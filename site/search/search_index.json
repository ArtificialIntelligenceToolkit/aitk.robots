{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to aitk.robots \u00b6 For full documentation visit github.com/ArtificialIntelligenceToolkit/aitk.robots . Introduction \u00b6 Installation \u00b6","title":"Home"},{"location":"#welcome-to-aitkrobots","text":"For full documentation visit github.com/ArtificialIntelligenceToolkit/aitk.robots .","title":"Welcome to aitk.robots"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"camera/","text":"Camera \u00b6 __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = 'camera' , samples = 1 , ** kwargs ) special \u00b6 A camera device. Parameters: Name Type Description Default width (int) width of camera in pixels 64 height (int) height of camera in pixels 32 fov (number) width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. 30 colorsFadeWithDistance (float) colors get darker faster with larger value 1.0 sizeFadeWithDistance (float) size gets smaller faster with with larger value 0.8 reflectGround (bool) ground reflects for 3D point cloud True reflectSky (bool) sky reflects for 3D point cloud False max_range (int) maximum range of camera 1000 name (str) the name of the camera 'camera' samples (int) how many pixels should it sample 1 Source code in robots/devices/cameras.py def __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = \"camera\" , samples = 1 , ** kwargs ): \"\"\" A camera device. Args: width: (int) width of camera in pixels height: (int) height of camera in pixels fov: (number) width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. colorsFadeWithDistance: (float) colors get darker faster with larger value sizeFadeWithDistance: (float) size gets smaller faster with with larger value reflectGround: (bool) ground reflects for 3D point cloud reflectSky: (bool) sky reflects for 3D point cloud max_range: (int) maximum range of camera name: (str) the name of the camera samples: (int) how many pixels should it sample Note: currently the camera faces forward. \"\"\" config = { \"width\" : width , \"height\" : height , \"fov\" : fov , \"colorsFadeWithDistance\" : colorsFadeWithDistance , \"sizeFadeWithDistance\" : sizeFadeWithDistance , \"reflectGround\" : reflectGround , \"reflectSky\" : reflectSky , \"max_range\" : max_range , \"name\" : name , \"samples\" : samples , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) draw ( self , backend ) \u00b6 Currently, cameras are fixed at 0,0 and face forwards. Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Currently, cameras are fixed at 0,0 and face forwards. \"\"\" backend . set_fill ( Color ( 0 , 64 , 0 )) backend . strokeStyle ( None , 0 ) backend . draw_rect ( 5.0 , - 3.33 , 1.33 , 6.33 ) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a + self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , - self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , - self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a - self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) get_fov ( self ) \u00b6 Get the field of view angle in degrees. Source code in robots/devices/cameras.py def get_fov ( self ): \"\"\" Get the field of view angle in degrees. \"\"\" return self . fov * ONE80_OVER_PI get_height ( self ) \u00b6 Get the height in pixels of the camera. Source code in robots/devices/cameras.py def get_height ( self ): \"\"\" Get the height in pixels of the camera. \"\"\" return self . cameraShape [ 1 ] get_max ( self ) \u00b6 Get the maximum distance in CM the camera can see. Source code in robots/devices/cameras.py def get_max ( self ): \"\"\" Get the maximum distance in CM the camera can see. \"\"\" return self . max_range get_name ( self ) \u00b6 Get the name of the camera. Source code in robots/devices/cameras.py def get_name ( self ): \"\"\" Get the name of the camera. \"\"\" return self . name get_width ( self ) \u00b6 Get the width in pixels of the camera. Source code in robots/devices/cameras.py def get_width ( self ): \"\"\" Get the width in pixels of the camera. \"\"\" return self . cameraShape [ 0 ] set_fov ( self , angle ) \u00b6 Set the field of view angle in degrees of the camera. Parameters: Name Type Description Default angle (number) angle in degrees of field of view required Source code in robots/devices/cameras.py def set_fov ( self , angle ): \"\"\" Set the field of view angle in degrees of the camera. Args: angle: (number) angle in degrees of field of view \"\"\" # given in degrees # save in radians # scale = min(max(angle / 6.0, 0.0), 1.0) self . fov = angle * PI_OVER_180 # self.sizeFadeWithDistance = scale self . reset () set_height ( self , height ) \u00b6 Set the height of the camera in pixels. Parameters: Name Type Description Default height (int) height of camera in pixels required Source code in robots/devices/cameras.py def set_height ( self , height ): \"\"\" Set the height of the camera in pixels. Args: height: (int) height of camera in pixels \"\"\" self . cameraShape [ 1 ] = height self . reset () set_max ( self , max_range ) \u00b6 Set the maximum distance the camera can see. Parameters: Name Type Description Default max_range (number) distance (in CM) the camera can see required Source code in robots/devices/cameras.py def set_max ( self , max_range ): \"\"\" Set the maximum distance the camera can see. Args: max_range: (number) distance (in CM) the camera can see \"\"\" self . max_range = max_range set_name ( self , name ) \u00b6 Set the name of the camera. Parameters: Name Type Description Default name (str) the name of the camera required Source code in robots/devices/cameras.py def set_name ( self , name ): \"\"\" Set the name of the camera. Args: name: (str) the name of the camera \"\"\" self . name = name set_size ( self , width , height ) \u00b6 Set the height and width of the camera in pixels. Parameters: Name Type Description Default width (int) width of camera in pixels required height (int) height of camera in pixels required Source code in robots/devices/cameras.py def set_size ( self , width , height ): \"\"\" Set the height and width of the camera in pixels. Args: width: (int) width of camera in pixels height: (int) height of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . cameraShape [ 1 ] = height self . reset () set_width ( self , width ) \u00b6 Set the width of the camera in pixels. Parameters: Name Type Description Default width (int) width of camera in pixels required Source code in robots/devices/cameras.py def set_width ( self , width ): \"\"\" Set the width of the camera in pixels. Args: width: (int) width of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . reset () update ( self , draw_list = None ) \u00b6 Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. \"\"\" pass","title":"Camera"},{"location":"camera/#camera","text":"","title":"Camera"},{"location":"camera/#aitk.robots.devices.cameras.Camera.__init__","text":"A camera device. Parameters: Name Type Description Default width (int) width of camera in pixels 64 height (int) height of camera in pixels 32 fov (number) width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. 30 colorsFadeWithDistance (float) colors get darker faster with larger value 1.0 sizeFadeWithDistance (float) size gets smaller faster with with larger value 0.8 reflectGround (bool) ground reflects for 3D point cloud True reflectSky (bool) sky reflects for 3D point cloud False max_range (int) maximum range of camera 1000 name (str) the name of the camera 'camera' samples (int) how many pixels should it sample 1 Source code in robots/devices/cameras.py def __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = \"camera\" , samples = 1 , ** kwargs ): \"\"\" A camera device. Args: width: (int) width of camera in pixels height: (int) height of camera in pixels fov: (number) width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. colorsFadeWithDistance: (float) colors get darker faster with larger value sizeFadeWithDistance: (float) size gets smaller faster with with larger value reflectGround: (bool) ground reflects for 3D point cloud reflectSky: (bool) sky reflects for 3D point cloud max_range: (int) maximum range of camera name: (str) the name of the camera samples: (int) how many pixels should it sample Note: currently the camera faces forward. \"\"\" config = { \"width\" : width , \"height\" : height , \"fov\" : fov , \"colorsFadeWithDistance\" : colorsFadeWithDistance , \"sizeFadeWithDistance\" : sizeFadeWithDistance , \"reflectGround\" : reflectGround , \"reflectSky\" : reflectSky , \"max_range\" : max_range , \"name\" : name , \"samples\" : samples , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.draw","text":"Currently, cameras are fixed at 0,0 and face forwards. Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Currently, cameras are fixed at 0,0 and face forwards. \"\"\" backend . set_fill ( Color ( 0 , 64 , 0 )) backend . strokeStyle ( None , 0 ) backend . draw_rect ( 5.0 , - 3.33 , 1.33 , 6.33 ) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a + self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , - self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , - self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a - self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ])","title":"draw()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_fov","text":"Get the field of view angle in degrees. Source code in robots/devices/cameras.py def get_fov ( self ): \"\"\" Get the field of view angle in degrees. \"\"\" return self . fov * ONE80_OVER_PI","title":"get_fov()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_height","text":"Get the height in pixels of the camera. Source code in robots/devices/cameras.py def get_height ( self ): \"\"\" Get the height in pixels of the camera. \"\"\" return self . cameraShape [ 1 ]","title":"get_height()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_max","text":"Get the maximum distance in CM the camera can see. Source code in robots/devices/cameras.py def get_max ( self ): \"\"\" Get the maximum distance in CM the camera can see. \"\"\" return self . max_range","title":"get_max()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_name","text":"Get the name of the camera. Source code in robots/devices/cameras.py def get_name ( self ): \"\"\" Get the name of the camera. \"\"\" return self . name","title":"get_name()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_width","text":"Get the width in pixels of the camera. Source code in robots/devices/cameras.py def get_width ( self ): \"\"\" Get the width in pixels of the camera. \"\"\" return self . cameraShape [ 0 ]","title":"get_width()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_fov","text":"Set the field of view angle in degrees of the camera. Parameters: Name Type Description Default angle (number) angle in degrees of field of view required Source code in robots/devices/cameras.py def set_fov ( self , angle ): \"\"\" Set the field of view angle in degrees of the camera. Args: angle: (number) angle in degrees of field of view \"\"\" # given in degrees # save in radians # scale = min(max(angle / 6.0, 0.0), 1.0) self . fov = angle * PI_OVER_180 # self.sizeFadeWithDistance = scale self . reset ()","title":"set_fov()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_height","text":"Set the height of the camera in pixels. Parameters: Name Type Description Default height (int) height of camera in pixels required Source code in robots/devices/cameras.py def set_height ( self , height ): \"\"\" Set the height of the camera in pixels. Args: height: (int) height of camera in pixels \"\"\" self . cameraShape [ 1 ] = height self . reset ()","title":"set_height()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_max","text":"Set the maximum distance the camera can see. Parameters: Name Type Description Default max_range (number) distance (in CM) the camera can see required Source code in robots/devices/cameras.py def set_max ( self , max_range ): \"\"\" Set the maximum distance the camera can see. Args: max_range: (number) distance (in CM) the camera can see \"\"\" self . max_range = max_range","title":"set_max()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_name","text":"Set the name of the camera. Parameters: Name Type Description Default name (str) the name of the camera required Source code in robots/devices/cameras.py def set_name ( self , name ): \"\"\" Set the name of the camera. Args: name: (str) the name of the camera \"\"\" self . name = name","title":"set_name()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_size","text":"Set the height and width of the camera in pixels. Parameters: Name Type Description Default width (int) width of camera in pixels required height (int) height of camera in pixels required Source code in robots/devices/cameras.py def set_size ( self , width , height ): \"\"\" Set the height and width of the camera in pixels. Args: width: (int) width of camera in pixels height: (int) height of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . cameraShape [ 1 ] = height self . reset ()","title":"set_size()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_width","text":"Set the width of the camera in pixels. Parameters: Name Type Description Default width (int) width of camera in pixels required Source code in robots/devices/cameras.py def set_width ( self , width ): \"\"\" Set the width of the camera in pixels. Args: width: (int) width of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . reset ()","title":"set_width()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.update","text":"Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. \"\"\" pass","title":"update()"},{"location":"robot/","text":"Robot \u00b6 __init__ ( self , x = 0 , y = 0 , a = 0 , color = 'red' , name = 'Robbie' , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ) special \u00b6 A simulated robot. Parameters: Name Type Description Default x (int) starting location in the horizontal direction. Leave 0 to place in a random location. 0 y (int) starting location in the horizontal direction. Leave 0 to place in a random location. 0 a (number) starting angle in degrees. 0 color (str) the name of a color 'red' name (str) a name to give your robot 'Robbie' do_trace (bool) should the robot leave a trace? True height (number) height of robot (use number < 1) 0.25 max_trace_length (number) max length of trace, in seconds 10 state (dict) serializable memory for a robot required va, vx, vy (numbers) velocities required tva, tvx, tvy (numbers) target velocities required va_max, vx_max, vy_max (numbers) max velocities required va_ramp, vx_ramp, vy_ramp (numbers) linear accelerations required image_data [\"dataset-name\", index] to use a 3D set of images required body data structure that defines a robot body required devices list of serialized devices required Source code in robots/robot.py def __init__ ( self , x = 0 , y = 0 , a = 0 , color = \"red\" , name = \"Robbie\" , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ): \"\"\" A simulated robot. Args: x: (int) starting location in the horizontal direction. Leave 0 to place in a random location. y: (int) starting location in the horizontal direction. Leave 0 to place in a random location. a: (number) starting angle in degrees. color: (str) the name of a color name: (str) a name to give your robot do_trace: (bool) should the robot leave a trace? height: (number) height of robot (use number < 1) max_trace_length: (number) max length of trace, in seconds state: (dict) serializable memory for a robot va, vx, vy: (numbers) velocities tva, tvx, tvy: (numbers) target velocities va_max, vx_max, vy_max: (numbers) max velocities va_ramp, vx_ramp, vy_ramp: (numbers) linear accelerations image_data: [\"dataset-name\", index] to use a 3D set of images body: data structure that defines a robot body devices: list of serialized devices \"\"\" # Get the args: config = { \"x\" : x , \"y\" : y , \"a\" : a , # degrees in the config file \"color\" : color , \"name\" : name , \"do_trace\" : do_trace , \"height\" : height , \"max_trace_length\" : max_trace_length , } # Update from the kwargs: config . update ( kwargs ) self . world = None self . _devices = [] self . _initialize () self . from_json ( config ) add_device ( self , device ) \u00b6 Add a device to a robot. Source code in robots/robot.py def add_device ( self , device ): \"\"\" Add a device to a robot. \"\"\" if device not in self . _devices : device . robot = self self . _devices . append ( device ) if self . world is not None : self . world . update () # request draw else : raise Exception ( \"Can't add the same device to a robot more than once.\" ) add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ) \u00b6 Adds a ring of devices at a given distance from the center of the robot. Parameters: Name Type Description Default device_class a class or function that receives position, a, and kwargs, and returns a device required distance_from_center in CM required start_degree angle of first device (0 points right) required stop_degree angle of stop degree (counter clockwise) required count number of sensors to add required kwargs additional args to pass to device_class {} Examples: >>> robot . add_device_ring ( RangeSensor , 10 , 0 , 359 , 6 , width = 20 ) Source code in robots/robot.py def add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ): \"\"\" Adds a ring of devices at a given distance from the center of the robot. Args: device_class: a class or function that receives position, a, and kwargs, and returns a device distance_from_center: in CM start_degree: angle of first device (0 points right) stop_degree: angle of stop degree (counter clockwise) count: number of sensors to add kwargs: additional args to pass to device_class Example: ```python >>> robot.add_device_ring(RangeSensor, 10, 0, 359, 6, width=20) ``` \"\"\" span = stop_degree - start_degree step_angle = span / count for angle in arange ( start_degree , stop_degree , step_angle ): x , y = rotate_around ( 0 , 0 , distance_from_center , - angle * PI_OVER_180 ) self . add_device ( device_class ( position = ( x , y ), a = angle , ** kwargs )) backward ( self , translate ) \u00b6 Set the target translate velocity. translate should be between 0 and 1, inclusive. Source code in robots/robot.py def backward ( self , translate ): \"\"\" Set the target translate velocity. translate should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( - translate * self . vx_max , 1 ) else : print ( \"backward value is out of range; should be between 0 and 1, inclusive\" ) cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ) \u00b6 Cast a ray into this world and see what it hits. Returns list of hits, furthest away first (back to front) Source code in robots/robot.py def cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ): \"\"\" Cast a ray into this world and see what it hits. Returns list of hits, furthest away first (back to front) \"\"\" return cast_ray ( self . world , self , x1 , y1 , a , maxRange , x2 , y2 , ignore_robots ) del_device ( self , device ) \u00b6 Remove a device from a robot. Source code in robots/robot.py def del_device ( self , device ): \"\"\" Remove a device from a robot. \"\"\" if isinstance ( device , ( str , int )): device = self [ device ] if device in self . _devices : device . robot = None self . _devices . remove ( device ) else : raise Exception ( \"Device %r is not on robot.\" % device ) display ( self , size = 100 ) \u00b6 Display the robot's image. Source code in robots/robot.py def display ( self , size = 100 ): \"\"\" Display the robot's image. \"\"\" image = self . get_image ( size = size ) display ( image ) draw ( self , backend ) \u00b6 Draw the robot. Source code in robots/robot.py def draw ( self , backend ): \"\"\" Draw the robot. \"\"\" if self . do_trace : time_step = self . world . time_step if self . world is not None else 0.1 if self . max_trace_length > 0 : max_trace_length = int ( 1.0 / time_step * self . max_trace_length ) else : max_trace_length = 0 if max_trace_length == 0 : data = [] else : data = self . trace [ - max_trace_length :] # None indicates a segment break if all ( data ): # no segments segments = [[( point [ 0 ], point [ 1 ]) for ( point , direction ) in data ]] else : segments = [] current = [] for item in data : if item is None : segments . append ( current ) current = [] else : point , direction = item current . append (( point [ 0 ], point [ 1 ])) if current : segments . append ( current ) for segment in segments : backend . draw_lines ( segment , stroke_style = self . trace_color , ) self . trace = data backend . pushMatrix () backend . translate ( self . x , self . y ) backend . rotate ( self . a ) # Draw first: for device in self . _devices : if device . type == \"bulb\" : device . draw ( backend ) # body: for shape in self . body : shape_name , color , args = shape if self . stalled : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) if color is None : backend . set_fill ( self . color ) else : backend . set_fill ( Color ( color )) if shape_name == \"polygon\" : backend . draw_polygon ( args ) elif shape_name == \"rectangle\" : backend . draw_rect ( * args ) elif shape_name == \"ellipse\" : backend . draw_ellipse ( * args ) elif shape_name == \"circle\" : backend . draw_circle ( * args ) elif shape_name == \"line\" : backend . draw_line ( * args ) backend . noStroke () # Draw on top of robot: for device in self . _devices : if device . type != \"bulb\" : device . draw ( backend ) backend . popMatrix () text = self . _get_current_text ( self . world . time ) if text : backend . set_fill_style ( Color ( 255 )) pad = 10 box_pad = 5 width = self . world . _backend . char_width * len ( text ) height = 20 if self . x - pad - width < 0 : side = 1 # put on right else : side = - 1 # put on left if self . y - height < 0 : half = 1 # put on top else : half = - 1 # put on bottom points = [ ( self . x , self . y ), ( self . x + pad * side , self . y + height / 2 * half ), ( self . x + pad * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y ), ( self . x + pad * side , self . y ), ( self . x + pad * side , self . y + height / 4 * half ), ] backend . set_stroke_style ( Color ( 0 )) backend . set_fill_style ( Color ( 255 , 255 , 255 , 200 )) backend . draw_polygon ( points ) backend . set_fill_style ( Color ( 0 )) if side == 1 : # right if half == 1 : # bottom backend . text ( text , self . x + ( pad + box_pad ), self . y + box_pad ) else : # top backend . text ( text , self . x + ( pad + box_pad ), self . y - self . world . _backend . char_height - box_pad , ) else : # left if half == 1 : # bottom backend . text ( text , self . x - pad - width - box_pad , self . y + box_pad ) else : # top backend . text ( text , self . x - pad - width - box_pad , self . y - self . world . _backend . char_height - box_pad , ) eat ( self ) \u00b6 If the robot is close enough to food, then this will eat it, removing from the world, and requesting a redraw. Returns True if success, and False otherwise. Note: it must be within robot.eat_food_distance Source code in robots/robot.py def eat ( self ): \"\"\" If the robot is close enough to food, then this will eat it, removing from the world, and requesting a redraw. Returns True if success, and False otherwise. Note: it must be within robot.eat_food_distance \"\"\" success = False if self . world is not None : for food in self . world . _food [:]: # copy if distance ( self . x , self . y , food [ 0 ], food [ 1 ]) <= self . eat_food_distance : self . food_eaten += 1 success = True self . world . _food . remove ( food ) self . world . _grid . need_update = True self . world . update () # request draw return success forward ( self , translate ) \u00b6 Set the target translate velocity. Arg should be between 0 and 1, inclusive. Source code in robots/robot.py def forward ( self , translate ): \"\"\" Set the target translate velocity. Arg should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( translate * self . vx_max , 1 ) else : print ( \"forward value is out of range; should be between 0 and 1, inclusive\" ) from_json ( self , config ) \u00b6 Load a robot from a JSON config dict. Source code in robots/robot.py def from_json ( self , config ): \"\"\" Load a robot from a JSON config dict. \"\"\" DEVICES = importlib . import_module ( \"aitk.robots.devices\" ) valid_keys = set ([ \"name\" , \"state\" , \"do_trace\" , \"va\" , \"vx\" , \"vy\" , \"tva\" , \"tvx\" , \"tvy\" , \"x\" , \"y\" , \"a\" , \"va_max\" , \"vx_max\" , \"vy_max\" , \"va_ramp\" , \"vx_ramp\" , \"vy_ramp\" , \"image_data\" , \"height\" , \"color\" , \"max_trace_length\" , \"body\" , \"devices\" , ]) config_keys = set ( list ( config . keys ())) extra_keys = config_keys - valid_keys if len ( extra_keys ) > 0 : raise TypeError ( \"invalid key(s) for robot config: %r \" % extra_keys ) if \"name\" in config : self . name = config [ \"name\" ] if \"state\" in config : self . state = config [ \"state\" ] if \"do_trace\" in config : self . do_trace = config [ \"do_trace\" ] if \"va\" in config : self . va = config [ \"va\" ] if \"vx\" in config : self . vx = config [ \"vx\" ] if \"vy\" in config : self . vy = config [ \"vy\" ] if \"tva\" in config : self . tva = config [ \"tva\" ] if \"tvx\" in config : self . tvx = config [ \"tvx\" ] if \"tvy\" in config : self . tvy = config [ \"tvy\" ] if \"va_max\" in config : self . va_max = config [ \"va_max\" ] if \"vx_max\" in config : self . vx_max = config [ \"vx_max\" ] if \"vy_max\" in config : self . vy_max = config [ \"vy_max\" ] if \"va_ramp\" in config : self . va_ramp = config [ \"va_ramp\" ] if \"vx_ramp\" in config : self . vx_ramp = config [ \"vx_ramp\" ] if \"vy_ramp\" in config : self . vy_ramp = config [ \"vy_ramp\" ] if \"x\" in config : self . x = config [ \"x\" ] if \"y\" in config : self . y = config [ \"y\" ] if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"image_data\" in config : self . image_data = config [ \"image_data\" ] # [\"dataset\", index] if len ( self . image_data ) == 0 : self . get_dataset_image = None else : self . get_dataset_image = get_dataset ( self . image_data [ 0 ]) if \"height\" in config : self . height = config [ \"height\" ] # ratio, 0 to 1 of height if \"color\" in config : self . _set_color ( config [ \"color\" ]) if \"max_trace_length\" in config : self . max_trace_length = config [ \"max_trace_length\" ] if \"body\" in config : self . body [:] = config [ \"body\" ] self . _init_boundingbox () if \"devices\" in config : # FIXME: raise if lengths/types don't match for i , deviceConfig in enumerate ( config [ \"devices\" ]): if i < len ( self ): if self [ i ] . __class__ . __name__ == deviceConfig [ \"class\" ]: # already a device, let's reuse it: device = self [ i ] device . initialize () device . from_json ( deviceConfig ) else : raise Exception ( \"can't use reset; config changed; use load_world\" ) else : device = None try : device_class = getattr ( DEVICES , deviceConfig [ \"class\" ]) device = device_class ( ** deviceConfig ) except Exception : raise Exception ( \"Failed to create device: %s (** %s )\" % ( deviceConfig [ \"class\" ], deviceConfig ) ) if device : self . add_device ( device ) get_image ( self , size = 100 ) \u00b6 Get an image of the robot. Parameters: Name Type Description Default size (int) size in pixels around robot 100 Source code in robots/robot.py def get_image ( self , size = 100 ): \"\"\" Get an image of the robot. Args: size: (int) size in pixels around robot \"\"\" picture = self . world . get_image () start_x = round ( max ( self . x * self . world . scale - size / 2 , 0 ) ) start_y = round ( max ( self . y * self . world . scale - size / 2 , 0 ) ) rectangle = ( start_x , start_y , min ( start_x + size , self . world . width * self . world . scale ), min ( start_y + size , self . world . height * self . world . scale , ), ) picture = picture . crop ( rectangle ) return picture get_image_3d ( self , degrees ) \u00b6 Return the 3D image in the proper angle. Source code in robots/robot.py def get_image_3d ( self , degrees ): \"\"\" Return the 3D image in the proper angle. \"\"\" return self . get_dataset_image ( self . image_data [ 1 ], degrees ) get_max_trace_length ( self ) \u00b6 Get the max step lengths of the trace. Source code in robots/robot.py def get_max_trace_length ( self ): \"\"\" Get the max step lengths of the trace. \"\"\" return self . max_trace_length get_pose ( self ) \u00b6 Get the pose of the robot (x, y, a) where a (direction) is in degrees. Source code in robots/robot.py def get_pose ( self ): \"\"\" Get the pose of the robot (x, y, a) where a (direction) is in degrees. \"\"\" return ( self . x , self . y , world_to_degrees ( self . a )) get_time ( self ) \u00b6 Get the clock time of the world. Source code in robots/robot.py def get_time ( self ): \"\"\" Get the clock time of the world. \"\"\" if self . world : return self . world . time get_velocity ( self , target = False ) \u00b6 Get the current (or target) translate and rotate velocities of the robot. Source code in robots/robot.py def get_velocity ( self , target = False ): \"\"\" Get the current (or target) translate and rotate velocities of the robot. \"\"\" if not target : return ( self . vx / self . vx_max , self . va / self . va_max ) else : return ( self . tvx / self . vx_max , self . tva / self . va_max ) get_widget ( self , size = None , show_robot = None , attributes = None ) \u00b6 Get the robot widget. Parameters: Name Type Description Default size (int) size in pixels around robot None show_robot (bool) show picture of robot None attributes (list) items to include, or \"all\" None Source code in robots/robot.py def get_widget ( self , size = None , show_robot = None , attributes = None ): \"\"\" Get the robot widget. Args: size: (int) size in pixels around robot show_robot: (bool) show picture of robot attributes: (list) items to include, or \"all\" \"\"\" from .watchers import RobotWatcher if self . _watcher is None : size = size if size is not None else 100 show_robot = show_robot if show_robot is not None else True attributes = attributes if attributes is not None else \"all\" self . _watcher = RobotWatcher ( self , size = size , show_robot = show_robot , attributes = attributes ) self . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( size = size , show_robot = show_robot , attributes = attributes ) self . _watcher . draw () return self . _watcher . get_widget () has_image ( self ) \u00b6 Does this robot have an associated 3D set of images from a dataset? Source code in robots/robot.py def has_image ( self ): \"\"\" Does this robot have an associated 3D set of images from a dataset? \"\"\" return self . get_dataset_image is not None motors ( self , left , right ) \u00b6 A move function that takes desired motor values and converts to trans and rotate. Source code in robots/robot.py def motors ( self , left , right ): \"\"\" A move function that takes desired motor values and converts to trans and rotate. \"\"\" trans = ( right + left ) / 2.0 rotate = ( right - left ) / 2.0 self . move ( trans , rotate ) move ( self , translate , rotate ) \u00b6 Set the target translate and rotate velocities. Args should be between -1 and 1. Source code in robots/robot.py def move ( self , translate , rotate ): \"\"\" Set the target translate and rotate velocities. Args should be between -1 and 1. \"\"\" # values between -1 and 1 # compute target velocities if self . world is not None : if self . world . status != \"running\" : print ( \"This world is not running\" ) if translate is not None : self . tvx = round ( translate * self . vx_max , 1 ) if rotate is not None : self . tva = round ( rotate * self . va_max , 1 ) pen_down ( self , color = None , radius = 1 ) \u00b6 Put the pen down to change the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_down ( self , color = None , radius = 1 ): \"\"\" Put the pen down to change the color of the background image. Note: not for use in a robot in a recorder. \"\"\" from PIL import Image color = color if color is not None else self . color self . pen = ( Color ( color ), radius ) if self . world is not None : if self . world . _ground_image is None : image = Image . new ( \"RGBA\" , ( self . world . width , self . world . height ), color = \"white\" ) filename = \"ground_image.png\" image . save ( filename ) self . world . set_ground_image ( filename ) pen_up ( self ) \u00b6 Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_up ( self ): \"\"\" Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. \"\"\" self . pen = ( None , 0 ) reset ( self ) \u00b6 Reset the robot's internal stuff. Typeocally, called from the world. Source code in robots/robot.py def reset ( self ): \"\"\" Reset the robot's internal stuff. Typeocally, called from the world. \"\"\" self . trace [:] = [] self . text_trace [:] = [] self . pen_trace [:] = [] reverse ( self ) \u00b6 Flip the target x and a velocities from negative to positive or from positive to negative. Source code in robots/robot.py def reverse ( self ): \"\"\" Flip the target x and a velocities from negative to positive or from positive to negative. \"\"\" self . tvx = - self . tvx self . tva = - self . tva rotate ( self , rotate ) \u00b6 Set the target rotate velocity. Arg should be between -1 and 1. Source code in robots/robot.py def rotate ( self , rotate ): \"\"\" Set the target rotate velocity. Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tva = rotate * self . va_max set_color ( self , color ) \u00b6 Set the color of a robot, and its trace. Source code in robots/robot.py def set_color ( self , color ): \"\"\" Set the color of a robot, and its trace. \"\"\" self . _set_color ( color ) set_max_trace_length ( self , seconds ) \u00b6 Set the max length of trace, in seconds. Parameters: Name Type Description Default seconds (number) the length of trace required Source code in robots/robot.py def set_max_trace_length ( self , seconds ): \"\"\" Set the max length of trace, in seconds. Args: seconds: (number) the length of trace \"\"\" self . max_trace_length = seconds set_pose ( self , x = None , y = None , a = None , clear_trace = True ) \u00b6 Set the pose of the robot. a is in degrees. Note: the robot must be in a world. Source code in robots/robot.py def set_pose ( self , x = None , y = None , a = None , clear_trace = True ): \"\"\" Set the pose of the robot. a is in degrees. Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add to world before setting pose\" ) else : if a is not None : a = degrees_to_world ( a ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save () set_random_pose ( self , clear_trace = True ) \u00b6 Set the pose of the robot to a random location. Note: the robot must be in a world. Source code in robots/robot.py def set_random_pose ( self , clear_trace = True ): \"\"\" Set the pose of the robot to a random location. Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add robot to world before calling set_random_pose\" ) else : # Direction is in radians, in world coordinates: x , y , a = self . world . _find_random_pose ( self ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save () speak ( self , text = None ) \u00b6 Show some text in the robot's speech bubble. Parameters: Name Type Description Default text (str) the text to show; use None to clear None Source code in robots/robot.py def speak ( self , text = None ): \"\"\" Show some text in the robot's speech bubble. Args: text: (str) the text to show; use None to clear Note: not for use in a robot in a recorder. \"\"\" if self . world : if self . world . _recording : if len ( self . text_trace ) > 0 : # If same as last, don't add again if self . text_trace [ - 1 ][ 1 ] != text : self . text_trace . append (( self . world . time , text )) else : self . text_trace . append (( self . world . time , text )) else : self . text_trace [:] = [( self . world . time , text )] stop ( self ) \u00b6 Set the target velocities to zeros. Source code in robots/robot.py def stop ( self ): \"\"\" Set the target velocities to zeros. \"\"\" self . tvx = 0.0 self . tvy = 0.0 self . tva = 0.0 summary ( self ) \u00b6 Get a summary of information about the robot. Source code in robots/robot.py def summary ( self ): \"\"\" Get a summary of information about the robot. \"\"\" if len ( self . _devices ) == 0 : print ( \" This robot has no devices.\" ) else : for i , device in enumerate ( self . _devices ): print ( \" robot[ %s or %r or %r ]: %r \" % ( i , device . type , device . name , device ) ) print ( \" \" + ( \"-\" * 25 )) to_json ( self ) \u00b6 Get this robot as a JSON config file. Source code in robots/robot.py def to_json ( self ): \"\"\" Get this robot as a JSON config file. \"\"\" robot_json = { \"name\" : self . name , \"state\" : self . state , \"va\" : self . va , \"vx\" : self . vx , \"vy\" : self . vy , \"tva\" : self . tva , \"tvx\" : self . tvx , \"tvy\" : self . tvy , \"va_max\" : self . va_max , \"vx_max\" : self . vx_max , \"vy_max\" : self . vy_max , \"va_ramp\" : self . va_ramp , \"vx_ramp\" : self . vx_ramp , \"vy_ramp\" : self . vy_ramp , \"x\" : self . x , \"y\" : self . y , \"a\" : world_to_degrees ( self . a ), \"image_data\" : self . image_data , \"height\" : self . height , \"color\" : str ( self . color ), \"max_trace_length\" : self . max_trace_length , \"body\" : self . body , \"devices\" : [ device . to_json () for device in self . _devices ], \"do_trace\" : self . do_trace , } return robot_json translate ( self , translate ) \u00b6 Set the target translate velocity. Arg should be between -1 and 1. Source code in robots/robot.py def translate ( self , translate ): \"\"\" Set the target translate velocity. Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tvx = round ( translate * self . vx_max , 1 ) update ( self , draw_list = None ) \u00b6 Update the robot, and devices. Source code in robots/robot.py def update ( self , draw_list = None ): \"\"\" Update the robot, and devices. \"\"\" # Wrapped worlds: wrapped = False if self . x < 0 : self . x = self . world . width wrapped = True elif self . x > self . world . width : self . x = 0 wrapped = True if self . y < 0 : self . y = self . world . height wrapped = True elif self . y > self . world . height : self . y = 0 wrapped = True if wrapped : self . trace . append ( None ) self . _init_boundingbox () if self . world . debug and draw_list is not None : draw_list . append (( \"strokeStyle\" , ( Color ( 255 ), 1 ))) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 0 ] . p1 . x , self . _bounding_lines [ 0 ] . p1 . y , self . _bounding_lines [ 0 ] . p2 . x , self . _bounding_lines [ 0 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 1 ] . p1 . x , self . _bounding_lines [ 1 ] . p1 . y , self . _bounding_lines [ 1 ] . p2 . x , self . _bounding_lines [ 1 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 2 ] . p1 . x , self . _bounding_lines [ 2 ] . p1 . y , self . _bounding_lines [ 2 ] . p2 . x , self . _bounding_lines [ 2 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 3 ] . p1 . x , self . _bounding_lines [ 3 ] . p1 . y , self . _bounding_lines [ 3 ] . p2 . x , self . _bounding_lines [ 3 ] . p2 . y , ), ) ) # Devices: for device in self . _devices : device . update ( draw_list ) # Update recording info: if self . world . _recording : if len ( self . pen_trace ) > 0 : # color of pen: if self . pen_trace [ - 1 ][ 1 ][ 0 ] != self . pen [ 0 ]: self . pen_trace . append (( self . world . time , self . pen )) # same pen color, do nothing elif self . pen != ( None , 0 ): self . pen_trace . append (( self . world . time , self . pen )) # else do nothing else : # not recording if self . pen == ( None , 0 ): self . pen_trace [:] = [] else : self . pen_trace [:] = [( self . world . time , self . pen )] # Alter world: self . _update_ground_image ( self . world . time ) return watch ( self , size = None , show_robot = None , attributes = None ) \u00b6 Watch the robot stats with live updates. Parameters: Name Type Description Default size (int) size in pixels around robot None show_robot (bool) show picture of robot None attributes (list) items to include, or \"all\" None Source code in robots/robot.py def watch ( self , size = None , show_robot = None , attributes = None ): \"\"\" Watch the robot stats with live updates. Args: size: (int) size in pixels around robot show_robot: (bool) show picture of robot attributes: (list) items to include, or \"all\" \"\"\" widget = self . get_widget ( size = size , show_robot = show_robot , attributes = attributes , ) display ( widget )","title":"Robot"},{"location":"robot/#robot","text":"","title":"Robot"},{"location":"robot/#aitk.robots.robot.Robot.__init__","text":"A simulated robot. Parameters: Name Type Description Default x (int) starting location in the horizontal direction. Leave 0 to place in a random location. 0 y (int) starting location in the horizontal direction. Leave 0 to place in a random location. 0 a (number) starting angle in degrees. 0 color (str) the name of a color 'red' name (str) a name to give your robot 'Robbie' do_trace (bool) should the robot leave a trace? True height (number) height of robot (use number < 1) 0.25 max_trace_length (number) max length of trace, in seconds 10 state (dict) serializable memory for a robot required va, vx, vy (numbers) velocities required tva, tvx, tvy (numbers) target velocities required va_max, vx_max, vy_max (numbers) max velocities required va_ramp, vx_ramp, vy_ramp (numbers) linear accelerations required image_data [\"dataset-name\", index] to use a 3D set of images required body data structure that defines a robot body required devices list of serialized devices required Source code in robots/robot.py def __init__ ( self , x = 0 , y = 0 , a = 0 , color = \"red\" , name = \"Robbie\" , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ): \"\"\" A simulated robot. Args: x: (int) starting location in the horizontal direction. Leave 0 to place in a random location. y: (int) starting location in the horizontal direction. Leave 0 to place in a random location. a: (number) starting angle in degrees. color: (str) the name of a color name: (str) a name to give your robot do_trace: (bool) should the robot leave a trace? height: (number) height of robot (use number < 1) max_trace_length: (number) max length of trace, in seconds state: (dict) serializable memory for a robot va, vx, vy: (numbers) velocities tva, tvx, tvy: (numbers) target velocities va_max, vx_max, vy_max: (numbers) max velocities va_ramp, vx_ramp, vy_ramp: (numbers) linear accelerations image_data: [\"dataset-name\", index] to use a 3D set of images body: data structure that defines a robot body devices: list of serialized devices \"\"\" # Get the args: config = { \"x\" : x , \"y\" : y , \"a\" : a , # degrees in the config file \"color\" : color , \"name\" : name , \"do_trace\" : do_trace , \"height\" : height , \"max_trace_length\" : max_trace_length , } # Update from the kwargs: config . update ( kwargs ) self . world = None self . _devices = [] self . _initialize () self . from_json ( config )","title":"__init__()"},{"location":"robot/#aitk.robots.robot.Robot.add_device","text":"Add a device to a robot. Source code in robots/robot.py def add_device ( self , device ): \"\"\" Add a device to a robot. \"\"\" if device not in self . _devices : device . robot = self self . _devices . append ( device ) if self . world is not None : self . world . update () # request draw else : raise Exception ( \"Can't add the same device to a robot more than once.\" )","title":"add_device()"},{"location":"robot/#aitk.robots.robot.Robot.add_device_ring","text":"Adds a ring of devices at a given distance from the center of the robot. Parameters: Name Type Description Default device_class a class or function that receives position, a, and kwargs, and returns a device required distance_from_center in CM required start_degree angle of first device (0 points right) required stop_degree angle of stop degree (counter clockwise) required count number of sensors to add required kwargs additional args to pass to device_class {} Examples: >>> robot . add_device_ring ( RangeSensor , 10 , 0 , 359 , 6 , width = 20 ) Source code in robots/robot.py def add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ): \"\"\" Adds a ring of devices at a given distance from the center of the robot. Args: device_class: a class or function that receives position, a, and kwargs, and returns a device distance_from_center: in CM start_degree: angle of first device (0 points right) stop_degree: angle of stop degree (counter clockwise) count: number of sensors to add kwargs: additional args to pass to device_class Example: ```python >>> robot.add_device_ring(RangeSensor, 10, 0, 359, 6, width=20) ``` \"\"\" span = stop_degree - start_degree step_angle = span / count for angle in arange ( start_degree , stop_degree , step_angle ): x , y = rotate_around ( 0 , 0 , distance_from_center , - angle * PI_OVER_180 ) self . add_device ( device_class ( position = ( x , y ), a = angle , ** kwargs ))","title":"add_device_ring()"},{"location":"robot/#aitk.robots.robot.Robot.backward","text":"Set the target translate velocity. translate should be between 0 and 1, inclusive. Source code in robots/robot.py def backward ( self , translate ): \"\"\" Set the target translate velocity. translate should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( - translate * self . vx_max , 1 ) else : print ( \"backward value is out of range; should be between 0 and 1, inclusive\" )","title":"backward()"},{"location":"robot/#aitk.robots.robot.Robot.cast_ray","text":"Cast a ray into this world and see what it hits. Returns list of hits, furthest away first (back to front) Source code in robots/robot.py def cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ): \"\"\" Cast a ray into this world and see what it hits. Returns list of hits, furthest away first (back to front) \"\"\" return cast_ray ( self . world , self , x1 , y1 , a , maxRange , x2 , y2 , ignore_robots )","title":"cast_ray()"},{"location":"robot/#aitk.robots.robot.Robot.del_device","text":"Remove a device from a robot. Source code in robots/robot.py def del_device ( self , device ): \"\"\" Remove a device from a robot. \"\"\" if isinstance ( device , ( str , int )): device = self [ device ] if device in self . _devices : device . robot = None self . _devices . remove ( device ) else : raise Exception ( \"Device %r is not on robot.\" % device )","title":"del_device()"},{"location":"robot/#aitk.robots.robot.Robot.display","text":"Display the robot's image. Source code in robots/robot.py def display ( self , size = 100 ): \"\"\" Display the robot's image. \"\"\" image = self . get_image ( size = size ) display ( image )","title":"display()"},{"location":"robot/#aitk.robots.robot.Robot.draw","text":"Draw the robot. Source code in robots/robot.py def draw ( self , backend ): \"\"\" Draw the robot. \"\"\" if self . do_trace : time_step = self . world . time_step if self . world is not None else 0.1 if self . max_trace_length > 0 : max_trace_length = int ( 1.0 / time_step * self . max_trace_length ) else : max_trace_length = 0 if max_trace_length == 0 : data = [] else : data = self . trace [ - max_trace_length :] # None indicates a segment break if all ( data ): # no segments segments = [[( point [ 0 ], point [ 1 ]) for ( point , direction ) in data ]] else : segments = [] current = [] for item in data : if item is None : segments . append ( current ) current = [] else : point , direction = item current . append (( point [ 0 ], point [ 1 ])) if current : segments . append ( current ) for segment in segments : backend . draw_lines ( segment , stroke_style = self . trace_color , ) self . trace = data backend . pushMatrix () backend . translate ( self . x , self . y ) backend . rotate ( self . a ) # Draw first: for device in self . _devices : if device . type == \"bulb\" : device . draw ( backend ) # body: for shape in self . body : shape_name , color , args = shape if self . stalled : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) if color is None : backend . set_fill ( self . color ) else : backend . set_fill ( Color ( color )) if shape_name == \"polygon\" : backend . draw_polygon ( args ) elif shape_name == \"rectangle\" : backend . draw_rect ( * args ) elif shape_name == \"ellipse\" : backend . draw_ellipse ( * args ) elif shape_name == \"circle\" : backend . draw_circle ( * args ) elif shape_name == \"line\" : backend . draw_line ( * args ) backend . noStroke () # Draw on top of robot: for device in self . _devices : if device . type != \"bulb\" : device . draw ( backend ) backend . popMatrix () text = self . _get_current_text ( self . world . time ) if text : backend . set_fill_style ( Color ( 255 )) pad = 10 box_pad = 5 width = self . world . _backend . char_width * len ( text ) height = 20 if self . x - pad - width < 0 : side = 1 # put on right else : side = - 1 # put on left if self . y - height < 0 : half = 1 # put on top else : half = - 1 # put on bottom points = [ ( self . x , self . y ), ( self . x + pad * side , self . y + height / 2 * half ), ( self . x + pad * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y ), ( self . x + pad * side , self . y ), ( self . x + pad * side , self . y + height / 4 * half ), ] backend . set_stroke_style ( Color ( 0 )) backend . set_fill_style ( Color ( 255 , 255 , 255 , 200 )) backend . draw_polygon ( points ) backend . set_fill_style ( Color ( 0 )) if side == 1 : # right if half == 1 : # bottom backend . text ( text , self . x + ( pad + box_pad ), self . y + box_pad ) else : # top backend . text ( text , self . x + ( pad + box_pad ), self . y - self . world . _backend . char_height - box_pad , ) else : # left if half == 1 : # bottom backend . text ( text , self . x - pad - width - box_pad , self . y + box_pad ) else : # top backend . text ( text , self . x - pad - width - box_pad , self . y - self . world . _backend . char_height - box_pad , )","title":"draw()"},{"location":"robot/#aitk.robots.robot.Robot.eat","text":"If the robot is close enough to food, then this will eat it, removing from the world, and requesting a redraw. Returns True if success, and False otherwise. Note: it must be within robot.eat_food_distance Source code in robots/robot.py def eat ( self ): \"\"\" If the robot is close enough to food, then this will eat it, removing from the world, and requesting a redraw. Returns True if success, and False otherwise. Note: it must be within robot.eat_food_distance \"\"\" success = False if self . world is not None : for food in self . world . _food [:]: # copy if distance ( self . x , self . y , food [ 0 ], food [ 1 ]) <= self . eat_food_distance : self . food_eaten += 1 success = True self . world . _food . remove ( food ) self . world . _grid . need_update = True self . world . update () # request draw return success","title":"eat()"},{"location":"robot/#aitk.robots.robot.Robot.forward","text":"Set the target translate velocity. Arg should be between 0 and 1, inclusive. Source code in robots/robot.py def forward ( self , translate ): \"\"\" Set the target translate velocity. Arg should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( translate * self . vx_max , 1 ) else : print ( \"forward value is out of range; should be between 0 and 1, inclusive\" )","title":"forward()"},{"location":"robot/#aitk.robots.robot.Robot.from_json","text":"Load a robot from a JSON config dict. Source code in robots/robot.py def from_json ( self , config ): \"\"\" Load a robot from a JSON config dict. \"\"\" DEVICES = importlib . import_module ( \"aitk.robots.devices\" ) valid_keys = set ([ \"name\" , \"state\" , \"do_trace\" , \"va\" , \"vx\" , \"vy\" , \"tva\" , \"tvx\" , \"tvy\" , \"x\" , \"y\" , \"a\" , \"va_max\" , \"vx_max\" , \"vy_max\" , \"va_ramp\" , \"vx_ramp\" , \"vy_ramp\" , \"image_data\" , \"height\" , \"color\" , \"max_trace_length\" , \"body\" , \"devices\" , ]) config_keys = set ( list ( config . keys ())) extra_keys = config_keys - valid_keys if len ( extra_keys ) > 0 : raise TypeError ( \"invalid key(s) for robot config: %r \" % extra_keys ) if \"name\" in config : self . name = config [ \"name\" ] if \"state\" in config : self . state = config [ \"state\" ] if \"do_trace\" in config : self . do_trace = config [ \"do_trace\" ] if \"va\" in config : self . va = config [ \"va\" ] if \"vx\" in config : self . vx = config [ \"vx\" ] if \"vy\" in config : self . vy = config [ \"vy\" ] if \"tva\" in config : self . tva = config [ \"tva\" ] if \"tvx\" in config : self . tvx = config [ \"tvx\" ] if \"tvy\" in config : self . tvy = config [ \"tvy\" ] if \"va_max\" in config : self . va_max = config [ \"va_max\" ] if \"vx_max\" in config : self . vx_max = config [ \"vx_max\" ] if \"vy_max\" in config : self . vy_max = config [ \"vy_max\" ] if \"va_ramp\" in config : self . va_ramp = config [ \"va_ramp\" ] if \"vx_ramp\" in config : self . vx_ramp = config [ \"vx_ramp\" ] if \"vy_ramp\" in config : self . vy_ramp = config [ \"vy_ramp\" ] if \"x\" in config : self . x = config [ \"x\" ] if \"y\" in config : self . y = config [ \"y\" ] if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"image_data\" in config : self . image_data = config [ \"image_data\" ] # [\"dataset\", index] if len ( self . image_data ) == 0 : self . get_dataset_image = None else : self . get_dataset_image = get_dataset ( self . image_data [ 0 ]) if \"height\" in config : self . height = config [ \"height\" ] # ratio, 0 to 1 of height if \"color\" in config : self . _set_color ( config [ \"color\" ]) if \"max_trace_length\" in config : self . max_trace_length = config [ \"max_trace_length\" ] if \"body\" in config : self . body [:] = config [ \"body\" ] self . _init_boundingbox () if \"devices\" in config : # FIXME: raise if lengths/types don't match for i , deviceConfig in enumerate ( config [ \"devices\" ]): if i < len ( self ): if self [ i ] . __class__ . __name__ == deviceConfig [ \"class\" ]: # already a device, let's reuse it: device = self [ i ] device . initialize () device . from_json ( deviceConfig ) else : raise Exception ( \"can't use reset; config changed; use load_world\" ) else : device = None try : device_class = getattr ( DEVICES , deviceConfig [ \"class\" ]) device = device_class ( ** deviceConfig ) except Exception : raise Exception ( \"Failed to create device: %s (** %s )\" % ( deviceConfig [ \"class\" ], deviceConfig ) ) if device : self . add_device ( device )","title":"from_json()"},{"location":"robot/#aitk.robots.robot.Robot.get_image","text":"Get an image of the robot. Parameters: Name Type Description Default size (int) size in pixels around robot 100 Source code in robots/robot.py def get_image ( self , size = 100 ): \"\"\" Get an image of the robot. Args: size: (int) size in pixels around robot \"\"\" picture = self . world . get_image () start_x = round ( max ( self . x * self . world . scale - size / 2 , 0 ) ) start_y = round ( max ( self . y * self . world . scale - size / 2 , 0 ) ) rectangle = ( start_x , start_y , min ( start_x + size , self . world . width * self . world . scale ), min ( start_y + size , self . world . height * self . world . scale , ), ) picture = picture . crop ( rectangle ) return picture","title":"get_image()"},{"location":"robot/#aitk.robots.robot.Robot.get_image_3d","text":"Return the 3D image in the proper angle. Source code in robots/robot.py def get_image_3d ( self , degrees ): \"\"\" Return the 3D image in the proper angle. \"\"\" return self . get_dataset_image ( self . image_data [ 1 ], degrees )","title":"get_image_3d()"},{"location":"robot/#aitk.robots.robot.Robot.get_max_trace_length","text":"Get the max step lengths of the trace. Source code in robots/robot.py def get_max_trace_length ( self ): \"\"\" Get the max step lengths of the trace. \"\"\" return self . max_trace_length","title":"get_max_trace_length()"},{"location":"robot/#aitk.robots.robot.Robot.get_pose","text":"Get the pose of the robot (x, y, a) where a (direction) is in degrees. Source code in robots/robot.py def get_pose ( self ): \"\"\" Get the pose of the robot (x, y, a) where a (direction) is in degrees. \"\"\" return ( self . x , self . y , world_to_degrees ( self . a ))","title":"get_pose()"},{"location":"robot/#aitk.robots.robot.Robot.get_time","text":"Get the clock time of the world. Source code in robots/robot.py def get_time ( self ): \"\"\" Get the clock time of the world. \"\"\" if self . world : return self . world . time","title":"get_time()"},{"location":"robot/#aitk.robots.robot.Robot.get_velocity","text":"Get the current (or target) translate and rotate velocities of the robot. Source code in robots/robot.py def get_velocity ( self , target = False ): \"\"\" Get the current (or target) translate and rotate velocities of the robot. \"\"\" if not target : return ( self . vx / self . vx_max , self . va / self . va_max ) else : return ( self . tvx / self . vx_max , self . tva / self . va_max )","title":"get_velocity()"},{"location":"robot/#aitk.robots.robot.Robot.get_widget","text":"Get the robot widget. Parameters: Name Type Description Default size (int) size in pixels around robot None show_robot (bool) show picture of robot None attributes (list) items to include, or \"all\" None Source code in robots/robot.py def get_widget ( self , size = None , show_robot = None , attributes = None ): \"\"\" Get the robot widget. Args: size: (int) size in pixels around robot show_robot: (bool) show picture of robot attributes: (list) items to include, or \"all\" \"\"\" from .watchers import RobotWatcher if self . _watcher is None : size = size if size is not None else 100 show_robot = show_robot if show_robot is not None else True attributes = attributes if attributes is not None else \"all\" self . _watcher = RobotWatcher ( self , size = size , show_robot = show_robot , attributes = attributes ) self . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( size = size , show_robot = show_robot , attributes = attributes ) self . _watcher . draw () return self . _watcher . get_widget ()","title":"get_widget()"},{"location":"robot/#aitk.robots.robot.Robot.has_image","text":"Does this robot have an associated 3D set of images from a dataset? Source code in robots/robot.py def has_image ( self ): \"\"\" Does this robot have an associated 3D set of images from a dataset? \"\"\" return self . get_dataset_image is not None","title":"has_image()"},{"location":"robot/#aitk.robots.robot.Robot.motors","text":"A move function that takes desired motor values and converts to trans and rotate. Source code in robots/robot.py def motors ( self , left , right ): \"\"\" A move function that takes desired motor values and converts to trans and rotate. \"\"\" trans = ( right + left ) / 2.0 rotate = ( right - left ) / 2.0 self . move ( trans , rotate )","title":"motors()"},{"location":"robot/#aitk.robots.robot.Robot.move","text":"Set the target translate and rotate velocities. Args should be between -1 and 1. Source code in robots/robot.py def move ( self , translate , rotate ): \"\"\" Set the target translate and rotate velocities. Args should be between -1 and 1. \"\"\" # values between -1 and 1 # compute target velocities if self . world is not None : if self . world . status != \"running\" : print ( \"This world is not running\" ) if translate is not None : self . tvx = round ( translate * self . vx_max , 1 ) if rotate is not None : self . tva = round ( rotate * self . va_max , 1 )","title":"move()"},{"location":"robot/#aitk.robots.robot.Robot.pen_down","text":"Put the pen down to change the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_down ( self , color = None , radius = 1 ): \"\"\" Put the pen down to change the color of the background image. Note: not for use in a robot in a recorder. \"\"\" from PIL import Image color = color if color is not None else self . color self . pen = ( Color ( color ), radius ) if self . world is not None : if self . world . _ground_image is None : image = Image . new ( \"RGBA\" , ( self . world . width , self . world . height ), color = \"white\" ) filename = \"ground_image.png\" image . save ( filename ) self . world . set_ground_image ( filename )","title":"pen_down()"},{"location":"robot/#aitk.robots.robot.Robot.pen_up","text":"Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_up ( self ): \"\"\" Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. \"\"\" self . pen = ( None , 0 )","title":"pen_up()"},{"location":"robot/#aitk.robots.robot.Robot.reset","text":"Reset the robot's internal stuff. Typeocally, called from the world. Source code in robots/robot.py def reset ( self ): \"\"\" Reset the robot's internal stuff. Typeocally, called from the world. \"\"\" self . trace [:] = [] self . text_trace [:] = [] self . pen_trace [:] = []","title":"reset()"},{"location":"robot/#aitk.robots.robot.Robot.reverse","text":"Flip the target x and a velocities from negative to positive or from positive to negative. Source code in robots/robot.py def reverse ( self ): \"\"\" Flip the target x and a velocities from negative to positive or from positive to negative. \"\"\" self . tvx = - self . tvx self . tva = - self . tva","title":"reverse()"},{"location":"robot/#aitk.robots.robot.Robot.rotate","text":"Set the target rotate velocity. Arg should be between -1 and 1. Source code in robots/robot.py def rotate ( self , rotate ): \"\"\" Set the target rotate velocity. Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tva = rotate * self . va_max","title":"rotate()"},{"location":"robot/#aitk.robots.robot.Robot.set_color","text":"Set the color of a robot, and its trace. Source code in robots/robot.py def set_color ( self , color ): \"\"\" Set the color of a robot, and its trace. \"\"\" self . _set_color ( color )","title":"set_color()"},{"location":"robot/#aitk.robots.robot.Robot.set_max_trace_length","text":"Set the max length of trace, in seconds. Parameters: Name Type Description Default seconds (number) the length of trace required Source code in robots/robot.py def set_max_trace_length ( self , seconds ): \"\"\" Set the max length of trace, in seconds. Args: seconds: (number) the length of trace \"\"\" self . max_trace_length = seconds","title":"set_max_trace_length()"},{"location":"robot/#aitk.robots.robot.Robot.set_pose","text":"Set the pose of the robot. a is in degrees. Note: the robot must be in a world. Source code in robots/robot.py def set_pose ( self , x = None , y = None , a = None , clear_trace = True ): \"\"\" Set the pose of the robot. a is in degrees. Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add to world before setting pose\" ) else : if a is not None : a = degrees_to_world ( a ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save ()","title":"set_pose()"},{"location":"robot/#aitk.robots.robot.Robot.set_random_pose","text":"Set the pose of the robot to a random location. Note: the robot must be in a world. Source code in robots/robot.py def set_random_pose ( self , clear_trace = True ): \"\"\" Set the pose of the robot to a random location. Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add robot to world before calling set_random_pose\" ) else : # Direction is in radians, in world coordinates: x , y , a = self . world . _find_random_pose ( self ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save ()","title":"set_random_pose()"},{"location":"robot/#aitk.robots.robot.Robot.speak","text":"Show some text in the robot's speech bubble. Parameters: Name Type Description Default text (str) the text to show; use None to clear None Source code in robots/robot.py def speak ( self , text = None ): \"\"\" Show some text in the robot's speech bubble. Args: text: (str) the text to show; use None to clear Note: not for use in a robot in a recorder. \"\"\" if self . world : if self . world . _recording : if len ( self . text_trace ) > 0 : # If same as last, don't add again if self . text_trace [ - 1 ][ 1 ] != text : self . text_trace . append (( self . world . time , text )) else : self . text_trace . append (( self . world . time , text )) else : self . text_trace [:] = [( self . world . time , text )]","title":"speak()"},{"location":"robot/#aitk.robots.robot.Robot.stop","text":"Set the target velocities to zeros. Source code in robots/robot.py def stop ( self ): \"\"\" Set the target velocities to zeros. \"\"\" self . tvx = 0.0 self . tvy = 0.0 self . tva = 0.0","title":"stop()"},{"location":"robot/#aitk.robots.robot.Robot.summary","text":"Get a summary of information about the robot. Source code in robots/robot.py def summary ( self ): \"\"\" Get a summary of information about the robot. \"\"\" if len ( self . _devices ) == 0 : print ( \" This robot has no devices.\" ) else : for i , device in enumerate ( self . _devices ): print ( \" robot[ %s or %r or %r ]: %r \" % ( i , device . type , device . name , device ) ) print ( \" \" + ( \"-\" * 25 ))","title":"summary()"},{"location":"robot/#aitk.robots.robot.Robot.to_json","text":"Get this robot as a JSON config file. Source code in robots/robot.py def to_json ( self ): \"\"\" Get this robot as a JSON config file. \"\"\" robot_json = { \"name\" : self . name , \"state\" : self . state , \"va\" : self . va , \"vx\" : self . vx , \"vy\" : self . vy , \"tva\" : self . tva , \"tvx\" : self . tvx , \"tvy\" : self . tvy , \"va_max\" : self . va_max , \"vx_max\" : self . vx_max , \"vy_max\" : self . vy_max , \"va_ramp\" : self . va_ramp , \"vx_ramp\" : self . vx_ramp , \"vy_ramp\" : self . vy_ramp , \"x\" : self . x , \"y\" : self . y , \"a\" : world_to_degrees ( self . a ), \"image_data\" : self . image_data , \"height\" : self . height , \"color\" : str ( self . color ), \"max_trace_length\" : self . max_trace_length , \"body\" : self . body , \"devices\" : [ device . to_json () for device in self . _devices ], \"do_trace\" : self . do_trace , } return robot_json","title":"to_json()"},{"location":"robot/#aitk.robots.robot.Robot.translate","text":"Set the target translate velocity. Arg should be between -1 and 1. Source code in robots/robot.py def translate ( self , translate ): \"\"\" Set the target translate velocity. Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tvx = round ( translate * self . vx_max , 1 )","title":"translate()"},{"location":"robot/#aitk.robots.robot.Robot.update","text":"Update the robot, and devices. Source code in robots/robot.py def update ( self , draw_list = None ): \"\"\" Update the robot, and devices. \"\"\" # Wrapped worlds: wrapped = False if self . x < 0 : self . x = self . world . width wrapped = True elif self . x > self . world . width : self . x = 0 wrapped = True if self . y < 0 : self . y = self . world . height wrapped = True elif self . y > self . world . height : self . y = 0 wrapped = True if wrapped : self . trace . append ( None ) self . _init_boundingbox () if self . world . debug and draw_list is not None : draw_list . append (( \"strokeStyle\" , ( Color ( 255 ), 1 ))) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 0 ] . p1 . x , self . _bounding_lines [ 0 ] . p1 . y , self . _bounding_lines [ 0 ] . p2 . x , self . _bounding_lines [ 0 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 1 ] . p1 . x , self . _bounding_lines [ 1 ] . p1 . y , self . _bounding_lines [ 1 ] . p2 . x , self . _bounding_lines [ 1 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 2 ] . p1 . x , self . _bounding_lines [ 2 ] . p1 . y , self . _bounding_lines [ 2 ] . p2 . x , self . _bounding_lines [ 2 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 3 ] . p1 . x , self . _bounding_lines [ 3 ] . p1 . y , self . _bounding_lines [ 3 ] . p2 . x , self . _bounding_lines [ 3 ] . p2 . y , ), ) ) # Devices: for device in self . _devices : device . update ( draw_list ) # Update recording info: if self . world . _recording : if len ( self . pen_trace ) > 0 : # color of pen: if self . pen_trace [ - 1 ][ 1 ][ 0 ] != self . pen [ 0 ]: self . pen_trace . append (( self . world . time , self . pen )) # same pen color, do nothing elif self . pen != ( None , 0 ): self . pen_trace . append (( self . world . time , self . pen )) # else do nothing else : # not recording if self . pen == ( None , 0 ): self . pen_trace [:] = [] else : self . pen_trace [:] = [( self . world . time , self . pen )] # Alter world: self . _update_ground_image ( self . world . time ) return","title":"update()"},{"location":"robot/#aitk.robots.robot.Robot.watch","text":"Watch the robot stats with live updates. Parameters: Name Type Description Default size (int) size in pixels around robot None show_robot (bool) show picture of robot None attributes (list) items to include, or \"all\" None Source code in robots/robot.py def watch ( self , size = None , show_robot = None , attributes = None ): \"\"\" Watch the robot stats with live updates. Args: size: (int) size in pixels around robot show_robot: (bool) show picture of robot attributes: (list) items to include, or \"all\" \"\"\" widget = self . get_widget ( size = size , show_robot = show_robot , attributes = attributes , ) display ( widget )","title":"watch()"},{"location":"world/","text":"World \u00b6 The aitk.robots simulator world. __init__ ( self , width = 500 , height = 250 , seed = 0 , scale = 3.0 , boundary_wall = True , boundary_wall_color = 'purple' , boundary_wall_width = 1 , ground_color = 'green' , ground_image_filename = None , filename = None , quiet = False , smell_cell_size = None , ** kwargs ) special \u00b6 The constructor for the aitk.robots simulator world. Parameters: Name Type Description Default width int width of world in pixels 500 height int height of world in pixels 250 seed int random number generator seed 0 scale float value to use in drawing the world 3.0 boundary_wall bool draw a boundary around the world? True boundary_wall_color str color name of boundary wall 'purple' boundary_wall_width int width of boundary wall 1 ground_color str color name 'green' ground_image_filename str image file used for backgound None filename str name of json world file None quiet bool if True, don't print any messages False You can also pass any valid item from the world config settings. Source code in robots/world.py def __init__ ( self , width = 500 , # type: int height = 250 , # type: int seed = 0 , # type: int scale = 3.0 , # type: float boundary_wall = True , # type: bool boundary_wall_color = \"purple\" , # type: str boundary_wall_width = 1 , # type: int ground_color = \"green\" , # type: str ground_image_filename = None , # type: str filename = None , # type: str quiet = False , # type: bool smell_cell_size = None , # type: int ** kwargs ): \"\"\" The constructor for the aitk.robots simulator world. Args: width (int): width of world in pixels height (int): height of world in pixels seed (int): random number generator seed scale (float): value to use in drawing the world boundary_wall (bool): draw a boundary around the world? boundary_wall_color (str): color name of boundary wall boundary_wall_width (int): width of boundary wall ground_color (str): color name ground_image_filename (str): image file used for backgound filename (str): name of json world file quiet (bool): if True, don't print any messages You can also pass any valid item from the world config settings. \"\"\" # For faster-than real time display with synchronous backends, # keep processing time below this percentage of throttle_period: config = { \"width\" : width , \"height\" : height , \"seed\" : seed , \"scale\" : scale , \"boundary_wall\" : boundary_wall , \"boundary_wall_width\" : boundary_wall_width , \"boundary_wall_color\" : boundary_wall_color , \"ground_color\" : ground_color , \"quiet\" : quiet , \"smell_cell_size\" : smell_cell_size , } self . _messages = [] if filename is not None : config [ \"filename\" ] = filename if ground_image_filename is not None : config [ \"ground_image_filename\" ] = ground_image_filename config [ \"walls\" ] = kwargs . pop ( \"walls\" , []) config [ \"bulbs\" ] = kwargs . pop ( \"bulbs\" , []) config [ \"robots\" ] = kwargs . pop ( \"robots\" , []) config [ \"food\" ] = kwargs . pop ( \"food\" , []) if len ( kwargs ) != 0 : raise AttributeError ( \"unknown arguments for World: %s \" % list ( kwargs . keys ()) ) self . _show_throttle_percentage = 0.40 self . _time_decimal_places = 1 self . _throttle_period = 0.1 self . _time_of_last_call = 0 self . _step_display = \"tqdm\" self . debug = False self . _watchers = [] self . _robots = [] self . _bulbs = [] self . _backend = None self . _recording = False self . config = config . copy () self . _initialize () # default values self . robots = List ( self . _robots ) self . bulbs = List ( self . _bulbs ) self . reset () # from config add_bulb ( self , color , x , y , z , brightness , name = None ) \u00b6 Add a bulb to the world. Parameters: Name Type Description Default color str the color of the light required x int the x coordinate required y int the y coordinate required z int the z coordinate required brightness float the distance in pixels of 1 standard deviation required name str the name of the bulb None Source code in robots/world.py def add_bulb ( self , color , x , y , z , brightness , name = None ): \"\"\" Add a bulb to the world. Args: color (str): the color of the light x (int): the x coordinate y (int): the y coordinate z (int): the z coordinate brightness (float): the distance in pixels of 1 standard deviation name (str): the name of the bulb \"\"\" self . _add_bulb ( color , x , y , z , brightness , name ) self . update () # request draw self . save () add_food ( self , x , y , standard_deviation ) \u00b6 Add food at x, y with a brightness of standard_deviation (in pixels). Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required standard_deviation float distance int pixels of 1 standard deviation required Source code in robots/world.py def add_food ( self , x , y , standard_deviation ): \"\"\" Add food at x, y with a brightness of standard_deviation (in pixels). Args: x (int): the x coordinate y (int): the y coordinate standard_deviation (float): distance int pixels of 1 standard deviation \"\"\" self . _add_food ( x , y , standard_deviation ) self . _grid . need_update = True self . update () # request draw self . save () add_robot ( self , robot ) \u00b6 Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Parameters: Name Type Description Default robot Robot the robot to add required Source code in robots/world.py def add_robot ( self , robot ): \"\"\" Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Args: robot (Robot): the robot to add \"\"\" if robot not in self . _robots : if robot . x == 0 and robot . y == 0 : robot . x , robot . y , robot . a = self . _find_random_pose ( robot ) self . _robots . append ( robot ) robot . world = self # Bounding lines form a wall: if len ( robot . _bounding_lines ) == 0 : print ( \"WARNING: adding a robot with no body\" ) wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . update () self . save () else : raise Exception ( \"Can't add the same robot to a world more than once.\" ) add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = 'wall' ) \u00b6 Add a wall line or box of wall lines. Parameters: Name Type Description Default color str the color of the wall required x1 int the upper left x coordinate required y1 int the upper left y coordinate required x2 int the lower right x coordinate required y2 int the lower right y coordinate required box bool whether this is a box (True) or line (False) True wtype str \"wall\", \"robot\", or \"boundary\" 'wall' Source code in robots/world.py def add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = \"wall\" ): \"\"\" Add a wall line or box of wall lines. Args: color (str): the color of the wall x1 (int): the upper left x coordinate y1 (int): the upper left y coordinate x2 (int): the lower right x coordinate y2 (int): the lower right y coordinate box (bool): whether this is a box (True) or line (False) wtype (str): \"wall\", \"robot\", or \"boundary\" \"\"\" p1 = Point ( x1 , y1 ) p3 = Point ( x2 , y2 ) if box : ## Pairs of points make Line: p2 = Point ( x2 , y1 ) p4 = Point ( x1 , y2 ) wall = Wall ( Color ( color ), None , Line ( p1 , p2 ), Line ( p2 , p3 ), Line ( p3 , p4 ), Line ( p4 , p1 ), wtype = wtype , ) else : wall = Wall ( Color ( color ), None , Line ( p1 , p3 ), wtype = \"wall\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . _grid . update_wall ( wall ) self . update () # request draw clear_watchers ( self ) \u00b6 Clear all of the watchers. Source code in robots/world.py def clear_watchers ( self ): \"\"\" Clear all of the watchers. \"\"\" self . _watchers [:] = [] del_robot ( self , robot ) \u00b6 Remove a robot from the world. Parameters: Name Type Description Default robot Robot the robot to remove required Source code in robots/world.py def del_robot ( self , robot ): \"\"\" Remove a robot from the world. Args: robot (Robot): the robot to remove \"\"\" if not isinstance ( robot , Robot ): # Then look it up by index/name/type: robot = self . robots [ robot ] for wall in list ( self . _walls ): if wall . robot is robot : self . _walls . remove ( wall ) if robot in self . _robots : robot . world = None self . _robots . remove ( robot ) self . _complexity = self . _compute_complexity () self . update () # request draw display ( self , index = None , size = 100 ) \u00b6 Display a picture of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def display ( self , index = None , size = 100 ): \"\"\" Display a picture of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" picture = self . get_image ( index = index , size = size ) display ( picture ) draw ( self ) \u00b6 Force a redraw of the world. Source code in robots/world.py def draw ( self ): \"\"\" Force a redraw of the world. \"\"\" if self . _backend is None : return self . _grid . update ( self . _food ) with self . _backend : self . _backend . clear () self . _backend . noStroke () if self . _ground_image is not None : self . _backend . draw_image ( self . _ground_image , 0 , 0 ) else : self . _backend . set_fill ( self . ground_color ) self . _backend . draw_rect ( 0 , 0 , self . width , self . height ) if len ( self . _food ) > 0 : smell = self . _grid . get_image () smell = smell . resize (( int ( self . width * self . scale ), int ( self . height * self . scale ))) self . _backend . image . paste ( smell , ( 0 , 0 ), smell ) ## Draw all bulbs in world: maxRange = max ( self . width , self . height ) for bulb in self . _get_light_sources ( all = True ): if bulb . state == \"on\" : color = bulb . color self . _backend . line_width = 0 self . _backend . noStroke () x , y = bulb . get_position ( world = True ) # Cast rays once: all_hits = [] for ray in range ( bulb . rays ): angle = ray / bulb . rays * TWO_PI hits = cast_ray ( self , bulb . robot , x , y , - angle + PI_OVER_2 , maxRange ) all_hits . append ( hits ) # Now draw the rings: for i in range ( bulb . draw_rings ): radius = ( bulb . draw_rings - i ) * 2 ray_length = bulb . brightness / 30 * radius color . alpha = ( i + 1 ) / bulb . draw_rings * 255 self . _backend . set_fill_style ( color ) points = [] for ray in range ( bulb . rays ): hits = all_hits [ ray ] ray_length = bulb . brightness / 30 * radius if len ( hits ) > 0 : if hits [ - 1 ] . distance < ray_length : ray_length = hits [ - 1 ] . distance angle = ray / bulb . rays * TWO_PI x2 , y2 = rotate_around ( x , y , ray_length , angle ) points . append (( x2 , y2 )) self . _backend . draw_polygon ( points ) self . _backend . line_width = 1 ## Draw walls: for wall in self . _walls : if wall . wtype == \"wall\" : c = wall . color if len ( wall . lines ) == 1 : self . _backend . strokeStyle ( c , 5 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) else : self . _backend . set_fill ( c ) self . _backend . noStroke () self . _backend . beginShape () for line in wall . lines : self . _backend . vertex ( line . p1 . x , line . p1 . y ) self . _backend . vertex ( line . p2 . x , line . p2 . y ) self . _backend . endShape () self . _backend . lineWidth ( 1 ) self . _backend . noStroke () elif wall . wtype == \"boundary\" : c = wall . color self . _backend . strokeStyle ( c , 3 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) self . _backend . lineWidth ( 1 ) self . _backend . noStroke () ## Draw robots: for robot in self . _robots : robot . draw ( self . _backend ) text = format_time ( self . time ) self . _backend . draw_status ( text ) for items in self . _draw_list : if len ( items ) == 1 : command = items [ 0 ] args = tuple () kwargs = {} elif len ( items ) == 2 : command = items [ 0 ] args = items [ 1 ] kwargs = {} elif len ( items ) == 3 : command = items [ 0 ] args = items [ 1 ] kwargs = items [ 2 ] self . _backend . do_command ( command , * args , ** kwargs ) self . _draw_watchers () from_json ( self , config ) \u00b6 Load a json config file. Source code in robots/world.py def from_json ( self , config ): \"\"\" Load a json config file. \"\"\" self . config = config seed = config . get ( \"seed\" , 0 ) self . set_seed ( seed ) if \"filename\" in config : self . filename = config [ \"filename\" ] if \"quiet\" in config : self . quiet = config [ \"quiet\" ] if \"width\" in config : self . width = config [ \"width\" ] if \"height\" in config : self . height = config [ \"height\" ] if \"scale\" in config : self . scale = config [ \"scale\" ] if \"smell_cell_size\" in config : self . smell_cell_size = config [ \"smell_cell_size\" ] if self . smell_cell_size is None : self . smell_cell_size = max (( self . width * self . height ) // 20000 , 1 ) if \"boundary_wall\" in config : self . boundary_wall = config [ \"boundary_wall\" ] if \"boundary_wall_color\" in config : self . boundary_wall_color = Color ( config [ \"boundary_wall_color\" ]) if \"boundary_wall_width\" in config : self . boundary_wall_width = config [ \"boundary_wall_width\" ] if \"ground_color\" in config : self . ground_color = Color ( config [ \"ground_color\" ]) if \"ground_image_filename\" in config : self . set_ground_image ( config [ \"ground_image_filename\" ], show = False ) # Now, we create the grid: self . _grid = Grid ( self . width , self . height , self . smell_cell_size ) self . _grid . update_walls ( self . _walls ) # Add walls: self . _add_boundary_walls () for wall in config . get ( \"walls\" , []): # Walls are either \"boxes\" with 4 lines, or a single line: if \"wtype\" not in wall or wall [ \"wtype\" ] == \"box\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = True , ) elif wall [ \"wtype\" ] == \"line\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = False , ) for bulb in config . get ( \"bulbs\" , []): # bulbs are {x, y, z, color, brightness} self . _add_bulb ( ** bulb ) for food in config . get ( \"food\" , []): # food x, y, standard_deviation self . _add_food ( ** food ) ## Create robot, and add to world: for i , robotConfig in enumerate ( self . config . get ( \"robots\" , [])): # FIXME: raise if lengths don't match if i < len ( self . _robots ): # already a robot; let's reuse it: robot = self . _robots [ i ] robot . _initialize () robot . from_json ( robotConfig ) else : robot = Robot ( ** robotConfig ) self . add_robot ( robot ) # Create the backend if first time: if self . _backend is None : self . _backend = make_backend ( self . width , self . height , self . scale ) # Update the backend if it already existed, but differs in config self . _backend . update_dimensions ( self . width , self . height , self . scale ) get_bulb ( self , item ) \u00b6 Get the bulb by name or index. Equivalent to world.bulbs[item] Parameters: Name Type Description Default item int or string index or name of bulb required Source code in robots/world.py def get_bulb ( self , item ): \"\"\" Get the bulb by name or index. Equivalent to world.bulbs[item] Args: item (int or string): index or name of bulb \"\"\" return self . bulbs [ item ] get_ground_color_at ( self , x , y , radius = 1 ) \u00b6 Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required radius int size of area 1 Source code in robots/world.py def get_ground_color_at ( self , x , y , radius = 1 ): \"\"\" Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate radius (int): size of area \"\"\" if self . _ground_image : results = [] for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): results . append ( self . _ground_image_pixels [ (( x + i ) * self . scale , ( y + j ) * self . scale ) ] ) return results get_image ( self , index = None , size = 100 ) \u00b6 Get a PIL image of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def get_image ( self , index = None , size = 100 ): \"\"\" Get a PIL image of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" try : picture = self . _backend . get_image ( self . time ) except RuntimeError : raise Exception ( \"Backend is not ready yet; try again\" ) if index is not None : robot = self . robots [ index ] if robot : start_x = round ( max ( robot . x * self . scale - size / 2 , 0 )) start_y = round ( max ( robot . y * self . scale - size / 2 , 0 )) rectangle = ( start_x , start_y , min ( start_x + size , self . width * self . scale ), min ( start_y + size , self . height * self . scale ), ) picture = picture . crop ( rectangle ) return picture else : return picture get_robot ( self , item ) \u00b6 Get the robot by name or index. Equivalent to world.robots[item] Parameters: Name Type Description Default item int or string index or name of robot required Source code in robots/world.py def get_robot ( self , item ): \"\"\" Get the robot by name or index. Equivalent to world.robots[item] Args: item (int or string): index or name of robot \"\"\" return self . robots [ item ] get_widget ( self , width = None , height = None ) \u00b6 Returns the IPython simulation widget. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def get_widget ( self , width = None , height = None ): \"\"\" Returns the IPython simulation widget. Args: width (int): the width of the world height (int): the height of the world \"\"\" if isinstance ( width , int ): width = \" %s px\" % width if isinstance ( height , int ): height = \" %s px\" % height self . _step_display = \"notebook\" self . update () return self . _backend . get_widget ( width = width , height = height ) paste_ground_image ( self , image , x , y ) \u00b6 Paste an image onto the ground image. Requires a ground image to have already been set. Parameters: Name Type Description Default image Image a Python Image Library image required x int the x coordinate of upper lefthand corner required y int the y coordinate of upper lefthand corner required Source code in robots/world.py def paste_ground_image ( self , image , x , y ): \"\"\" Paste an image onto the ground image. Requires a ground image to have already been set. Args: image (Image): a Python Image Library image x (int): the x coordinate of upper lefthand corner y (int): the y coordinate of upper lefthand corner \"\"\" if self . _ground_image : self . _ground_image . paste ( image , ( x , y )) record ( self ) \u00b6 Create and return a world recorder. Source code in robots/world.py def record ( self ): \"\"\" Create and return a world recorder. \"\"\" from .watchers import Recorder recorder = Recorder ( self ) self . _watchers . append ( recorder ) self . _recording = True return recorder reset ( self ) \u00b6 Reloads the config from initialization, or from last save. Source code in robots/world.py def reset ( self ): \"\"\" Reloads the config from initialization, or from last save. \"\"\" self . stop () self . _initialize () self . _reset_watchers () self . _food = [] self . _grid = None self . from_json ( self . config ) self . time = 0.0 for robot in self . _robots : robot . reset () # Re-add the robot's boundaries: wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _stop = False # should stop? self . status = \"stopped\" self . update ( show = False ) # twice to allow robots to see each other self . update ( show = False ) self . draw () # force run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False ) \u00b6 Run the simulator until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False background bool if True, run in the background. False Source code in robots/world.py def run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False , ): \"\"\" Run the simulator until one of the control functions returns True or Control+C is pressed. Args: function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed background (bool): if True, run in the background. \"\"\" time_step = time_step if time_step is not None else self . time_step if background : if self . _thread is None : kwargs = { \"function\" : function , \"time_step\" : time_step , \"show\" : show , \"real_time\" : real_time , \"show_progress\" : False , \"quiet\" : True , \"background\" : False } print ( \"Starting world.run() in background. Use world.stop()\" ) self . _thread = Thread ( target = self . run , kwargs = kwargs ) self . _thread . start () else : print ( \"The world is already running in the background. Use world.stop()\" ) else : self . steps ( float ( \"inf\" ), function , time_step , show , real_time , show_progress , quiet ) save ( self ) \u00b6 Save the current state of the world as the config. Source code in robots/world.py def save ( self ): \"\"\" Save the current state of the world as the config. \"\"\" self . config = self . to_json () save_as ( self , filename ) \u00b6 Save the world config JSON as a new file. Parameters: Name Type Description Default filename str the name of the file to save the world in required Source code in robots/world.py def save_as ( self , filename ): \"\"\" Save the world config JSON as a new file. Args: filename (str): the name of the file to save the world in \"\"\" if not filename . endswith ( \".json\" ): filename = filename + \".json\" # First, save internally. self . config = self . to_json () with open ( filename , \"w\" ) as fp : json_dump ( self . to_json (), fp , sort_keys = True , indent = 4 ) self . config [ \"filename\" ] = filename save_file ( self ) \u00b6 Save the current state of the world as the config, and save it back to disc if it was loaded from disk. Source code in robots/world.py def save_file ( self ): \"\"\" Save the current state of the world as the config, and save it back to disc if it was loaded from disk. \"\"\" # First, save internally. self . config = self . to_json () if self . filename is not None and os . path . exists ( self . filename ): with open ( self . filename , \"w\" ) as fp : json_dump ( self . config , fp , sort_keys = True , indent = 4 ) else : if not self . quiet : print ( \"Saved in memory. Use world.save_as('filename') to save to disk.\" ) seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False ) \u00b6 Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default seconds float how many simulation seconds to run 5.0 function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time float run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Args: seconds (float): how many simulation seconds to run function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (float): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" time_step = time_step if time_step is not None else self . time_step steps = round ( seconds / time_step ) self . steps ( steps , function , time_step , show , real_time , show_progress , quiet ) set_ground_color_at ( self , x , y , pen ) \u00b6 Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required pen tuple the (color, radius) to draw with required Source code in robots/world.py def set_ground_color_at ( self , x , y , pen ): \"\"\" Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate pen (tuple): the (color, radius) to draw with \"\"\" if self . _ground_image : color , radius = pen for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): try : self . _ground_image_pixels [ (( x * self . scale ) + i , ( y * self . scale ) + j ) ] = color . to_tuple () except Exception : pass set_ground_image ( self , filename , show = True ) \u00b6 Set the background image Parameters: Name Type Description Default filename str the name of the image required show bool update the world now if True True Source code in robots/world.py def set_ground_image ( self , filename , show = True ): \"\"\" Set the background image Args: filename (str): the name of the image show (bool): update the world now if True \"\"\" self . ground_image_filename = filename self . _reset_ground_image () if show : self . update ( show = False ) self . draw () # force set_scale ( self , scale ) \u00b6 Change the scale of the rendered world. Parameters: Name Type Description Default scale float the scale of the world (usually between 0.5 and 10) required Source code in robots/world.py def set_scale ( self , scale ): \"\"\" Change the scale of the rendered world. Args: scale (float): the scale of the world (usually between 0.5 and 10) \"\"\" self . scale = scale self . _backend . update_dimensions ( self . width , self . height , self . scale ) # Save with config self . config [ \"scale\" ] = self . scale self . update ( show = False ) self . draw () # force set_seed ( self , seed ) \u00b6 Set the random seed. Source code in robots/world.py def set_seed ( self , seed ): \"\"\" Set the random seed. \"\"\" if seed == 0 : seed = random . randint ( 0 , 9999999 ) if not self . quiet : print ( \"Random seed set to:\" , seed ) else : if not self . quiet : print ( \"Using random seed:\" , seed ) random . seed ( seed ) self . seed = seed self . config [ \"seed\" ] = seed steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False ) \u00b6 Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default steps int either a finite number, or infinity 1 time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Args: steps (int): either a finite number, or infinity function (Function) either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" self . status = \"running\" time_step = time_step if time_step is not None else self . time_step if steps == float ( \"inf\" ): step_iter = count () else : step_iter = range ( steps ) with self . _no_interrupt (): start_real_time = time . monotonic () start_time = self . time for step in progress_bar ( step_iter , show_progress and not quiet , self . _step_display ): if self . _stop : self . status = \"stopped\" break if function is not None : if isinstance ( function , ( list , tuple )): if len ( function ) < len ( self . _robots ): self . _print_once ( \"WARNING: you have not provided a controller function for every robot\" ) # Deterministically run robots round-robin: stop = any ( [ function [ i ]( self . _robots [ i ]) for i in range ( len ( function )) if function [ i ] is not None ] ) else : stop = function ( self ) if stop : break self . _step ( time_step , show = show , real_time = real_time ) self . status = \"stopped\" stop_real_time = time . monotonic () stop_time = self . time speed = ( stop_time - start_time ) / ( stop_real_time - start_real_time ) if steps > 1 and not quiet and not self . quiet : print ( \"Simulation stopped at: %s ; speed %s x real time\" % ( format_time ( self . time ), round ( speed , 2 )) ) if show : self . draw () # force to update any displays stop ( self ) \u00b6 Stop the simulator, if in thread or not. Source code in robots/world.py def stop ( self ): \"\"\" Stop the simulator, if in thread or not. \"\"\" self . _stop = True self . status = \"stopped\" if self . _thread is not None : print ( \"Stopping thread...\" ) self . _thread . join () self . _thread = None summary ( self ) \u00b6 Get a summary of information about the world and all of its robots. Source code in robots/world.py def summary ( self ): \"\"\" Get a summary of information about the world and all of its robots. \"\"\" print ( \"World details:\" ) if self . filename : print ( \"This world was loaded from %r \" % self . filename ) print ( \"Size: %s x %s \" % ( self . width , self . height )) print ( \"Robots:\" ) if len ( self . _robots ) == 0 : print ( \" This world has no robots.\" ) else : print ( \"-\" * 25 ) for i , robot in enumerate ( self . _robots ): print ( \" .robots[ %s or %r ]: %r \" % ( i , robot . name , robot )) robot . summary () print ( \"Food:\" ) if len ( self . _food ) == 0 : print ( \" This world has no food.\" ) else : print ( \"-\" * 25 ) for food in self . _food : print ( \" x: %s , y: %s , brightness: %s \" % ( food [ 0 ], food [ 1 ], food [ 2 ])) print ( \"Lights:\" ) if len ( self . _bulbs ) == 0 : print ( \" This world has no lights.\" ) else : print ( \"-\" * 25 ) for bulb in self . _bulbs : print ( \" x: %s , y: %s , brightness: %s , name: %r , color: %s \" % ( bulb . x , bulb . y , bulb . brightness , bulb . name , bulb . color )) to_json ( self ) \u00b6 Get the world as a JSON dict. Source code in robots/world.py def to_json ( self ): \"\"\" Get the world as a JSON dict. \"\"\" config = { \"seed\" : self . seed , \"width\" : int ( self . width ), \"height\" : int ( self . height ), \"scale\" : self . scale , \"boundary_wall\" : self . boundary_wall , # bool \"boundary_wall_color\" : str ( self . boundary_wall_color ), \"boundary_wall_width\" : self . boundary_wall_width , \"ground_color\" : str ( self . ground_color ), \"ground_image_filename\" : self . ground_image_filename , \"quiet\" : self . quiet , \"smell_cell_size\" : self . smell_cell_size , \"walls\" : [], \"bulbs\" : [], \"robots\" : [], \"food\" : [], } for wall in self . _walls : # Not a boundary wall or robot bounding box: if wall . wtype == \"wall\" : if len ( wall . lines ) == 4 : # Box: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 2 ] . p1 . x , \"y\" : wall . lines [ 2 ] . p1 . y ,}, \"wtype\" : \"box\" , } elif len ( wall . lines ) == 1 : # Line: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 0 ] . p2 . x , \"y\" : wall . lines [ 0 ] . p2 . y ,}, \"wtype\" : \"line\" , } else : raise Exception ( \"invalid wall length; should be 1 or 4: %s \" % len ( wall . lines )) config [ \"walls\" ] . append ( w ) for bulb in self . _bulbs : config [ \"bulbs\" ] . append ( { \"color\" : str ( bulb . color ), \"x\" : bulb . x , \"y\" : bulb . y , \"z\" : bulb . z , \"brightness\" : bulb . brightness , } ) for food in self . _food : config [ \"food\" ] . append ( { \"x\" : food [ 0 ], \"y\" : food [ 1 ], \"standard_deviation\" : food [ 2 ], } ) for robot in self . _robots : config [ \"robots\" ] . append ( robot . to_json ()) return config update ( self , show = True ) \u00b6 Update the world, robots, and devices. Optionally, draw the world. Parameters: Name Type Description Default show bool if True, draw the world. True Source code in robots/world.py def update ( self , show = True ): \"\"\" Update the world, robots, and devices. Optionally, draw the world. Args: show (bool): if True, draw the world. \"\"\" ## Update robots: self . _draw_list = self . _overlay_list [:] for robot in self . _robots : robot . update ( self . _draw_list ) if show : self . _request_draw () watch ( self , width = None , height = None ) \u00b6 Display a live (dynamically updated) view of the world. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def watch ( self , width = None , height = None ): \"\"\" Display a live (dynamically updated) view of the world. Args: width (int): the width of the world height (int): the height of the world \"\"\" # Force update: self . update ( show = True ) # Force draw: self . draw () widget = self . get_widget ( width , height ) display ( widget )","title":"World"},{"location":"world/#world","text":"The aitk.robots simulator world.","title":"World"},{"location":"world/#aitk.robots.world.World.__init__","text":"The constructor for the aitk.robots simulator world. Parameters: Name Type Description Default width int width of world in pixels 500 height int height of world in pixels 250 seed int random number generator seed 0 scale float value to use in drawing the world 3.0 boundary_wall bool draw a boundary around the world? True boundary_wall_color str color name of boundary wall 'purple' boundary_wall_width int width of boundary wall 1 ground_color str color name 'green' ground_image_filename str image file used for backgound None filename str name of json world file None quiet bool if True, don't print any messages False You can also pass any valid item from the world config settings. Source code in robots/world.py def __init__ ( self , width = 500 , # type: int height = 250 , # type: int seed = 0 , # type: int scale = 3.0 , # type: float boundary_wall = True , # type: bool boundary_wall_color = \"purple\" , # type: str boundary_wall_width = 1 , # type: int ground_color = \"green\" , # type: str ground_image_filename = None , # type: str filename = None , # type: str quiet = False , # type: bool smell_cell_size = None , # type: int ** kwargs ): \"\"\" The constructor for the aitk.robots simulator world. Args: width (int): width of world in pixels height (int): height of world in pixels seed (int): random number generator seed scale (float): value to use in drawing the world boundary_wall (bool): draw a boundary around the world? boundary_wall_color (str): color name of boundary wall boundary_wall_width (int): width of boundary wall ground_color (str): color name ground_image_filename (str): image file used for backgound filename (str): name of json world file quiet (bool): if True, don't print any messages You can also pass any valid item from the world config settings. \"\"\" # For faster-than real time display with synchronous backends, # keep processing time below this percentage of throttle_period: config = { \"width\" : width , \"height\" : height , \"seed\" : seed , \"scale\" : scale , \"boundary_wall\" : boundary_wall , \"boundary_wall_width\" : boundary_wall_width , \"boundary_wall_color\" : boundary_wall_color , \"ground_color\" : ground_color , \"quiet\" : quiet , \"smell_cell_size\" : smell_cell_size , } self . _messages = [] if filename is not None : config [ \"filename\" ] = filename if ground_image_filename is not None : config [ \"ground_image_filename\" ] = ground_image_filename config [ \"walls\" ] = kwargs . pop ( \"walls\" , []) config [ \"bulbs\" ] = kwargs . pop ( \"bulbs\" , []) config [ \"robots\" ] = kwargs . pop ( \"robots\" , []) config [ \"food\" ] = kwargs . pop ( \"food\" , []) if len ( kwargs ) != 0 : raise AttributeError ( \"unknown arguments for World: %s \" % list ( kwargs . keys ()) ) self . _show_throttle_percentage = 0.40 self . _time_decimal_places = 1 self . _throttle_period = 0.1 self . _time_of_last_call = 0 self . _step_display = \"tqdm\" self . debug = False self . _watchers = [] self . _robots = [] self . _bulbs = [] self . _backend = None self . _recording = False self . config = config . copy () self . _initialize () # default values self . robots = List ( self . _robots ) self . bulbs = List ( self . _bulbs ) self . reset () # from config","title":"__init__()"},{"location":"world/#aitk.robots.world.World.add_bulb","text":"Add a bulb to the world. Parameters: Name Type Description Default color str the color of the light required x int the x coordinate required y int the y coordinate required z int the z coordinate required brightness float the distance in pixels of 1 standard deviation required name str the name of the bulb None Source code in robots/world.py def add_bulb ( self , color , x , y , z , brightness , name = None ): \"\"\" Add a bulb to the world. Args: color (str): the color of the light x (int): the x coordinate y (int): the y coordinate z (int): the z coordinate brightness (float): the distance in pixels of 1 standard deviation name (str): the name of the bulb \"\"\" self . _add_bulb ( color , x , y , z , brightness , name ) self . update () # request draw self . save ()","title":"add_bulb()"},{"location":"world/#aitk.robots.world.World.add_food","text":"Add food at x, y with a brightness of standard_deviation (in pixels). Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required standard_deviation float distance int pixels of 1 standard deviation required Source code in robots/world.py def add_food ( self , x , y , standard_deviation ): \"\"\" Add food at x, y with a brightness of standard_deviation (in pixels). Args: x (int): the x coordinate y (int): the y coordinate standard_deviation (float): distance int pixels of 1 standard deviation \"\"\" self . _add_food ( x , y , standard_deviation ) self . _grid . need_update = True self . update () # request draw self . save ()","title":"add_food()"},{"location":"world/#aitk.robots.world.World.add_robot","text":"Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Parameters: Name Type Description Default robot Robot the robot to add required Source code in robots/world.py def add_robot ( self , robot ): \"\"\" Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Args: robot (Robot): the robot to add \"\"\" if robot not in self . _robots : if robot . x == 0 and robot . y == 0 : robot . x , robot . y , robot . a = self . _find_random_pose ( robot ) self . _robots . append ( robot ) robot . world = self # Bounding lines form a wall: if len ( robot . _bounding_lines ) == 0 : print ( \"WARNING: adding a robot with no body\" ) wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . update () self . save () else : raise Exception ( \"Can't add the same robot to a world more than once.\" )","title":"add_robot()"},{"location":"world/#aitk.robots.world.World.add_wall","text":"Add a wall line or box of wall lines. Parameters: Name Type Description Default color str the color of the wall required x1 int the upper left x coordinate required y1 int the upper left y coordinate required x2 int the lower right x coordinate required y2 int the lower right y coordinate required box bool whether this is a box (True) or line (False) True wtype str \"wall\", \"robot\", or \"boundary\" 'wall' Source code in robots/world.py def add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = \"wall\" ): \"\"\" Add a wall line or box of wall lines. Args: color (str): the color of the wall x1 (int): the upper left x coordinate y1 (int): the upper left y coordinate x2 (int): the lower right x coordinate y2 (int): the lower right y coordinate box (bool): whether this is a box (True) or line (False) wtype (str): \"wall\", \"robot\", or \"boundary\" \"\"\" p1 = Point ( x1 , y1 ) p3 = Point ( x2 , y2 ) if box : ## Pairs of points make Line: p2 = Point ( x2 , y1 ) p4 = Point ( x1 , y2 ) wall = Wall ( Color ( color ), None , Line ( p1 , p2 ), Line ( p2 , p3 ), Line ( p3 , p4 ), Line ( p4 , p1 ), wtype = wtype , ) else : wall = Wall ( Color ( color ), None , Line ( p1 , p3 ), wtype = \"wall\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . _grid . update_wall ( wall ) self . update () # request draw","title":"add_wall()"},{"location":"world/#aitk.robots.world.World.clear_watchers","text":"Clear all of the watchers. Source code in robots/world.py def clear_watchers ( self ): \"\"\" Clear all of the watchers. \"\"\" self . _watchers [:] = []","title":"clear_watchers()"},{"location":"world/#aitk.robots.world.World.del_robot","text":"Remove a robot from the world. Parameters: Name Type Description Default robot Robot the robot to remove required Source code in robots/world.py def del_robot ( self , robot ): \"\"\" Remove a robot from the world. Args: robot (Robot): the robot to remove \"\"\" if not isinstance ( robot , Robot ): # Then look it up by index/name/type: robot = self . robots [ robot ] for wall in list ( self . _walls ): if wall . robot is robot : self . _walls . remove ( wall ) if robot in self . _robots : robot . world = None self . _robots . remove ( robot ) self . _complexity = self . _compute_complexity () self . update () # request draw","title":"del_robot()"},{"location":"world/#aitk.robots.world.World.display","text":"Display a picture of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def display ( self , index = None , size = 100 ): \"\"\" Display a picture of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" picture = self . get_image ( index = index , size = size ) display ( picture )","title":"display()"},{"location":"world/#aitk.robots.world.World.draw","text":"Force a redraw of the world. Source code in robots/world.py def draw ( self ): \"\"\" Force a redraw of the world. \"\"\" if self . _backend is None : return self . _grid . update ( self . _food ) with self . _backend : self . _backend . clear () self . _backend . noStroke () if self . _ground_image is not None : self . _backend . draw_image ( self . _ground_image , 0 , 0 ) else : self . _backend . set_fill ( self . ground_color ) self . _backend . draw_rect ( 0 , 0 , self . width , self . height ) if len ( self . _food ) > 0 : smell = self . _grid . get_image () smell = smell . resize (( int ( self . width * self . scale ), int ( self . height * self . scale ))) self . _backend . image . paste ( smell , ( 0 , 0 ), smell ) ## Draw all bulbs in world: maxRange = max ( self . width , self . height ) for bulb in self . _get_light_sources ( all = True ): if bulb . state == \"on\" : color = bulb . color self . _backend . line_width = 0 self . _backend . noStroke () x , y = bulb . get_position ( world = True ) # Cast rays once: all_hits = [] for ray in range ( bulb . rays ): angle = ray / bulb . rays * TWO_PI hits = cast_ray ( self , bulb . robot , x , y , - angle + PI_OVER_2 , maxRange ) all_hits . append ( hits ) # Now draw the rings: for i in range ( bulb . draw_rings ): radius = ( bulb . draw_rings - i ) * 2 ray_length = bulb . brightness / 30 * radius color . alpha = ( i + 1 ) / bulb . draw_rings * 255 self . _backend . set_fill_style ( color ) points = [] for ray in range ( bulb . rays ): hits = all_hits [ ray ] ray_length = bulb . brightness / 30 * radius if len ( hits ) > 0 : if hits [ - 1 ] . distance < ray_length : ray_length = hits [ - 1 ] . distance angle = ray / bulb . rays * TWO_PI x2 , y2 = rotate_around ( x , y , ray_length , angle ) points . append (( x2 , y2 )) self . _backend . draw_polygon ( points ) self . _backend . line_width = 1 ## Draw walls: for wall in self . _walls : if wall . wtype == \"wall\" : c = wall . color if len ( wall . lines ) == 1 : self . _backend . strokeStyle ( c , 5 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) else : self . _backend . set_fill ( c ) self . _backend . noStroke () self . _backend . beginShape () for line in wall . lines : self . _backend . vertex ( line . p1 . x , line . p1 . y ) self . _backend . vertex ( line . p2 . x , line . p2 . y ) self . _backend . endShape () self . _backend . lineWidth ( 1 ) self . _backend . noStroke () elif wall . wtype == \"boundary\" : c = wall . color self . _backend . strokeStyle ( c , 3 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) self . _backend . lineWidth ( 1 ) self . _backend . noStroke () ## Draw robots: for robot in self . _robots : robot . draw ( self . _backend ) text = format_time ( self . time ) self . _backend . draw_status ( text ) for items in self . _draw_list : if len ( items ) == 1 : command = items [ 0 ] args = tuple () kwargs = {} elif len ( items ) == 2 : command = items [ 0 ] args = items [ 1 ] kwargs = {} elif len ( items ) == 3 : command = items [ 0 ] args = items [ 1 ] kwargs = items [ 2 ] self . _backend . do_command ( command , * args , ** kwargs ) self . _draw_watchers ()","title":"draw()"},{"location":"world/#aitk.robots.world.World.from_json","text":"Load a json config file. Source code in robots/world.py def from_json ( self , config ): \"\"\" Load a json config file. \"\"\" self . config = config seed = config . get ( \"seed\" , 0 ) self . set_seed ( seed ) if \"filename\" in config : self . filename = config [ \"filename\" ] if \"quiet\" in config : self . quiet = config [ \"quiet\" ] if \"width\" in config : self . width = config [ \"width\" ] if \"height\" in config : self . height = config [ \"height\" ] if \"scale\" in config : self . scale = config [ \"scale\" ] if \"smell_cell_size\" in config : self . smell_cell_size = config [ \"smell_cell_size\" ] if self . smell_cell_size is None : self . smell_cell_size = max (( self . width * self . height ) // 20000 , 1 ) if \"boundary_wall\" in config : self . boundary_wall = config [ \"boundary_wall\" ] if \"boundary_wall_color\" in config : self . boundary_wall_color = Color ( config [ \"boundary_wall_color\" ]) if \"boundary_wall_width\" in config : self . boundary_wall_width = config [ \"boundary_wall_width\" ] if \"ground_color\" in config : self . ground_color = Color ( config [ \"ground_color\" ]) if \"ground_image_filename\" in config : self . set_ground_image ( config [ \"ground_image_filename\" ], show = False ) # Now, we create the grid: self . _grid = Grid ( self . width , self . height , self . smell_cell_size ) self . _grid . update_walls ( self . _walls ) # Add walls: self . _add_boundary_walls () for wall in config . get ( \"walls\" , []): # Walls are either \"boxes\" with 4 lines, or a single line: if \"wtype\" not in wall or wall [ \"wtype\" ] == \"box\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = True , ) elif wall [ \"wtype\" ] == \"line\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = False , ) for bulb in config . get ( \"bulbs\" , []): # bulbs are {x, y, z, color, brightness} self . _add_bulb ( ** bulb ) for food in config . get ( \"food\" , []): # food x, y, standard_deviation self . _add_food ( ** food ) ## Create robot, and add to world: for i , robotConfig in enumerate ( self . config . get ( \"robots\" , [])): # FIXME: raise if lengths don't match if i < len ( self . _robots ): # already a robot; let's reuse it: robot = self . _robots [ i ] robot . _initialize () robot . from_json ( robotConfig ) else : robot = Robot ( ** robotConfig ) self . add_robot ( robot ) # Create the backend if first time: if self . _backend is None : self . _backend = make_backend ( self . width , self . height , self . scale ) # Update the backend if it already existed, but differs in config self . _backend . update_dimensions ( self . width , self . height , self . scale )","title":"from_json()"},{"location":"world/#aitk.robots.world.World.get_bulb","text":"Get the bulb by name or index. Equivalent to world.bulbs[item] Parameters: Name Type Description Default item int or string index or name of bulb required Source code in robots/world.py def get_bulb ( self , item ): \"\"\" Get the bulb by name or index. Equivalent to world.bulbs[item] Args: item (int or string): index or name of bulb \"\"\" return self . bulbs [ item ]","title":"get_bulb()"},{"location":"world/#aitk.robots.world.World.get_ground_color_at","text":"Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required radius int size of area 1 Source code in robots/world.py def get_ground_color_at ( self , x , y , radius = 1 ): \"\"\" Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate radius (int): size of area \"\"\" if self . _ground_image : results = [] for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): results . append ( self . _ground_image_pixels [ (( x + i ) * self . scale , ( y + j ) * self . scale ) ] ) return results","title":"get_ground_color_at()"},{"location":"world/#aitk.robots.world.World.get_image","text":"Get a PIL image of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def get_image ( self , index = None , size = 100 ): \"\"\" Get a PIL image of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" try : picture = self . _backend . get_image ( self . time ) except RuntimeError : raise Exception ( \"Backend is not ready yet; try again\" ) if index is not None : robot = self . robots [ index ] if robot : start_x = round ( max ( robot . x * self . scale - size / 2 , 0 )) start_y = round ( max ( robot . y * self . scale - size / 2 , 0 )) rectangle = ( start_x , start_y , min ( start_x + size , self . width * self . scale ), min ( start_y + size , self . height * self . scale ), ) picture = picture . crop ( rectangle ) return picture else : return picture","title":"get_image()"},{"location":"world/#aitk.robots.world.World.get_robot","text":"Get the robot by name or index. Equivalent to world.robots[item] Parameters: Name Type Description Default item int or string index or name of robot required Source code in robots/world.py def get_robot ( self , item ): \"\"\" Get the robot by name or index. Equivalent to world.robots[item] Args: item (int or string): index or name of robot \"\"\" return self . robots [ item ]","title":"get_robot()"},{"location":"world/#aitk.robots.world.World.get_widget","text":"Returns the IPython simulation widget. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def get_widget ( self , width = None , height = None ): \"\"\" Returns the IPython simulation widget. Args: width (int): the width of the world height (int): the height of the world \"\"\" if isinstance ( width , int ): width = \" %s px\" % width if isinstance ( height , int ): height = \" %s px\" % height self . _step_display = \"notebook\" self . update () return self . _backend . get_widget ( width = width , height = height )","title":"get_widget()"},{"location":"world/#aitk.robots.world.World.paste_ground_image","text":"Paste an image onto the ground image. Requires a ground image to have already been set. Parameters: Name Type Description Default image Image a Python Image Library image required x int the x coordinate of upper lefthand corner required y int the y coordinate of upper lefthand corner required Source code in robots/world.py def paste_ground_image ( self , image , x , y ): \"\"\" Paste an image onto the ground image. Requires a ground image to have already been set. Args: image (Image): a Python Image Library image x (int): the x coordinate of upper lefthand corner y (int): the y coordinate of upper lefthand corner \"\"\" if self . _ground_image : self . _ground_image . paste ( image , ( x , y ))","title":"paste_ground_image()"},{"location":"world/#aitk.robots.world.World.record","text":"Create and return a world recorder. Source code in robots/world.py def record ( self ): \"\"\" Create and return a world recorder. \"\"\" from .watchers import Recorder recorder = Recorder ( self ) self . _watchers . append ( recorder ) self . _recording = True return recorder","title":"record()"},{"location":"world/#aitk.robots.world.World.reset","text":"Reloads the config from initialization, or from last save. Source code in robots/world.py def reset ( self ): \"\"\" Reloads the config from initialization, or from last save. \"\"\" self . stop () self . _initialize () self . _reset_watchers () self . _food = [] self . _grid = None self . from_json ( self . config ) self . time = 0.0 for robot in self . _robots : robot . reset () # Re-add the robot's boundaries: wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _stop = False # should stop? self . status = \"stopped\" self . update ( show = False ) # twice to allow robots to see each other self . update ( show = False ) self . draw () # force","title":"reset()"},{"location":"world/#aitk.robots.world.World.run","text":"Run the simulator until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False background bool if True, run in the background. False Source code in robots/world.py def run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False , ): \"\"\" Run the simulator until one of the control functions returns True or Control+C is pressed. Args: function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed background (bool): if True, run in the background. \"\"\" time_step = time_step if time_step is not None else self . time_step if background : if self . _thread is None : kwargs = { \"function\" : function , \"time_step\" : time_step , \"show\" : show , \"real_time\" : real_time , \"show_progress\" : False , \"quiet\" : True , \"background\" : False } print ( \"Starting world.run() in background. Use world.stop()\" ) self . _thread = Thread ( target = self . run , kwargs = kwargs ) self . _thread . start () else : print ( \"The world is already running in the background. Use world.stop()\" ) else : self . steps ( float ( \"inf\" ), function , time_step , show , real_time , show_progress , quiet )","title":"run()"},{"location":"world/#aitk.robots.world.World.save","text":"Save the current state of the world as the config. Source code in robots/world.py def save ( self ): \"\"\" Save the current state of the world as the config. \"\"\" self . config = self . to_json ()","title":"save()"},{"location":"world/#aitk.robots.world.World.save_as","text":"Save the world config JSON as a new file. Parameters: Name Type Description Default filename str the name of the file to save the world in required Source code in robots/world.py def save_as ( self , filename ): \"\"\" Save the world config JSON as a new file. Args: filename (str): the name of the file to save the world in \"\"\" if not filename . endswith ( \".json\" ): filename = filename + \".json\" # First, save internally. self . config = self . to_json () with open ( filename , \"w\" ) as fp : json_dump ( self . to_json (), fp , sort_keys = True , indent = 4 ) self . config [ \"filename\" ] = filename","title":"save_as()"},{"location":"world/#aitk.robots.world.World.save_file","text":"Save the current state of the world as the config, and save it back to disc if it was loaded from disk. Source code in robots/world.py def save_file ( self ): \"\"\" Save the current state of the world as the config, and save it back to disc if it was loaded from disk. \"\"\" # First, save internally. self . config = self . to_json () if self . filename is not None and os . path . exists ( self . filename ): with open ( self . filename , \"w\" ) as fp : json_dump ( self . config , fp , sort_keys = True , indent = 4 ) else : if not self . quiet : print ( \"Saved in memory. Use world.save_as('filename') to save to disk.\" )","title":"save_file()"},{"location":"world/#aitk.robots.world.World.seconds","text":"Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default seconds float how many simulation seconds to run 5.0 function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time float run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Args: seconds (float): how many simulation seconds to run function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (float): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" time_step = time_step if time_step is not None else self . time_step steps = round ( seconds / time_step ) self . steps ( steps , function , time_step , show , real_time , show_progress , quiet )","title":"seconds()"},{"location":"world/#aitk.robots.world.World.set_ground_color_at","text":"Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required pen tuple the (color, radius) to draw with required Source code in robots/world.py def set_ground_color_at ( self , x , y , pen ): \"\"\" Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate pen (tuple): the (color, radius) to draw with \"\"\" if self . _ground_image : color , radius = pen for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): try : self . _ground_image_pixels [ (( x * self . scale ) + i , ( y * self . scale ) + j ) ] = color . to_tuple () except Exception : pass","title":"set_ground_color_at()"},{"location":"world/#aitk.robots.world.World.set_ground_image","text":"Set the background image Parameters: Name Type Description Default filename str the name of the image required show bool update the world now if True True Source code in robots/world.py def set_ground_image ( self , filename , show = True ): \"\"\" Set the background image Args: filename (str): the name of the image show (bool): update the world now if True \"\"\" self . ground_image_filename = filename self . _reset_ground_image () if show : self . update ( show = False ) self . draw () # force","title":"set_ground_image()"},{"location":"world/#aitk.robots.world.World.set_scale","text":"Change the scale of the rendered world. Parameters: Name Type Description Default scale float the scale of the world (usually between 0.5 and 10) required Source code in robots/world.py def set_scale ( self , scale ): \"\"\" Change the scale of the rendered world. Args: scale (float): the scale of the world (usually between 0.5 and 10) \"\"\" self . scale = scale self . _backend . update_dimensions ( self . width , self . height , self . scale ) # Save with config self . config [ \"scale\" ] = self . scale self . update ( show = False ) self . draw () # force","title":"set_scale()"},{"location":"world/#aitk.robots.world.World.set_seed","text":"Set the random seed. Source code in robots/world.py def set_seed ( self , seed ): \"\"\" Set the random seed. \"\"\" if seed == 0 : seed = random . randint ( 0 , 9999999 ) if not self . quiet : print ( \"Random seed set to:\" , seed ) else : if not self . quiet : print ( \"Using random seed:\" , seed ) random . seed ( seed ) self . seed = seed self . config [ \"seed\" ] = seed","title":"set_seed()"},{"location":"world/#aitk.robots.world.World.steps","text":"Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default steps int either a finite number, or infinity 1 time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Args: steps (int): either a finite number, or infinity function (Function) either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" self . status = \"running\" time_step = time_step if time_step is not None else self . time_step if steps == float ( \"inf\" ): step_iter = count () else : step_iter = range ( steps ) with self . _no_interrupt (): start_real_time = time . monotonic () start_time = self . time for step in progress_bar ( step_iter , show_progress and not quiet , self . _step_display ): if self . _stop : self . status = \"stopped\" break if function is not None : if isinstance ( function , ( list , tuple )): if len ( function ) < len ( self . _robots ): self . _print_once ( \"WARNING: you have not provided a controller function for every robot\" ) # Deterministically run robots round-robin: stop = any ( [ function [ i ]( self . _robots [ i ]) for i in range ( len ( function )) if function [ i ] is not None ] ) else : stop = function ( self ) if stop : break self . _step ( time_step , show = show , real_time = real_time ) self . status = \"stopped\" stop_real_time = time . monotonic () stop_time = self . time speed = ( stop_time - start_time ) / ( stop_real_time - start_real_time ) if steps > 1 and not quiet and not self . quiet : print ( \"Simulation stopped at: %s ; speed %s x real time\" % ( format_time ( self . time ), round ( speed , 2 )) ) if show : self . draw () # force to update any displays","title":"steps()"},{"location":"world/#aitk.robots.world.World.stop","text":"Stop the simulator, if in thread or not. Source code in robots/world.py def stop ( self ): \"\"\" Stop the simulator, if in thread or not. \"\"\" self . _stop = True self . status = \"stopped\" if self . _thread is not None : print ( \"Stopping thread...\" ) self . _thread . join () self . _thread = None","title":"stop()"},{"location":"world/#aitk.robots.world.World.summary","text":"Get a summary of information about the world and all of its robots. Source code in robots/world.py def summary ( self ): \"\"\" Get a summary of information about the world and all of its robots. \"\"\" print ( \"World details:\" ) if self . filename : print ( \"This world was loaded from %r \" % self . filename ) print ( \"Size: %s x %s \" % ( self . width , self . height )) print ( \"Robots:\" ) if len ( self . _robots ) == 0 : print ( \" This world has no robots.\" ) else : print ( \"-\" * 25 ) for i , robot in enumerate ( self . _robots ): print ( \" .robots[ %s or %r ]: %r \" % ( i , robot . name , robot )) robot . summary () print ( \"Food:\" ) if len ( self . _food ) == 0 : print ( \" This world has no food.\" ) else : print ( \"-\" * 25 ) for food in self . _food : print ( \" x: %s , y: %s , brightness: %s \" % ( food [ 0 ], food [ 1 ], food [ 2 ])) print ( \"Lights:\" ) if len ( self . _bulbs ) == 0 : print ( \" This world has no lights.\" ) else : print ( \"-\" * 25 ) for bulb in self . _bulbs : print ( \" x: %s , y: %s , brightness: %s , name: %r , color: %s \" % ( bulb . x , bulb . y , bulb . brightness , bulb . name , bulb . color ))","title":"summary()"},{"location":"world/#aitk.robots.world.World.to_json","text":"Get the world as a JSON dict. Source code in robots/world.py def to_json ( self ): \"\"\" Get the world as a JSON dict. \"\"\" config = { \"seed\" : self . seed , \"width\" : int ( self . width ), \"height\" : int ( self . height ), \"scale\" : self . scale , \"boundary_wall\" : self . boundary_wall , # bool \"boundary_wall_color\" : str ( self . boundary_wall_color ), \"boundary_wall_width\" : self . boundary_wall_width , \"ground_color\" : str ( self . ground_color ), \"ground_image_filename\" : self . ground_image_filename , \"quiet\" : self . quiet , \"smell_cell_size\" : self . smell_cell_size , \"walls\" : [], \"bulbs\" : [], \"robots\" : [], \"food\" : [], } for wall in self . _walls : # Not a boundary wall or robot bounding box: if wall . wtype == \"wall\" : if len ( wall . lines ) == 4 : # Box: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 2 ] . p1 . x , \"y\" : wall . lines [ 2 ] . p1 . y ,}, \"wtype\" : \"box\" , } elif len ( wall . lines ) == 1 : # Line: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 0 ] . p2 . x , \"y\" : wall . lines [ 0 ] . p2 . y ,}, \"wtype\" : \"line\" , } else : raise Exception ( \"invalid wall length; should be 1 or 4: %s \" % len ( wall . lines )) config [ \"walls\" ] . append ( w ) for bulb in self . _bulbs : config [ \"bulbs\" ] . append ( { \"color\" : str ( bulb . color ), \"x\" : bulb . x , \"y\" : bulb . y , \"z\" : bulb . z , \"brightness\" : bulb . brightness , } ) for food in self . _food : config [ \"food\" ] . append ( { \"x\" : food [ 0 ], \"y\" : food [ 1 ], \"standard_deviation\" : food [ 2 ], } ) for robot in self . _robots : config [ \"robots\" ] . append ( robot . to_json ()) return config","title":"to_json()"},{"location":"world/#aitk.robots.world.World.update","text":"Update the world, robots, and devices. Optionally, draw the world. Parameters: Name Type Description Default show bool if True, draw the world. True Source code in robots/world.py def update ( self , show = True ): \"\"\" Update the world, robots, and devices. Optionally, draw the world. Args: show (bool): if True, draw the world. \"\"\" ## Update robots: self . _draw_list = self . _overlay_list [:] for robot in self . _robots : robot . update ( self . _draw_list ) if show : self . _request_draw ()","title":"update()"},{"location":"world/#aitk.robots.world.World.watch","text":"Display a live (dynamically updated) view of the world. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def watch ( self , width = None , height = None ): \"\"\" Display a live (dynamically updated) view of the world. Args: width (int): the width of the world height (int): the height of the world \"\"\" # Force update: self . update ( show = True ) # Force draw: self . draw () widget = self . get_widget ( width , height ) display ( widget )","title":"watch()"}]}