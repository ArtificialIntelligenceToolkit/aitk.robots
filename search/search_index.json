{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to aitk.robots \u00b6 For full documentation visit github.com/ArtificialIntelligenceToolkit/aitk.robots . Introduction \u00b6 A lightweight Python robot simulator for JupyterLab, Notebooks, and other Python environments. Goals \u00b6 A lightweight mobile robotics simulator Usable in the classroom, research, or exploration Explore wheeled robots with range, cameras, smell, and light sensors Operate quickly without a huge amount of resources Create reproducible experiments Designed for exposition, experimentation, and analysis Sensors designed for somewhat realistic problems (such as image recognition) Especially designed to work easily with Machine Learning and Artificial Intelligence systems Installation \u00b6 For the core operations, you will need to install just aitk.robots: pip install aitk.robots To use the Jupyter enhancements, you'll also need the browser-based extensions. You can install those with: jupyter labextension install @jupyter-widgets/jupyterlab-manager If not in a conda environment, then you will also need to: jupyter nbextension enable --py widgetsnbextension For additional information, please see: aitk aitk.robots aitk.networks aitk.utils","title":"Home"},{"location":"#welcome-to-aitkrobots","text":"For full documentation visit github.com/ArtificialIntelligenceToolkit/aitk.robots .","title":"Welcome to aitk.robots"},{"location":"#introduction","text":"A lightweight Python robot simulator for JupyterLab, Notebooks, and other Python environments.","title":"Introduction"},{"location":"#goals","text":"A lightweight mobile robotics simulator Usable in the classroom, research, or exploration Explore wheeled robots with range, cameras, smell, and light sensors Operate quickly without a huge amount of resources Create reproducible experiments Designed for exposition, experimentation, and analysis Sensors designed for somewhat realistic problems (such as image recognition) Especially designed to work easily with Machine Learning and Artificial Intelligence systems","title":"Goals"},{"location":"#installation","text":"For the core operations, you will need to install just aitk.robots: pip install aitk.robots To use the Jupyter enhancements, you'll also need the browser-based extensions. You can install those with: jupyter labextension install @jupyter-widgets/jupyterlab-manager If not in a conda environment, then you will also need to: jupyter nbextension enable --py widgetsnbextension For additional information, please see: aitk aitk.robots aitk.networks aitk.utils","title":"Installation"},{"location":"bulb/","text":"Bulb \u00b6 Class representing lights in the world. __init__ ( self , color , x = 0 , y = 0 , z = 0 , brightness = 50 , name = None , ** kwargs ) special \u00b6 Create a lightbulb. Parameters: Name Type Description Default color Color the color of the bulb required x int the position of bulb on x dimension 0 y int the position of bulb on y dimension 0 z float the height of bulb from ground (range 0 to 1) 0 brightness float the brightness of the bulb (default 50) 50 name str the name of the bulb None Source code in robots/devices/bulbs.py def __init__ ( self , color , x = 0 , y = 0 , z = 0 , brightness = 50 , name = None , ** kwargs ): \"\"\" Create a lightbulb. Args: color (Color): the color of the bulb x (int): the position of bulb on x dimension y (int): the position of bulb on y dimension z (float): the height of bulb from ground (range 0 to 1) brightness (float): the brightness of the bulb (default 50) name (str): the name of the bulb \"\"\" config = { \"color\" : color , \"x\" : x , \"y\" : y , \"z\" : z , \"brightness\" : brightness , \"name\" : name , } config . update ( kwargs ) self . rays = 32 self . state = \"on\" self . draw_rings = 7 # rings around bulb light in views self . _watcher = None self . robot = None self . from_json ( config ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/bulbs.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" # Drawn by world pass from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/bulbs.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"x\" , \"y\" , \"z\" , \"name\" , \"color\" , \"brightness\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"x\" in config : self . _x = config [ \"x\" ] if \"y\" in config : self . _y = config [ \"y\" ] if \"z\" in config : self . _z = config [ \"z\" ] if \"name\" in config : name = config [ \"name\" ] else : name = None self . name = name if name is not None else \"bulb\" if \"color\" in config : self . color = Color ( config [ \"color\" ]) if \"brightness\" in config : self . brightness = config [ \"brightness\" ] self . initialize () get_position ( self , world = True ) \u00b6 Get the relative or global position of the device. Parameters: Name Type Description Default world bool if True, return the global coordinates of the device. Otherwsie, return the local, relative position. True Source code in robots/devices/bulbs.py def get_position ( self , world = True ): \"\"\" Get the relative or global position of the device. Args: world (bool): if True, return the global coordinates of the device. Otherwsie, return the local, relative position. \"\"\" if self . robot is None : return self . _x , self . _y else : if world : if self . dist_from_center != 0 : x , y = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center ) return x , y else : return self . robot . x , self . robot . y else : # local to robot if self . dist_from_center != 0 : x , y = rotate_around ( 0 , 0 , self . dist_from_center , self . robot . a + self . dir_from_center ) return x , y else : return 0 , 0 get_widget ( self , title = 'Bulb:' ) \u00b6 Return the dynamically updating widget. Parameters: Name Type Description Default title str title of device 'Bulb:' Source code in robots/devices/bulbs.py def get_widget ( self , title = \"Bulb:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of device \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"brightness\" , title = title , labels = [ \"Name:\" , \"Brightness:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/bulbs.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"bulb\" self . state = \"on\" self . dist_from_center = distance ( 0 , 0 , self . _x , self . _y ) self . dir_from_center = math . atan2 ( - self . _x , self . _y ) off ( self ) \u00b6 Turn the bulb \"off\". Source code in robots/devices/bulbs.py def off ( self ): \"\"\" Turn the bulb \"off\". \"\"\" self . state = \"off\" if self . robot is not None and self . robot . world is not None : self . robot . world . update () on ( self ) \u00b6 Turn the bulb \"on\". Source code in robots/devices/bulbs.py def on ( self ): \"\"\" Turn the bulb \"on\". \"\"\" self . state = \"on\" if self . robot is not None and self . robot . world is not None : self . robot . world . update () to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/bulbs.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"color\" : str ( self . color ), \"x\" : self . _x , \"y\" : self . _y , \"z\" : self . _z , \"brightness\" : self . brightness , \"name\" : self . name , } return config update ( self , draw_list = None ) \u00b6 Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/bulbs.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" pass watch ( self , title = 'Bulb:' ) \u00b6 Create a dynamically updating view of this device. Parameters: Name Type Description Default title str title of device 'Bulb:' Source code in robots/devices/bulbs.py def watch ( self , title = \"Bulb:\" ): \"\"\" Create a dynamically updating view of this device. Args: title (str): title of device \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"Bulb"},{"location":"bulb/#bulb","text":"Class representing lights in the world.","title":"Bulb"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.__init__","text":"Create a lightbulb. Parameters: Name Type Description Default color Color the color of the bulb required x int the position of bulb on x dimension 0 y int the position of bulb on y dimension 0 z float the height of bulb from ground (range 0 to 1) 0 brightness float the brightness of the bulb (default 50) 50 name str the name of the bulb None Source code in robots/devices/bulbs.py def __init__ ( self , color , x = 0 , y = 0 , z = 0 , brightness = 50 , name = None , ** kwargs ): \"\"\" Create a lightbulb. Args: color (Color): the color of the bulb x (int): the position of bulb on x dimension y (int): the position of bulb on y dimension z (float): the height of bulb from ground (range 0 to 1) brightness (float): the brightness of the bulb (default 50) name (str): the name of the bulb \"\"\" config = { \"color\" : color , \"x\" : x , \"y\" : y , \"z\" : z , \"brightness\" : brightness , \"name\" : name , } config . update ( kwargs ) self . rays = 32 self . state = \"on\" self . draw_rings = 7 # rings around bulb light in views self . _watcher = None self . robot = None self . from_json ( config )","title":"__init__()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/bulbs.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" # Drawn by world pass","title":"draw()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/bulbs.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"x\" , \"y\" , \"z\" , \"name\" , \"color\" , \"brightness\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"x\" in config : self . _x = config [ \"x\" ] if \"y\" in config : self . _y = config [ \"y\" ] if \"z\" in config : self . _z = config [ \"z\" ] if \"name\" in config : name = config [ \"name\" ] else : name = None self . name = name if name is not None else \"bulb\" if \"color\" in config : self . color = Color ( config [ \"color\" ]) if \"brightness\" in config : self . brightness = config [ \"brightness\" ] self . initialize ()","title":"from_json()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.get_position","text":"Get the relative or global position of the device. Parameters: Name Type Description Default world bool if True, return the global coordinates of the device. Otherwsie, return the local, relative position. True Source code in robots/devices/bulbs.py def get_position ( self , world = True ): \"\"\" Get the relative or global position of the device. Args: world (bool): if True, return the global coordinates of the device. Otherwsie, return the local, relative position. \"\"\" if self . robot is None : return self . _x , self . _y else : if world : if self . dist_from_center != 0 : x , y = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center ) return x , y else : return self . robot . x , self . robot . y else : # local to robot if self . dist_from_center != 0 : x , y = rotate_around ( 0 , 0 , self . dist_from_center , self . robot . a + self . dir_from_center ) return x , y else : return 0 , 0","title":"get_position()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.get_widget","text":"Return the dynamically updating widget. Parameters: Name Type Description Default title str title of device 'Bulb:' Source code in robots/devices/bulbs.py def get_widget ( self , title = \"Bulb:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of device \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"brightness\" , title = title , labels = [ \"Name:\" , \"Brightness:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget","title":"get_widget()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/bulbs.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"bulb\" self . state = \"on\" self . dist_from_center = distance ( 0 , 0 , self . _x , self . _y ) self . dir_from_center = math . atan2 ( - self . _x , self . _y )","title":"initialize()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.off","text":"Turn the bulb \"off\". Source code in robots/devices/bulbs.py def off ( self ): \"\"\" Turn the bulb \"off\". \"\"\" self . state = \"off\" if self . robot is not None and self . robot . world is not None : self . robot . world . update ()","title":"off()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.on","text":"Turn the bulb \"on\". Source code in robots/devices/bulbs.py def on ( self ): \"\"\" Turn the bulb \"on\". \"\"\" self . state = \"on\" if self . robot is not None and self . robot . world is not None : self . robot . world . update ()","title":"on()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/bulbs.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"color\" : str ( self . color ), \"x\" : self . _x , \"y\" : self . _y , \"z\" : self . _z , \"brightness\" : self . brightness , \"name\" : self . name , } return config","title":"to_json()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.update","text":"Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/bulbs.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" pass","title":"update()"},{"location":"bulb/#aitk.robots.devices.bulbs.Bulb.watch","text":"Create a dynamically updating view of this device. Parameters: Name Type Description Default title str title of device 'Bulb:' Source code in robots/devices/bulbs.py def watch ( self , title = \"Bulb:\" ): \"\"\" Create a dynamically updating view of this device. Args: title (str): title of device \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"watch()"},{"location":"camera/","text":"Cameras \u00b6 __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = 'camera' , samples = 1 , ** kwargs ) special \u00b6 A camera device. Parameters: Name Type Description Default width int width of camera in pixels 64 height int height of camera in pixels 32 fov float width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. 30 colorsFadeWithDistance float colors get darker faster with larger value 1.0 sizeFadeWithDistance float size gets smaller faster with with larger value 0.8 reflectGround bool ground reflects for 3D point cloud True reflectSky bool sky reflects for 3D point cloud False max_range int maximum range of camera 1000 name str the name of the camera 'camera' samples int how many pixels should it sample 1 Source code in robots/devices/cameras.py def __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = \"camera\" , samples = 1 , ** kwargs ): \"\"\" A camera device. Args: width (int): width of camera in pixels height (int): height of camera in pixels fov (float): width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. colorsFadeWithDistance (float): colors get darker faster with larger value sizeFadeWithDistance (float): size gets smaller faster with with larger value reflectGround (bool): ground reflects for 3D point cloud reflectSky (bool): sky reflects for 3D point cloud max_range (int): maximum range of camera name (str): the name of the camera samples (int): how many pixels should it sample Note: currently the camera faces forward. \"\"\" config = { \"width\" : width , \"height\" : height , \"fov\" : fov , \"colorsFadeWithDistance\" : colorsFadeWithDistance , \"sizeFadeWithDistance\" : sizeFadeWithDistance , \"reflectGround\" : reflectGround , \"reflectSky\" : reflectSky , \"max_range\" : max_range , \"name\" : name , \"samples\" : samples , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) display ( self , type = 'color' ) \u00b6 Display an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" 'color' Source code in robots/devices/cameras.py def display ( self , type = \"color\" ): \"\"\" Display an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" image = self . get_image ( type = type ) display ( image ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend NOTE: Currently, cameras are fixed at 0,0 and face forwards. \"\"\" backend . set_fill ( Color ( 0 , 64 , 0 )) backend . strokeStyle ( None , 0 ) backend . draw_rect ( 5.0 , - 3.33 , 1.33 , 6.33 ) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a + self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , - self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , - self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a - self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/cameras.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"width\" , \"name\" , \"height\" , \"colorsFadeWithDistance\" , \"sizeFadeWithDistance\" , \"reflectGround\" , \"reflectSky\" , \"fov\" , \"max_range\" , \"samples\" , \"position\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"width\" in config : self . cameraShape [ 0 ] = config [ \"width\" ] if \"height\" in config : self . cameraShape [ 1 ] = config [ \"height\" ] if \"colorsFadeWithDistance\" in config : self . colorsFadeWithDistance = config [ \"colorsFadeWithDistance\" ] if \"sizeFadeWithDistance\" in config : self . sizeFadeWithDistance = config [ \"sizeFadeWithDistance\" ] if \"reflectGround\" in config : self . reflectGround = config [ \"reflectGround\" ] if \"reflectSky\" in config : self . reflectSky = config [ \"reflectSky\" ] if \"fov\" in config : self . set_fov ( config [ \"fov\" ]) # degrees if \"max_range\" in config : self . max_range = config [ \"max_range\" ] if \"samples\" in config : self . samples = config [ \"samples\" ] if \"name\" in config : self . name = config [ \"name\" ] if \"position\" in config : self . position = config [ \"position\" ] get_fov ( self ) \u00b6 Get the field of view angle in degrees. Source code in robots/devices/cameras.py def get_fov ( self ): \"\"\" Get the field of view angle in degrees. \"\"\" return self . fov * ONE80_OVER_PI get_height ( self ) \u00b6 Get the height in pixels of the camera. Source code in robots/devices/cameras.py def get_height ( self ): \"\"\" Get the height in pixels of the camera. \"\"\" return self . cameraShape [ 1 ] get_image ( self , type = 'color' ) \u00b6 Get an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" 'color' Source code in robots/devices/cameras.py def get_image ( self , type = \"color\" ): \"\"\" Get an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" try : from PIL import Image except ImportError : print ( \"Pillow (PIL) module not available; get_image() unavailable\" ) return # Lazy; only get the data when we need it: self . _update () if self . robot . world . _ground_image is not None : area = list ( self . _get_visible_area ()) else : area = None pic = Image . new ( \"RGBA\" , ( self . cameraShape [ 0 ], self . cameraShape [ 1 ])) pic_pixels = pic . load () # FIXME: probably should have a specific size rather than scale it to world size = max ( self . robot . world . width , self . robot . world . height ) hcolor = None # draw non-robot walls first: for i in range ( self . cameraShape [ 0 ]): hits = [ hit for hit in self . hits [ i ] if hit . height == 1.0 ] # only walls if len ( hits ) == 0 : continue hit = hits [ - 1 ] # get closest high = None hcolor = None if hit : if self . fov < PI_OVER_2 : # Orthoginal distance to camera: angle = hit . angle hit_distance = abs ( hit . distance * math . sin ( angle )) else : hit_distance = hit . distance distance_ratio = 1.0 - hit_distance / size s = distance_ratio * self . sizeFadeWithDistance sc = distance_ratio * self . colorsFadeWithDistance if type == \"color\" : r = hit . color . red * sc g = hit . color . green * sc b = hit . color . blue * sc elif type == \"depth\" : r = 255 * distance_ratio g = 255 * distance_ratio b = 255 * distance_ratio else : avg = ( hit . color . red + hit . color . green + hit . color . blue ) / 3.0 r = avg * sc g = avg * sc b = avg * sc hcolor = Color ( r , g , b ) high = ( 1.0 - s ) * self . cameraShape [ 1 ] else : high = 0 horizon = self . cameraShape [ 1 ] / 2 for j in range ( self . cameraShape [ 1 ]): dist = max ( min ( abs ( j - horizon ) / horizon , 1.0 ), 0.0 ) if j < high / 2 : # sky if type == \"depth\" : if self . reflectSky : color = Color ( 255 * dist ) else : color = Color ( 0 ) elif type == \"color\" : color = Color ( 0 , 0 , 128 ) else : color = Color ( 128 / 3 ) pic_pixels [ i , j ] = color . to_tuple () elif j < self . cameraShape [ 1 ] - high / 2 : # hit if hcolor is not None : pic_pixels [ i , j ] = hcolor . to_tuple () else : # ground if type == \"depth\" : if self . reflectGround : color = Color ( 255 * dist ) else : color = Color ( 0 ) elif type == \"color\" : color = self . _get_ground_color ( area , i , j ) else : color = Color ( 128 / 3 ) pic_pixels [ i , j ] = color . to_tuple () # Other robots, draw on top of walls: self . obstacles = {} for i in range ( self . cameraShape [ 0 ]): closest_wall_dist = self . _find_closest_wall ( self . hits [ i ]) hits = [ hit for hit in self . hits [ i ] if hit . height < 1.0 ] # obstacles for hit in hits : if hit . distance > closest_wall_dist : # Behind wall, try next continue if self . fov < PI_OVER_2 : angle = hit . angle hit_distance = abs ( hit . distance * math . sin ( angle )) else : # perspective hit_distance = hit . distance distance_ratio = 4.0 - hit_distance / size s = distance_ratio * self . sizeFadeWithDistance sc = distance_ratio * self . colorsFadeWithDistance distance_to = self . cameraShape [ 1 ] / 2 * ( 4.0 - sc ) # scribbler was 30, so 0.23 height ratio # height is ratio, 0 to 1 height = round ( hit . height * self . cameraShape [ 1 ] / 2.0 * s ) if type == \"color\" : r = hit . color . red * sc g = hit . color . green * sc b = hit . color . blue * sc elif type == \"depth\" : r = 255 * distance_ratio g = 255 * distance_ratio b = 255 * distance_ratio else : avg = ( hit . color . red + hit . color . green + hit . color . blue ) / 3.0 r = avg * sc g = avg * sc b = avg * sc hcolor = Color ( r , g , b ) horizon = self . cameraShape [ 1 ] / 2 self . _record_obstacle ( hit . robot , i , self . cameraShape [ 1 ] - 1 - round ( distance_to ), self . cameraShape [ 1 ] - height - 1 - 1 - round ( distance_to ), ) if not hit . robot . has_image (): for j in range ( height ): pic_pixels [ i , self . cameraShape [ 1 ] - j - 1 - round ( distance_to ) ] = hcolor . to_tuple () if self . bulbs_are_visible : self . _show_bulbs ( pic ) if self . food_is_visible : self . _show_food ( pic ) self . _show_obstacles ( pic ) return pic get_max ( self ) \u00b6 Get the maximum distance in CM the camera can see. Source code in robots/devices/cameras.py def get_max ( self ): \"\"\" Get the maximum distance in CM the camera can see. \"\"\" return self . max_range get_name ( self ) \u00b6 Get the name of the camera. Source code in robots/devices/cameras.py def get_name ( self ): \"\"\" Get the name of the camera. \"\"\" return self . name get_point_cloud ( self ) \u00b6 Get a 3D point cloud from the camera data. Returns a list of [x, y, distance, red, green, blue] for each (x,y) of the camera. Source code in robots/devices/cameras.py def get_point_cloud ( self ): \"\"\" Get a 3D point cloud from the camera data. Returns a list of [x, y, distance, red, green, blue] for each (x,y) of the camera. \"\"\" depth_pic = self . get_image ( \"depth\" ) depth_pixels = depth_pic . load () color_pic = self . get_image ( \"color\" ) color_pixels = color_pic . load () points = [] for x in range ( self . cameraShape [ 0 ]): for y in range ( self . cameraShape [ 1 ]): dist_color = depth_pixels [ x , y ] color = color_pixels [ x , y ] if dist_color [ 0 ] != 255 : points . append ( [ self . cameraShape [ 0 ] - x - 1 , self . cameraShape [ 1 ] - y - 1 , dist_color [ 0 ], color [ 0 ], color [ 1 ], color [ 2 ], ] ) return points get_widget ( self , ** kwargs ) \u00b6 Return the dynamically updating widget. Parameters: Name Type Description Default title str title of device required Source code in robots/devices/cameras.py def get_widget ( self , ** kwargs ): \"\"\" Return the dynamically updating widget. Args: title (str): title of device \"\"\" from ..watchers import CameraWatcher if self . _watcher is None : self . _watcher = CameraWatcher ( self , ** kwargs ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . get_widget () else : return self . _watcher . get_widget ( ** kwargs ) get_width ( self ) \u00b6 Get the width in pixels of the camera. Source code in robots/devices/cameras.py def get_width ( self ): \"\"\" Get the width in pixels of the camera. \"\"\" return self . cameraShape [ 0 ] initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/cameras.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" # FIXME: camera is fixed at (0,0) facing forward self . type = \"camera\" self . bulbs_are_visible = True self . food_is_visible = True self . time = 0.0 self . cameraShape = [ 64 , 32 ] self . position = [ 0 , 0 ] self . max_range = 1000 self . samples = 1 self . name = \"camera\" # 0 = no fade, 1.0 = max fade self . colorsFadeWithDistance = 0.9 self . sizeFadeWithDistance = 1.0 self . reflectGround = True self . reflectSky = False self . set_fov ( 60 ) # degrees self . reset () reset ( self ) \u00b6 Internal method to reset the camera data. Source code in robots/devices/cameras.py def reset ( self ): \"\"\" Internal method to reset the camera data. \"\"\" self . hits = [[] for i in range ( self . cameraShape [ 0 ])] set_fov ( self , angle ) \u00b6 Set the field of view angle in degrees of the camera. Parameters: Name Type Description Default angle float angle in degrees of field of view required Source code in robots/devices/cameras.py def set_fov ( self , angle ): \"\"\" Set the field of view angle in degrees of the camera. Args: angle (float): angle in degrees of field of view \"\"\" # given in degrees # save in radians # scale = min(max(angle / 6.0, 0.0), 1.0) self . fov = angle * PI_OVER_180 # self.sizeFadeWithDistance = scale self . reset () set_height ( self , height ) \u00b6 Set the height of the camera in pixels. Parameters: Name Type Description Default height int height of camera in pixels required Source code in robots/devices/cameras.py def set_height ( self , height ): \"\"\" Set the height of the camera in pixels. Args: height (int): height of camera in pixels \"\"\" self . cameraShape [ 1 ] = height self . reset () set_max ( self , max_range ) \u00b6 Set the maximum distance the camera can see. Parameters: Name Type Description Default max_range float distance (in CM) the camera can see required Source code in robots/devices/cameras.py def set_max ( self , max_range ): \"\"\" Set the maximum distance the camera can see. Args: max_range (float): distance (in CM) the camera can see \"\"\" self . max_range = max_range set_name ( self , name ) \u00b6 Set the name of the camera. Parameters: Name Type Description Default name str the name of the camera required Source code in robots/devices/cameras.py def set_name ( self , name ): \"\"\" Set the name of the camera. Args: name (str): the name of the camera \"\"\" self . name = name set_size ( self , width , height ) \u00b6 Set the height and width of the camera in pixels. Parameters: Name Type Description Default width int width of camera in pixels required height int height of camera in pixels required Source code in robots/devices/cameras.py def set_size ( self , width , height ): \"\"\" Set the height and width of the camera in pixels. Args: width (int): width of camera in pixels height (int): height of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . cameraShape [ 1 ] = height self . reset () set_width ( self , width ) \u00b6 Set the width of the camera in pixels. Parameters: Name Type Description Default width int width of camera in pixels required Source code in robots/devices/cameras.py def set_width ( self , width ): \"\"\" Set the width of the camera in pixels. Args: width (int): width of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . reset () to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/cameras.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" return { \"class\" : self . __class__ . __name__ , \"width\" : self . cameraShape [ 0 ], \"height\" : self . cameraShape [ 1 ], \"colorsFadeWithDistance\" : self . colorsFadeWithDistance , \"sizeFadeWithDistance\" : self . sizeFadeWithDistance , \"reflectGround\" : self . reflectGround , \"reflectSky\" : self . reflectSky , \"fov\" : self . fov * ONE80_OVER_PI , # save in degrees \"max_range\" : self . max_range , \"samples\" : self . samples , \"name\" : self . name , \"position\" : self . position , } update ( self , draw_list = None ) \u00b6 Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" pass watch ( self , ** kwargs ) \u00b6 Create a dynamically updating view of this device. Parameters: Name Type Description Default title str title of device required Source code in robots/devices/cameras.py def watch ( self , ** kwargs ): \"\"\" Create a dynamically updating view of this device. Args: title (str): title of device \"\"\" if self . robot is None or self . robot . world is None : raise Exception ( \"can't watch device until added to robot, and robot is in world\" ) # Make the watcher if doesn't exist: self . get_widget ( ** kwargs ) self . _watcher . watch () __init__ ( self , width = 15 , height = 15 , name = 'ground-camera' , ** kwargs ) special \u00b6 A downward-facing camera device. Parameters: Name Type Description Default width int width of camera in pixels 15 height int height of camera in pixels 15 name str the name of the camera 'ground-camera' Source code in robots/devices/cameras.py def __init__ ( self , width = 15 , height = 15 , name = \"ground-camera\" , ** kwargs ): \"\"\" A downward-facing camera device. Args: width (int): width of camera in pixels height (int): height of camera in pixels name (str): the name of the camera \"\"\" config = { \"width\" : width , \"height\" : height , \"name\" : name , } self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" left = - ( self . cameraShape [ 0 ] // 2 ) / self . robot . world . scale upper = - ( self . cameraShape [ 1 ] // 2 ) / self . robot . world . scale right = ( self . cameraShape [ 0 ] // 2 ) / self . robot . world . scale lower = ( self . cameraShape [ 1 ] // 2 ) / self . robot . world . scale backend . strokeStyle ( Color ( 128 ), 1 ) backend . draw_line ( left , upper , right , upper ) backend . draw_line ( right , upper , right , lower ) backend . draw_line ( right , lower , left , lower ) backend . draw_line ( left , lower , left , upper ) from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/cameras.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" if \"width\" in config : self . cameraShape [ 0 ] = config [ \"width\" ] if \"height\" in config : self . cameraShape [ 1 ] = config [ \"height\" ] if \"name\" in config : self . name = config [ \"name\" ] get_image ( self , type = None ) \u00b6 Get an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" None Source code in robots/devices/cameras.py def get_image ( self , type = None ): \"\"\" Get an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" # FIXME: would be faster to trim image down # before rotating center = ( self . robot . x * self . robot . world . scale , self . robot . y * self . robot . world . scale , ) rotated_image = self . robot . world . _ground_image . rotate ( ( self . robot . a - math . pi / 4 * 6 ) * ( ONE80_OVER_PI ), center = center , ) left = center [ 0 ] - self . cameraShape [ 0 ] // 2 right = center [ 0 ] + self . cameraShape [ 0 ] // 2 upper = center [ 1 ] - self . cameraShape [ 1 ] // 2 lower = center [ 1 ] + self . cameraShape [ 1 ] // 2 return rotated_image . crop (( left , upper , right , lower )) initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/cameras.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"ground-camera\" self . time = 0.0 self . cameraShape = [ 15 , 15 ] self . name = \"ground-camera\" to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/cameras.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" return { \"class\" : self . __class__ . __name__ , \"width\" : self . cameraShape [ 0 ], \"height\" : self . cameraShape [ 1 ], \"name\" : self . name , } update ( self , draw_list = None ) \u00b6 Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. \"\"\" pass","title":"Cameras"},{"location":"camera/#cameras","text":"","title":"Cameras"},{"location":"camera/#aitk.robots.devices.cameras.Camera.__init__","text":"A camera device. Parameters: Name Type Description Default width int width of camera in pixels 64 height int height of camera in pixels 32 fov float width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. 30 colorsFadeWithDistance float colors get darker faster with larger value 1.0 sizeFadeWithDistance float size gets smaller faster with with larger value 0.8 reflectGround bool ground reflects for 3D point cloud True reflectSky bool sky reflects for 3D point cloud False max_range int maximum range of camera 1000 name str the name of the camera 'camera' samples int how many pixels should it sample 1 Source code in robots/devices/cameras.py def __init__ ( self , width = 64 , height = 32 , fov = 30 , colorsFadeWithDistance = 1.0 , sizeFadeWithDistance = 0.8 , reflectGround = True , reflectSky = False , max_range = 1000 , name = \"camera\" , samples = 1 , ** kwargs ): \"\"\" A camera device. Args: width (int): width of camera in pixels height (int): height of camera in pixels fov (float): width of camera field of view in degrees. Can be 180 or even 360 for wide angle cameras. colorsFadeWithDistance (float): colors get darker faster with larger value sizeFadeWithDistance (float): size gets smaller faster with with larger value reflectGround (bool): ground reflects for 3D point cloud reflectSky (bool): sky reflects for 3D point cloud max_range (int): maximum range of camera name (str): the name of the camera samples (int): how many pixels should it sample Note: currently the camera faces forward. \"\"\" config = { \"width\" : width , \"height\" : height , \"fov\" : fov , \"colorsFadeWithDistance\" : colorsFadeWithDistance , \"sizeFadeWithDistance\" : sizeFadeWithDistance , \"reflectGround\" : reflectGround , \"reflectSky\" : reflectSky , \"max_range\" : max_range , \"name\" : name , \"samples\" : samples , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.display","text":"Display an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" 'color' Source code in robots/devices/cameras.py def display ( self , type = \"color\" ): \"\"\" Display an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" image = self . get_image ( type = type ) display ( image )","title":"display()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend NOTE: Currently, cameras are fixed at 0,0 and face forwards. \"\"\" backend . set_fill ( Color ( 0 , 64 , 0 )) backend . strokeStyle ( None , 0 ) backend . draw_rect ( 5.0 , - 3.33 , 1.33 , 6.33 ) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a + self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , - self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , - self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ]) # Note angle in sim world is opposite in graphics: hits = self . robot . cast_ray ( self . robot . x , self . robot . y , PI_OVER_2 - self . robot . a - self . fov / 2 , self . max_range , ) if hits : p = rotate_around ( 0 , 0 , hits [ - 1 ] . distance , self . fov / 2 ,) else : p = rotate_around ( 0 , 0 , self . max_range , self . fov / 2 ,) backend . draw_line ( 0 , 0 , p [ 0 ], p [ 1 ])","title":"draw()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/cameras.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"width\" , \"name\" , \"height\" , \"colorsFadeWithDistance\" , \"sizeFadeWithDistance\" , \"reflectGround\" , \"reflectSky\" , \"fov\" , \"max_range\" , \"samples\" , \"position\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"width\" in config : self . cameraShape [ 0 ] = config [ \"width\" ] if \"height\" in config : self . cameraShape [ 1 ] = config [ \"height\" ] if \"colorsFadeWithDistance\" in config : self . colorsFadeWithDistance = config [ \"colorsFadeWithDistance\" ] if \"sizeFadeWithDistance\" in config : self . sizeFadeWithDistance = config [ \"sizeFadeWithDistance\" ] if \"reflectGround\" in config : self . reflectGround = config [ \"reflectGround\" ] if \"reflectSky\" in config : self . reflectSky = config [ \"reflectSky\" ] if \"fov\" in config : self . set_fov ( config [ \"fov\" ]) # degrees if \"max_range\" in config : self . max_range = config [ \"max_range\" ] if \"samples\" in config : self . samples = config [ \"samples\" ] if \"name\" in config : self . name = config [ \"name\" ] if \"position\" in config : self . position = config [ \"position\" ]","title":"from_json()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_fov","text":"Get the field of view angle in degrees. Source code in robots/devices/cameras.py def get_fov ( self ): \"\"\" Get the field of view angle in degrees. \"\"\" return self . fov * ONE80_OVER_PI","title":"get_fov()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_height","text":"Get the height in pixels of the camera. Source code in robots/devices/cameras.py def get_height ( self ): \"\"\" Get the height in pixels of the camera. \"\"\" return self . cameraShape [ 1 ]","title":"get_height()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_image","text":"Get an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" 'color' Source code in robots/devices/cameras.py def get_image ( self , type = \"color\" ): \"\"\" Get an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" try : from PIL import Image except ImportError : print ( \"Pillow (PIL) module not available; get_image() unavailable\" ) return # Lazy; only get the data when we need it: self . _update () if self . robot . world . _ground_image is not None : area = list ( self . _get_visible_area ()) else : area = None pic = Image . new ( \"RGBA\" , ( self . cameraShape [ 0 ], self . cameraShape [ 1 ])) pic_pixels = pic . load () # FIXME: probably should have a specific size rather than scale it to world size = max ( self . robot . world . width , self . robot . world . height ) hcolor = None # draw non-robot walls first: for i in range ( self . cameraShape [ 0 ]): hits = [ hit for hit in self . hits [ i ] if hit . height == 1.0 ] # only walls if len ( hits ) == 0 : continue hit = hits [ - 1 ] # get closest high = None hcolor = None if hit : if self . fov < PI_OVER_2 : # Orthoginal distance to camera: angle = hit . angle hit_distance = abs ( hit . distance * math . sin ( angle )) else : hit_distance = hit . distance distance_ratio = 1.0 - hit_distance / size s = distance_ratio * self . sizeFadeWithDistance sc = distance_ratio * self . colorsFadeWithDistance if type == \"color\" : r = hit . color . red * sc g = hit . color . green * sc b = hit . color . blue * sc elif type == \"depth\" : r = 255 * distance_ratio g = 255 * distance_ratio b = 255 * distance_ratio else : avg = ( hit . color . red + hit . color . green + hit . color . blue ) / 3.0 r = avg * sc g = avg * sc b = avg * sc hcolor = Color ( r , g , b ) high = ( 1.0 - s ) * self . cameraShape [ 1 ] else : high = 0 horizon = self . cameraShape [ 1 ] / 2 for j in range ( self . cameraShape [ 1 ]): dist = max ( min ( abs ( j - horizon ) / horizon , 1.0 ), 0.0 ) if j < high / 2 : # sky if type == \"depth\" : if self . reflectSky : color = Color ( 255 * dist ) else : color = Color ( 0 ) elif type == \"color\" : color = Color ( 0 , 0 , 128 ) else : color = Color ( 128 / 3 ) pic_pixels [ i , j ] = color . to_tuple () elif j < self . cameraShape [ 1 ] - high / 2 : # hit if hcolor is not None : pic_pixels [ i , j ] = hcolor . to_tuple () else : # ground if type == \"depth\" : if self . reflectGround : color = Color ( 255 * dist ) else : color = Color ( 0 ) elif type == \"color\" : color = self . _get_ground_color ( area , i , j ) else : color = Color ( 128 / 3 ) pic_pixels [ i , j ] = color . to_tuple () # Other robots, draw on top of walls: self . obstacles = {} for i in range ( self . cameraShape [ 0 ]): closest_wall_dist = self . _find_closest_wall ( self . hits [ i ]) hits = [ hit for hit in self . hits [ i ] if hit . height < 1.0 ] # obstacles for hit in hits : if hit . distance > closest_wall_dist : # Behind wall, try next continue if self . fov < PI_OVER_2 : angle = hit . angle hit_distance = abs ( hit . distance * math . sin ( angle )) else : # perspective hit_distance = hit . distance distance_ratio = 4.0 - hit_distance / size s = distance_ratio * self . sizeFadeWithDistance sc = distance_ratio * self . colorsFadeWithDistance distance_to = self . cameraShape [ 1 ] / 2 * ( 4.0 - sc ) # scribbler was 30, so 0.23 height ratio # height is ratio, 0 to 1 height = round ( hit . height * self . cameraShape [ 1 ] / 2.0 * s ) if type == \"color\" : r = hit . color . red * sc g = hit . color . green * sc b = hit . color . blue * sc elif type == \"depth\" : r = 255 * distance_ratio g = 255 * distance_ratio b = 255 * distance_ratio else : avg = ( hit . color . red + hit . color . green + hit . color . blue ) / 3.0 r = avg * sc g = avg * sc b = avg * sc hcolor = Color ( r , g , b ) horizon = self . cameraShape [ 1 ] / 2 self . _record_obstacle ( hit . robot , i , self . cameraShape [ 1 ] - 1 - round ( distance_to ), self . cameraShape [ 1 ] - height - 1 - 1 - round ( distance_to ), ) if not hit . robot . has_image (): for j in range ( height ): pic_pixels [ i , self . cameraShape [ 1 ] - j - 1 - round ( distance_to ) ] = hcolor . to_tuple () if self . bulbs_are_visible : self . _show_bulbs ( pic ) if self . food_is_visible : self . _show_food ( pic ) self . _show_obstacles ( pic ) return pic","title":"get_image()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_max","text":"Get the maximum distance in CM the camera can see. Source code in robots/devices/cameras.py def get_max ( self ): \"\"\" Get the maximum distance in CM the camera can see. \"\"\" return self . max_range","title":"get_max()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_name","text":"Get the name of the camera. Source code in robots/devices/cameras.py def get_name ( self ): \"\"\" Get the name of the camera. \"\"\" return self . name","title":"get_name()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_point_cloud","text":"Get a 3D point cloud from the camera data. Returns a list of [x, y, distance, red, green, blue] for each (x,y) of the camera. Source code in robots/devices/cameras.py def get_point_cloud ( self ): \"\"\" Get a 3D point cloud from the camera data. Returns a list of [x, y, distance, red, green, blue] for each (x,y) of the camera. \"\"\" depth_pic = self . get_image ( \"depth\" ) depth_pixels = depth_pic . load () color_pic = self . get_image ( \"color\" ) color_pixels = color_pic . load () points = [] for x in range ( self . cameraShape [ 0 ]): for y in range ( self . cameraShape [ 1 ]): dist_color = depth_pixels [ x , y ] color = color_pixels [ x , y ] if dist_color [ 0 ] != 255 : points . append ( [ self . cameraShape [ 0 ] - x - 1 , self . cameraShape [ 1 ] - y - 1 , dist_color [ 0 ], color [ 0 ], color [ 1 ], color [ 2 ], ] ) return points","title":"get_point_cloud()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_widget","text":"Return the dynamically updating widget. Parameters: Name Type Description Default title str title of device required Source code in robots/devices/cameras.py def get_widget ( self , ** kwargs ): \"\"\" Return the dynamically updating widget. Args: title (str): title of device \"\"\" from ..watchers import CameraWatcher if self . _watcher is None : self . _watcher = CameraWatcher ( self , ** kwargs ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . get_widget () else : return self . _watcher . get_widget ( ** kwargs )","title":"get_widget()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.get_width","text":"Get the width in pixels of the camera. Source code in robots/devices/cameras.py def get_width ( self ): \"\"\" Get the width in pixels of the camera. \"\"\" return self . cameraShape [ 0 ]","title":"get_width()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/cameras.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" # FIXME: camera is fixed at (0,0) facing forward self . type = \"camera\" self . bulbs_are_visible = True self . food_is_visible = True self . time = 0.0 self . cameraShape = [ 64 , 32 ] self . position = [ 0 , 0 ] self . max_range = 1000 self . samples = 1 self . name = \"camera\" # 0 = no fade, 1.0 = max fade self . colorsFadeWithDistance = 0.9 self . sizeFadeWithDistance = 1.0 self . reflectGround = True self . reflectSky = False self . set_fov ( 60 ) # degrees self . reset ()","title":"initialize()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.reset","text":"Internal method to reset the camera data. Source code in robots/devices/cameras.py def reset ( self ): \"\"\" Internal method to reset the camera data. \"\"\" self . hits = [[] for i in range ( self . cameraShape [ 0 ])]","title":"reset()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_fov","text":"Set the field of view angle in degrees of the camera. Parameters: Name Type Description Default angle float angle in degrees of field of view required Source code in robots/devices/cameras.py def set_fov ( self , angle ): \"\"\" Set the field of view angle in degrees of the camera. Args: angle (float): angle in degrees of field of view \"\"\" # given in degrees # save in radians # scale = min(max(angle / 6.0, 0.0), 1.0) self . fov = angle * PI_OVER_180 # self.sizeFadeWithDistance = scale self . reset ()","title":"set_fov()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_height","text":"Set the height of the camera in pixels. Parameters: Name Type Description Default height int height of camera in pixels required Source code in robots/devices/cameras.py def set_height ( self , height ): \"\"\" Set the height of the camera in pixels. Args: height (int): height of camera in pixels \"\"\" self . cameraShape [ 1 ] = height self . reset ()","title":"set_height()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_max","text":"Set the maximum distance the camera can see. Parameters: Name Type Description Default max_range float distance (in CM) the camera can see required Source code in robots/devices/cameras.py def set_max ( self , max_range ): \"\"\" Set the maximum distance the camera can see. Args: max_range (float): distance (in CM) the camera can see \"\"\" self . max_range = max_range","title":"set_max()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_name","text":"Set the name of the camera. Parameters: Name Type Description Default name str the name of the camera required Source code in robots/devices/cameras.py def set_name ( self , name ): \"\"\" Set the name of the camera. Args: name (str): the name of the camera \"\"\" self . name = name","title":"set_name()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_size","text":"Set the height and width of the camera in pixels. Parameters: Name Type Description Default width int width of camera in pixels required height int height of camera in pixels required Source code in robots/devices/cameras.py def set_size ( self , width , height ): \"\"\" Set the height and width of the camera in pixels. Args: width (int): width of camera in pixels height (int): height of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . cameraShape [ 1 ] = height self . reset ()","title":"set_size()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.set_width","text":"Set the width of the camera in pixels. Parameters: Name Type Description Default width int width of camera in pixels required Source code in robots/devices/cameras.py def set_width ( self , width ): \"\"\" Set the width of the camera in pixels. Args: width (int): width of camera in pixels \"\"\" self . cameraShape [ 0 ] = width self . reset ()","title":"set_width()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/cameras.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" return { \"class\" : self . __class__ . __name__ , \"width\" : self . cameraShape [ 0 ], \"height\" : self . cameraShape [ 1 ], \"colorsFadeWithDistance\" : self . colorsFadeWithDistance , \"sizeFadeWithDistance\" : self . sizeFadeWithDistance , \"reflectGround\" : self . reflectGround , \"reflectSky\" : self . reflectSky , \"fov\" : self . fov * ONE80_OVER_PI , # save in degrees \"max_range\" : self . max_range , \"samples\" : self . samples , \"name\" : self . name , \"position\" : self . position , }","title":"to_json()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.update","text":"Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" pass","title":"update()"},{"location":"camera/#aitk.robots.devices.cameras.Camera.watch","text":"Create a dynamically updating view of this device. Parameters: Name Type Description Default title str title of device required Source code in robots/devices/cameras.py def watch ( self , ** kwargs ): \"\"\" Create a dynamically updating view of this device. Args: title (str): title of device \"\"\" if self . robot is None or self . robot . world is None : raise Exception ( \"can't watch device until added to robot, and robot is in world\" ) # Make the watcher if doesn't exist: self . get_widget ( ** kwargs ) self . _watcher . watch ()","title":"watch()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.__init__","text":"A downward-facing camera device. Parameters: Name Type Description Default width int width of camera in pixels 15 height int height of camera in pixels 15 name str the name of the camera 'ground-camera' Source code in robots/devices/cameras.py def __init__ ( self , width = 15 , height = 15 , name = \"ground-camera\" , ** kwargs ): \"\"\" A downward-facing camera device. Args: width (int): width of camera in pixels height (int): height of camera in pixels name (str): the name of the camera \"\"\" config = { \"width\" : width , \"height\" : height , \"name\" : name , } self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/cameras.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" left = - ( self . cameraShape [ 0 ] // 2 ) / self . robot . world . scale upper = - ( self . cameraShape [ 1 ] // 2 ) / self . robot . world . scale right = ( self . cameraShape [ 0 ] // 2 ) / self . robot . world . scale lower = ( self . cameraShape [ 1 ] // 2 ) / self . robot . world . scale backend . strokeStyle ( Color ( 128 ), 1 ) backend . draw_line ( left , upper , right , upper ) backend . draw_line ( right , upper , right , lower ) backend . draw_line ( right , lower , left , lower ) backend . draw_line ( left , lower , left , upper )","title":"draw()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/cameras.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" if \"width\" in config : self . cameraShape [ 0 ] = config [ \"width\" ] if \"height\" in config : self . cameraShape [ 1 ] = config [ \"height\" ] if \"name\" in config : self . name = config [ \"name\" ]","title":"from_json()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.get_image","text":"Get an image of the camera. Parameters: Name Type Description Default type str the return type of image. Can be \"color\" or \"depth\" None Source code in robots/devices/cameras.py def get_image ( self , type = None ): \"\"\" Get an image of the camera. Args: type (str): the return type of image. Can be \"color\" or \"depth\" \"\"\" # FIXME: would be faster to trim image down # before rotating center = ( self . robot . x * self . robot . world . scale , self . robot . y * self . robot . world . scale , ) rotated_image = self . robot . world . _ground_image . rotate ( ( self . robot . a - math . pi / 4 * 6 ) * ( ONE80_OVER_PI ), center = center , ) left = center [ 0 ] - self . cameraShape [ 0 ] // 2 right = center [ 0 ] + self . cameraShape [ 0 ] // 2 upper = center [ 1 ] - self . cameraShape [ 1 ] // 2 lower = center [ 1 ] + self . cameraShape [ 1 ] // 2 return rotated_image . crop (( left , upper , right , lower ))","title":"get_image()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/cameras.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"ground-camera\" self . time = 0.0 self . cameraShape = [ 15 , 15 ] self . name = \"ground-camera\"","title":"initialize()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/cameras.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" return { \"class\" : self . __class__ . __name__ , \"width\" : self . cameraShape [ 0 ], \"height\" : self . cameraShape [ 1 ], \"name\" : self . name , }","title":"to_json()"},{"location":"camera/#aitk.robots.devices.cameras.GroundCamera.update","text":"Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. Source code in robots/devices/cameras.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. Cameras operate in a lazy way: they don't actually update until needed because they are so expensive. \"\"\" pass","title":"update()"},{"location":"lightsensor/","text":"LightSensor \u00b6 __init__ ( self , position = ( 0 , 0 ), name = 'light' , color_sensitivity = None , ** kwargs ) special \u00b6 A light sensor for sensing bulbs. Parameters: Name Type Description Default position Tuple[int, int] the position of the sensor in centimeters relative to the center of the robot. (0, 0) name str the name of the device 'light' color_sensitivity Color the name of the color that the sensor is sensitive to. None means that it is sensitive to all colors. None Source code in robots/devices/lightsensors.py def __init__ ( self , position = ( 0 , 0 ), name = \"light\" , color_sensitivity = None , ** kwargs ): \"\"\" A light sensor for sensing bulbs. Args: position (Tuple[int, int]): the position of the sensor in centimeters relative to the center of the robot. name (str): the name of the device color_sensitivity (Color): the name of the color that the sensor is sensitive to. None means that it is sensitive to all colors. \"\"\" config = { \"position\" : position , \"name\" : name , \"color_sensitivity\" : color_sensitivity , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/lightsensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . lineWidth ( 1 ) backend . set_stroke_style ( BLACK ) if self . color_sensitivity is not None : backend . set_fill_style ( self . color_sensitivity ) else : backend . set_fill_style ( YELLOW ) backend . draw_circle ( self . position [ 0 ], self . position [ 1 ], 2 ) from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/lightsensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"name\" , \"class\" , \"color_sensitivity\" ]) self . verify_config ( valid_keys , config ) if \"name\" in config : self . name = config [ \"name\" ] if \"color_sensitivity\" in config : if config [ \"color_sensitivity\" ] is not None : self . color_sensitivity = Color ( config [ \"color_sensitivity\" ]) else : self . color_sensitivity = None config [ \"color_sensitivity\" ] = self . color_sensitivity if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) get_brightness ( self ) \u00b6 Get the light brightness reading from the sensor. Source code in robots/devices/lightsensors.py def get_brightness ( self ): \"\"\" Get the light brightness reading from the sensor. \"\"\" return self . value get_widget ( self , title = 'Light Sensor:' ) \u00b6 Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor 'Light Sensor:' Source code in robots/devices/lightsensors.py def get_widget ( self , title = \"Light Sensor:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"value\" , title = title , labels = [ \"Name:\" , \"Light:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/lightsensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"light\" self . name = \"light\" self . color_sensitivity = None self . value = 0.0 # FIXME: add to config self . multiplier = 1000 # CM self . position = [ 0 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) set_position ( self , position ) \u00b6 Set the position of the light sensor with respect to the center of the robot. Parameters: Name Type Description Default position List[int, int] represents [x, y] in CM from center of robot required Source code in robots/devices/lightsensors.py def set_position ( self , position ): \"\"\" Set the position of the light sensor with respect to the center of the robot. Args: position (List[int, int]): represents [x, y] in CM from center of robot \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/lightsensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"name\" : self . name , \"color_sensitivity\" : str ( self . color_sensitivity ) if self . color_sensitivity is not None else None , } return config update ( self , draw_list = None ) \u00b6 Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/lightsensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" self . value = 0 # Location of sensor: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + math . pi / 2 , ) for bulb in self . robot . world . _get_light_sources ( all = True ): # for each light source: if bulb . robot is self . robot : # You can't sense your own bulbs continue if (( self . color_sensitivity is not None ) and ( self . color_sensitivity != bulb . color )): # If sensitivity is set, if bulb doesn't match # skip it continue z , brightness , light_color = ( # noqa: F841 bulb . z , bulb . brightness , bulb . color , ) x , y = bulb . get_position ( world = True ) angle = math . atan2 ( x - p [ 0 ], y - p [ 1 ]) dist = distance ( x , y , p [ 0 ], p [ 1 ]) ignore_robots = [] if bulb . robot is not None : ignore_robots . append ( bulb . robot ) if self . robot is not None : ignore_robots . append ( self . robot ) hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], angle , dist , ignore_robots = ignore_robots ) if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_circle\" , ( p [ 0 ], p [ 1 ], 2 ), {})) draw_list . append (( \"draw_circle\" , ( x , y , 2 ), {})) for hit in hits : draw_list . append (( \"set_fill_style\" , ( PURPLE ,), {})) draw_list . append (( \"draw_circle\" , ( hit . x , hit . y , 2 ), {})) if len ( hits ) == 0 : # nothing blocking! we can see the light # Maximum value of 100.0 with defaults: self . value += ( normal_dist ( dist , 0 , brightness ) / math . pi ) / brightness self . value = min ( self . value , 1.0 ) if draw_list is not None : draw_list . append (( \"strokeStyle\" , ( PURPLE , 1 ), {})) draw_list . append (( \"draw_line\" , ( x , y , p [ 0 ], p [ 1 ]), {})) watch ( self , title = 'Light Sensor:' ) \u00b6 Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Light Sensor:' Source code in robots/devices/lightsensors.py def watch ( self , title = \"Light Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"LightSensor"},{"location":"lightsensor/#lightsensor","text":"","title":"LightSensor"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.__init__","text":"A light sensor for sensing bulbs. Parameters: Name Type Description Default position Tuple[int, int] the position of the sensor in centimeters relative to the center of the robot. (0, 0) name str the name of the device 'light' color_sensitivity Color the name of the color that the sensor is sensitive to. None means that it is sensitive to all colors. None Source code in robots/devices/lightsensors.py def __init__ ( self , position = ( 0 , 0 ), name = \"light\" , color_sensitivity = None , ** kwargs ): \"\"\" A light sensor for sensing bulbs. Args: position (Tuple[int, int]): the position of the sensor in centimeters relative to the center of the robot. name (str): the name of the device color_sensitivity (Color): the name of the color that the sensor is sensitive to. None means that it is sensitive to all colors. \"\"\" config = { \"position\" : position , \"name\" : name , \"color_sensitivity\" : color_sensitivity , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/lightsensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . lineWidth ( 1 ) backend . set_stroke_style ( BLACK ) if self . color_sensitivity is not None : backend . set_fill_style ( self . color_sensitivity ) else : backend . set_fill_style ( YELLOW ) backend . draw_circle ( self . position [ 0 ], self . position [ 1 ], 2 )","title":"draw()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/lightsensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"name\" , \"class\" , \"color_sensitivity\" ]) self . verify_config ( valid_keys , config ) if \"name\" in config : self . name = config [ \"name\" ] if \"color_sensitivity\" in config : if config [ \"color_sensitivity\" ] is not None : self . color_sensitivity = Color ( config [ \"color_sensitivity\" ]) else : self . color_sensitivity = None config [ \"color_sensitivity\" ] = self . color_sensitivity if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"from_json()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.get_brightness","text":"Get the light brightness reading from the sensor. Source code in robots/devices/lightsensors.py def get_brightness ( self ): \"\"\" Get the light brightness reading from the sensor. \"\"\" return self . value","title":"get_brightness()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.get_widget","text":"Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor 'Light Sensor:' Source code in robots/devices/lightsensors.py def get_widget ( self , title = \"Light Sensor:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"value\" , title = title , labels = [ \"Name:\" , \"Light:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget","title":"get_widget()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/lightsensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"light\" self . name = \"light\" self . color_sensitivity = None self . value = 0.0 # FIXME: add to config self . multiplier = 1000 # CM self . position = [ 0 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"initialize()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.set_position","text":"Set the position of the light sensor with respect to the center of the robot. Parameters: Name Type Description Default position List[int, int] represents [x, y] in CM from center of robot required Source code in robots/devices/lightsensors.py def set_position ( self , position ): \"\"\" Set the position of the light sensor with respect to the center of the robot. Args: position (List[int, int]): represents [x, y] in CM from center of robot \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"set_position()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/lightsensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"name\" : self . name , \"color_sensitivity\" : str ( self . color_sensitivity ) if self . color_sensitivity is not None else None , } return config","title":"to_json()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.update","text":"Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/lightsensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" self . value = 0 # Location of sensor: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + math . pi / 2 , ) for bulb in self . robot . world . _get_light_sources ( all = True ): # for each light source: if bulb . robot is self . robot : # You can't sense your own bulbs continue if (( self . color_sensitivity is not None ) and ( self . color_sensitivity != bulb . color )): # If sensitivity is set, if bulb doesn't match # skip it continue z , brightness , light_color = ( # noqa: F841 bulb . z , bulb . brightness , bulb . color , ) x , y = bulb . get_position ( world = True ) angle = math . atan2 ( x - p [ 0 ], y - p [ 1 ]) dist = distance ( x , y , p [ 0 ], p [ 1 ]) ignore_robots = [] if bulb . robot is not None : ignore_robots . append ( bulb . robot ) if self . robot is not None : ignore_robots . append ( self . robot ) hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], angle , dist , ignore_robots = ignore_robots ) if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_circle\" , ( p [ 0 ], p [ 1 ], 2 ), {})) draw_list . append (( \"draw_circle\" , ( x , y , 2 ), {})) for hit in hits : draw_list . append (( \"set_fill_style\" , ( PURPLE ,), {})) draw_list . append (( \"draw_circle\" , ( hit . x , hit . y , 2 ), {})) if len ( hits ) == 0 : # nothing blocking! we can see the light # Maximum value of 100.0 with defaults: self . value += ( normal_dist ( dist , 0 , brightness ) / math . pi ) / brightness self . value = min ( self . value , 1.0 ) if draw_list is not None : draw_list . append (( \"strokeStyle\" , ( PURPLE , 1 ), {})) draw_list . append (( \"draw_line\" , ( x , y , p [ 0 ], p [ 1 ]), {}))","title":"update()"},{"location":"lightsensor/#aitk.robots.devices.lightsensors.LightSensor.watch","text":"Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Light Sensor:' Source code in robots/devices/lightsensors.py def watch ( self , title = \"Light Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"watch()"},{"location":"rangesensor/","text":"RangeSensor \u00b6 __init__ ( self , position = ( 8 , 0 ), a = 0 , max = 20 , width = 1.0 , name = 'sensor' , ** kwargs ) special \u00b6 A range sensor calculates both a \"distance\" and a \"reading\". The \"distance\" is the actual distance to an obstacle in CM (when it is within the \"max\" distance). The reading is a ratio of distance/max. When no obstacle is sensed the \"reading\" is 1.0 and as the robot approaches an obstacle the \"reading\" decreases towards 0.0. Parameters: Name Type Description Default position List[int, int] the location on the robot in (x, y) (8, 0) a float the direction in degrees the sensor is facing. 0 max float max distance in CM that the range sensor can sense 20 width float 0 for laser, or wider for sonar 1.0 name str the name of the sensor 'sensor' Source code in robots/devices/rangesensors.py def __init__ ( self , position = ( 8 , 0 ), a = 0 , max = 20 , width = 1.0 , name = \"sensor\" , ** kwargs ): \"\"\" A range sensor calculates both a \"distance\" and a \"reading\". The \"distance\" is the actual distance to an obstacle in CM (when it is within the \"max\" distance). The reading is a ratio of distance/max. When no obstacle is sensed the \"reading\" is 1.0 and as the robot approaches an obstacle the \"reading\" decreases towards 0.0. Args: position (List[int, int]): the location on the robot in (x, y) a (float): the direction in degrees the sensor is facing. max (float): max distance in CM that the range sensor can sense width (float): 0 for laser, or wider for sonar name (str): the name of the sensor \"\"\" config = { \"position\" : position , \"a\" : a , # degrees in the config file \"max\" : max , \"width\" : width , \"name\" : name , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/rangesensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . set_fill ( Color ( 128 , 0 , 128 , 64 )) dist = self . get_distance () if self . width > 0 : if self . get_reading () < 1.0 : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) backend . draw_arc ( self . position [ 0 ], self . position [ 1 ], dist , dist , self . a - self . width / 2 , self . a + self . width / 2 , ) else : if self . get_reading () < 1.0 : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 128 , 0 , 128 , 64 ), 1 ) x , y = rotate_around ( self . position [ 0 ], self . position [ 1 ], dist , self . a ) backend . draw_line ( self . position [ 0 ], self . position [ 1 ], x , y ) from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/rangesensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"a\" , \"max\" , \"width\" , \"name\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"max\" in config : self . max = config [ \"max\" ] if \"width\" in config : self . width = config [ \"width\" ] * PI_OVER_180 # save as radians if self . width == 0 : self . type = \"laser\" if \"name\" in config : self . name = config [ \"name\" ] self . distance = self . reading * self . max get_angle ( self ) \u00b6 Get the direction in degrees. Use RangeSensor.a to get the raw radians. Source code in robots/devices/rangesensors.py def get_angle ( self ): \"\"\" Get the direction in degrees. Use RangeSensor.a to get the raw radians. \"\"\" return world_to_degrees ( self . a ) get_distance ( self ) \u00b6 Get the last range distance of the sensor in CM. The distance is between 0 and max. Source code in robots/devices/rangesensors.py def get_distance ( self ): \"\"\" Get the last range distance of the sensor in CM. The distance is between 0 and max. \"\"\" return self . distance get_max ( self ) \u00b6 Get the maximum distance in CM the sensor can sense. Source code in robots/devices/rangesensors.py def get_max ( self ): \"\"\" Get the maximum distance in CM the sensor can sense. \"\"\" return self . max get_name ( self ) \u00b6 Get the name of the range sensor. Source code in robots/devices/rangesensors.py def get_name ( self ): \"\"\" Get the name of the range sensor. \"\"\" return self . name get_position ( self ) \u00b6 Get the position of the sensor. This represents the location of the sensor in [x, y] CM. Source code in robots/devices/rangesensors.py def get_position ( self ): \"\"\" Get the position of the sensor. This represents the location of the sensor in [x, y] CM. \"\"\" return self . position get_reading ( self ) \u00b6 Get the last range reading of the sensor. The reading is between 0 and 1. Source code in robots/devices/rangesensors.py def get_reading ( self ): \"\"\" Get the last range reading of the sensor. The reading is between 0 and 1. \"\"\" return self . reading get_widget ( self , title = None , attributes = None ) \u00b6 Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor None Source code in robots/devices/rangesensors.py def get_widget ( self , title = None , attributes = None ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : title = title if title is not None else \"Range Sensor:\" attributes = attributes if attributes is not None else \"all\" self . _watcher = AttributesWatcher ( self , \"name\" , \"reading\" , \"distance\" , title = title , labels = [ \"Name:\" , \"Reading:\" , \"Distance:\" ], attributes = attributes , ) self . robot . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( title = title , attributes = attributes ) self . _watcher . update () return self . _watcher . widget get_width ( self ) \u00b6 Get the width of the sensor in degrees. Use RangeSensor.width to see raw radians. Source code in robots/devices/rangesensors.py def get_width ( self ): \"\"\" Get the width of the sensor in degrees. Use RangeSensor.width to see raw radians. \"\"\" return self . width * ONE80_OVER_PI initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/rangesensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"ir\" self . time = 0.0 self . reading = 1.0 self . position = [ 8 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) self . a = degrees_to_world ( 0 ) # comes in degrees, save as radians self . max = 20 # CM self . width = 1.0 # radians self . name = \"sensor\" self . distance = self . reading * self . max set_angle ( self , a ) \u00b6 Set the direction of the sensor. Parameters: Name Type Description Default a float the angle of the direction of sensor in degrees required Source code in robots/devices/rangesensors.py def set_angle ( self , a ): \"\"\" Set the direction of the sensor. Args: a (float): the angle of the direction of sensor in degrees \"\"\" self . a = degrees_to_world ( a ) set_distance ( self , distance ) \u00b6 Set the distance that the sensor is reading. You would not usually do this manually. Parameters: Name Type Description Default distance float distance in CM to sensed object required Source code in robots/devices/rangesensors.py def set_distance ( self , distance ): \"\"\" Set the distance that the sensor is reading. You would not usually do this manually. Args: distance (float): distance in CM to sensed object \"\"\" self . distance = distance self . reading = distance / self . max set_max ( self , max ) \u00b6 Set the maximum distance in CM that this sensor can sense. Parameters: Name Type Description Default max float max distance in CM the sensor can sense. required Source code in robots/devices/rangesensors.py def set_max ( self , max ): \"\"\" Set the maximum distance in CM that this sensor can sense. Args: max (float): max distance in CM the sensor can sense. \"\"\" self . max = max set_name ( self , name ) \u00b6 Set the name of the range sensor. Parameters: Name Type Description Default name str the name of the range sensor required Source code in robots/devices/rangesensors.py def set_name ( self , name ): \"\"\" Set the name of the range sensor. Args: name (str): the name of the range sensor \"\"\" self . name = name set_position ( self , position ) \u00b6 Set the position of the sensor. position must be a list/tuple of length 2 representing [x, y] in CM of the location of the sensor relative to the center of the robot. Parameters: Name Type Description Default position List[int, int] the location of the sensor in relationship to the center of the robot. required Source code in robots/devices/rangesensors.py def set_position ( self , position ): \"\"\" Set the position of the sensor. position must be a list/tuple of length 2 representing [x, y] in CM of the location of the sensor relative to the center of the robot. Args: position (List[int, int]): the location of the sensor in relationship to the center of the robot. \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) set_reading ( self , reading ) \u00b6 Set the reading that the sensor is reading. You would not usually do this manually. Parameters: Name Type Description Default reading float between 0 and 1 required Source code in robots/devices/rangesensors.py def set_reading ( self , reading ): \"\"\" Set the reading that the sensor is reading. You would not usually do this manually. Args: reading (float): between 0 and 1 \"\"\" self . reading = reading self . distance = reading * self . max set_width ( self , width ) \u00b6 Set the width of the range sensor in degrees. 0 width is a laser range finder. Larger values indicate the width of an IR sensor. It is measured in three locations: start, middle, and stop. The value of the sensor is the minimum of the three. Parameters: Name Type Description Default width float angle in degrees required Source code in robots/devices/rangesensors.py def set_width ( self , width ): \"\"\" Set the width of the range sensor in degrees. 0 width is a laser range finder. Larger values indicate the width of an IR sensor. It is measured in three locations: start, middle, and stop. The value of the sensor is the minimum of the three. Args: width (float): angle in degrees \"\"\" self . width = width * PI_OVER_180 # save as radians if self . width == 0 : self . type = \"laser\" else : self . type = \"ir\" to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/rangesensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"a\" : world_to_degrees ( self . a ), \"max\" : self . max , \"width\" : self . width * ONE80_OVER_PI , # save as degrees \"name\" : self . name , } return config update ( self , draw_list = None ) \u00b6 Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/rangesensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" # Update timestamp: self . time = self . robot . world . time # This changes: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + PI_OVER_2 , ) if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_ellipse\" , ( p [ 0 ], p [ 1 ], 2 , 2 ), {})) self . set_reading ( 1.0 ) if self . width != 0 : for incr in arange ( - self . width / 2 , self . width / 2 , self . width / 2 ): hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], - self . robot . a + PI_OVER_2 + incr - self . a , self . max , ) if hits : if self . robot . world . debug and draw_list is not None : draw_list . append ( ( \"draw_ellipse\" , ( hits [ - 1 ] . x , hits [ - 1 ] . y , 2 , 2 ), {}) ) # Closest hit: if hits [ - 1 ] . distance < self . get_distance (): self . set_distance ( hits [ - 1 ] . distance ) else : hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], - self . robot . a + PI_OVER_2 - self . a , self . max , ) if hits : if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_ellipse\" , ( hits [ - 1 ] . x , hits [ - 1 ] . y , 2 , 2 ), {})) # Closest hit: if hits [ - 1 ] . distance < self . get_distance (): self . set_distance ( hits [ - 1 ] . distance ) watch ( self , title = 'Range Sensor:' ) \u00b6 Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Range Sensor:' Source code in robots/devices/rangesensors.py def watch ( self , title = \"Range Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"RangeSensor"},{"location":"rangesensor/#rangesensor","text":"","title":"RangeSensor"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.__init__","text":"A range sensor calculates both a \"distance\" and a \"reading\". The \"distance\" is the actual distance to an obstacle in CM (when it is within the \"max\" distance). The reading is a ratio of distance/max. When no obstacle is sensed the \"reading\" is 1.0 and as the robot approaches an obstacle the \"reading\" decreases towards 0.0. Parameters: Name Type Description Default position List[int, int] the location on the robot in (x, y) (8, 0) a float the direction in degrees the sensor is facing. 0 max float max distance in CM that the range sensor can sense 20 width float 0 for laser, or wider for sonar 1.0 name str the name of the sensor 'sensor' Source code in robots/devices/rangesensors.py def __init__ ( self , position = ( 8 , 0 ), a = 0 , max = 20 , width = 1.0 , name = \"sensor\" , ** kwargs ): \"\"\" A range sensor calculates both a \"distance\" and a \"reading\". The \"distance\" is the actual distance to an obstacle in CM (when it is within the \"max\" distance). The reading is a ratio of distance/max. When no obstacle is sensed the \"reading\" is 1.0 and as the robot approaches an obstacle the \"reading\" decreases towards 0.0. Args: position (List[int, int]): the location on the robot in (x, y) a (float): the direction in degrees the sensor is facing. max (float): max distance in CM that the range sensor can sense width (float): 0 for laser, or wider for sonar name (str): the name of the sensor \"\"\" config = { \"position\" : position , \"a\" : a , # degrees in the config file \"max\" : max , \"width\" : width , \"name\" : name , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/rangesensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . set_fill ( Color ( 128 , 0 , 128 , 64 )) dist = self . get_distance () if self . width > 0 : if self . get_reading () < 1.0 : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) backend . draw_arc ( self . position [ 0 ], self . position [ 1 ], dist , dist , self . a - self . width / 2 , self . a + self . width / 2 , ) else : if self . get_reading () < 1.0 : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 128 , 0 , 128 , 64 ), 1 ) x , y = rotate_around ( self . position [ 0 ], self . position [ 1 ], dist , self . a ) backend . draw_line ( self . position [ 0 ], self . position [ 1 ], x , y )","title":"draw()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/rangesensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"a\" , \"max\" , \"width\" , \"name\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"max\" in config : self . max = config [ \"max\" ] if \"width\" in config : self . width = config [ \"width\" ] * PI_OVER_180 # save as radians if self . width == 0 : self . type = \"laser\" if \"name\" in config : self . name = config [ \"name\" ] self . distance = self . reading * self . max","title":"from_json()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_angle","text":"Get the direction in degrees. Use RangeSensor.a to get the raw radians. Source code in robots/devices/rangesensors.py def get_angle ( self ): \"\"\" Get the direction in degrees. Use RangeSensor.a to get the raw radians. \"\"\" return world_to_degrees ( self . a )","title":"get_angle()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_distance","text":"Get the last range distance of the sensor in CM. The distance is between 0 and max. Source code in robots/devices/rangesensors.py def get_distance ( self ): \"\"\" Get the last range distance of the sensor in CM. The distance is between 0 and max. \"\"\" return self . distance","title":"get_distance()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_max","text":"Get the maximum distance in CM the sensor can sense. Source code in robots/devices/rangesensors.py def get_max ( self ): \"\"\" Get the maximum distance in CM the sensor can sense. \"\"\" return self . max","title":"get_max()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_name","text":"Get the name of the range sensor. Source code in robots/devices/rangesensors.py def get_name ( self ): \"\"\" Get the name of the range sensor. \"\"\" return self . name","title":"get_name()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_position","text":"Get the position of the sensor. This represents the location of the sensor in [x, y] CM. Source code in robots/devices/rangesensors.py def get_position ( self ): \"\"\" Get the position of the sensor. This represents the location of the sensor in [x, y] CM. \"\"\" return self . position","title":"get_position()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_reading","text":"Get the last range reading of the sensor. The reading is between 0 and 1. Source code in robots/devices/rangesensors.py def get_reading ( self ): \"\"\" Get the last range reading of the sensor. The reading is between 0 and 1. \"\"\" return self . reading","title":"get_reading()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_widget","text":"Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor None Source code in robots/devices/rangesensors.py def get_widget ( self , title = None , attributes = None ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : title = title if title is not None else \"Range Sensor:\" attributes = attributes if attributes is not None else \"all\" self . _watcher = AttributesWatcher ( self , \"name\" , \"reading\" , \"distance\" , title = title , labels = [ \"Name:\" , \"Reading:\" , \"Distance:\" ], attributes = attributes , ) self . robot . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( title = title , attributes = attributes ) self . _watcher . update () return self . _watcher . widget","title":"get_widget()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.get_width","text":"Get the width of the sensor in degrees. Use RangeSensor.width to see raw radians. Source code in robots/devices/rangesensors.py def get_width ( self ): \"\"\" Get the width of the sensor in degrees. Use RangeSensor.width to see raw radians. \"\"\" return self . width * ONE80_OVER_PI","title":"get_width()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/rangesensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"ir\" self . time = 0.0 self . reading = 1.0 self . position = [ 8 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) self . a = degrees_to_world ( 0 ) # comes in degrees, save as radians self . max = 20 # CM self . width = 1.0 # radians self . name = \"sensor\" self . distance = self . reading * self . max","title":"initialize()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_angle","text":"Set the direction of the sensor. Parameters: Name Type Description Default a float the angle of the direction of sensor in degrees required Source code in robots/devices/rangesensors.py def set_angle ( self , a ): \"\"\" Set the direction of the sensor. Args: a (float): the angle of the direction of sensor in degrees \"\"\" self . a = degrees_to_world ( a )","title":"set_angle()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_distance","text":"Set the distance that the sensor is reading. You would not usually do this manually. Parameters: Name Type Description Default distance float distance in CM to sensed object required Source code in robots/devices/rangesensors.py def set_distance ( self , distance ): \"\"\" Set the distance that the sensor is reading. You would not usually do this manually. Args: distance (float): distance in CM to sensed object \"\"\" self . distance = distance self . reading = distance / self . max","title":"set_distance()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_max","text":"Set the maximum distance in CM that this sensor can sense. Parameters: Name Type Description Default max float max distance in CM the sensor can sense. required Source code in robots/devices/rangesensors.py def set_max ( self , max ): \"\"\" Set the maximum distance in CM that this sensor can sense. Args: max (float): max distance in CM the sensor can sense. \"\"\" self . max = max","title":"set_max()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_name","text":"Set the name of the range sensor. Parameters: Name Type Description Default name str the name of the range sensor required Source code in robots/devices/rangesensors.py def set_name ( self , name ): \"\"\" Set the name of the range sensor. Args: name (str): the name of the range sensor \"\"\" self . name = name","title":"set_name()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_position","text":"Set the position of the sensor. position must be a list/tuple of length 2 representing [x, y] in CM of the location of the sensor relative to the center of the robot. Parameters: Name Type Description Default position List[int, int] the location of the sensor in relationship to the center of the robot. required Source code in robots/devices/rangesensors.py def set_position ( self , position ): \"\"\" Set the position of the sensor. position must be a list/tuple of length 2 representing [x, y] in CM of the location of the sensor relative to the center of the robot. Args: position (List[int, int]): the location of the sensor in relationship to the center of the robot. \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"set_position()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_reading","text":"Set the reading that the sensor is reading. You would not usually do this manually. Parameters: Name Type Description Default reading float between 0 and 1 required Source code in robots/devices/rangesensors.py def set_reading ( self , reading ): \"\"\" Set the reading that the sensor is reading. You would not usually do this manually. Args: reading (float): between 0 and 1 \"\"\" self . reading = reading self . distance = reading * self . max","title":"set_reading()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.set_width","text":"Set the width of the range sensor in degrees. 0 width is a laser range finder. Larger values indicate the width of an IR sensor. It is measured in three locations: start, middle, and stop. The value of the sensor is the minimum of the three. Parameters: Name Type Description Default width float angle in degrees required Source code in robots/devices/rangesensors.py def set_width ( self , width ): \"\"\" Set the width of the range sensor in degrees. 0 width is a laser range finder. Larger values indicate the width of an IR sensor. It is measured in three locations: start, middle, and stop. The value of the sensor is the minimum of the three. Args: width (float): angle in degrees \"\"\" self . width = width * PI_OVER_180 # save as radians if self . width == 0 : self . type = \"laser\" else : self . type = \"ir\"","title":"set_width()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/rangesensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"a\" : world_to_degrees ( self . a ), \"max\" : self . max , \"width\" : self . width * ONE80_OVER_PI , # save as degrees \"name\" : self . name , } return config","title":"to_json()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.update","text":"Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/rangesensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" # Update timestamp: self . time = self . robot . world . time # This changes: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + PI_OVER_2 , ) if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_ellipse\" , ( p [ 0 ], p [ 1 ], 2 , 2 ), {})) self . set_reading ( 1.0 ) if self . width != 0 : for incr in arange ( - self . width / 2 , self . width / 2 , self . width / 2 ): hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], - self . robot . a + PI_OVER_2 + incr - self . a , self . max , ) if hits : if self . robot . world . debug and draw_list is not None : draw_list . append ( ( \"draw_ellipse\" , ( hits [ - 1 ] . x , hits [ - 1 ] . y , 2 , 2 ), {}) ) # Closest hit: if hits [ - 1 ] . distance < self . get_distance (): self . set_distance ( hits [ - 1 ] . distance ) else : hits = self . robot . cast_ray ( p [ 0 ], p [ 1 ], - self . robot . a + PI_OVER_2 - self . a , self . max , ) if hits : if self . robot . world . debug and draw_list is not None : draw_list . append (( \"draw_ellipse\" , ( hits [ - 1 ] . x , hits [ - 1 ] . y , 2 , 2 ), {})) # Closest hit: if hits [ - 1 ] . distance < self . get_distance (): self . set_distance ( hits [ - 1 ] . distance )","title":"update()"},{"location":"rangesensor/#aitk.robots.devices.rangesensors.RangeSensor.watch","text":"Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Range Sensor:' Source code in robots/devices/rangesensors.py def watch ( self , title = \"Range Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"watch()"},{"location":"robot/","text":"Robot \u00b6 The Robot class is the base class for all robots. Typically, you would use an existing robot subclass: from aitk.robots import Scribbler , Vehicle robot1 = Scribbler () robot2 = Vehicle () After creating a robot, you can then add devices to it, and then add it to a world. from aitk.robots import World , Camera world = World ( 200 , 200 ) robot1 . add_device ( Camera ()) world . add_robot ( robot1 ) world . add_robot ( robot2 ) __init__ ( self , x = 0 , y = 0 , a = 0 , color = 'red' , name = 'Robbie' , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ) special \u00b6 A simulated robot. Option Type Description Default x int starting location in the horizontal direction. Leave 0 to place in a random location. 0 y int starting location in the horizontal direction. Leave 0 to place in a random location. 0 a float starting angle in degrees. 0 color str the name of a color for the robot \"red\" name str a name to give your robot \"Robbie\" do_trace bool should the robot leave a trace? True height int height of robot use number < 1 0.25 max_trace_length int max length of trace, in seconds 10 state dict serializable memory for a robot None va float angle velocity None vx float x velocity None vy float y velocity None tva float angle target velocity None tvx float x target velocity None tvy float y target velocity None va_max float angle max velocity None vx_max float x max velocity None vy_max float y max velocity None va_ramp float angle linear acceleration None vx_ramp float x linear acceleration None vy_ramp float y linear acceleration None image_data dataset-name, index to use a 3D set of images None body List data structure that defines a robot body None devices List list of serialized devices None Source code in robots/robot.py def __init__ ( self , x = 0 , y = 0 , a = 0 , color = \"red\" , name = \"Robbie\" , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ): \"\"\" A simulated robot. Option | Type | Description | Default ------ | ---- | ----------- | ------- x | int | starting location in the horizontal direction. Leave 0 to place in a random location. | 0 y | int | starting location in the horizontal direction. Leave 0 to place in a random location. | 0 a | float | starting angle in degrees. | 0 color | str | the name of a color for the robot | \"red\" name | str | a name to give your robot | \"Robbie\" do_trace | bool | should the robot leave a trace? | True height | int | height of robot use number < 1 | 0.25 max_trace_length | int | max length of trace, in seconds | 10 state | dict | serializable memory for a robot | None va | float | angle velocity | None vx | float | x velocity | None vy | float | y velocity | None tva | float | angle target velocity | None tvx | float | x target velocity | None tvy | float | y target velocity | None va_max | float | angle max velocity | None vx_max | float | x max velocity | None vy_max | float | y max velocity | None va_ramp | float | angle linear acceleration | None vx_ramp | float | x linear acceleration | None vy_ramp | float | y linear acceleration | None image_data | dataset-name, index | to use a 3D set of images | None body | List | data structure that defines a robot body | None devices | List | list of serialized devices | None \"\"\" # Get the args: config = { \"x\" : x , \"y\" : y , \"a\" : a , # degrees in the config file \"color\" : color , \"name\" : name , \"do_trace\" : do_trace , \"height\" : height , \"max_trace_length\" : max_trace_length , } # Update from the kwargs: config . update ( kwargs ) self . world = None self . _devices = [] self . _initialize () self . from_json ( config ) add_device ( self , device ) \u00b6 Add a device to a robot. Parameters: Name Type Description Default device Device the device to add required Source code in robots/robot.py def add_device ( self , device ): \"\"\" Add a device to a robot. Args: device (Device): the device to add \"\"\" if device not in self . _devices : device . robot = self self . _devices . append ( device ) if self . world is not None : self . world . update () # request draw else : raise Exception ( \"Can't add the same device to a robot more than once.\" ) add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ) \u00b6 Adds a ring of devices at a given distance from the center of the robot. Parameters: Name Type Description Default device_class class a class or function that receives position, a, and kwargs, and returns a device required distance_from_center float in CM required start_degree float angle of first device (0 points right) required stop_degree float angle of stop degree (counter clockwise) required count int number of sensors to add required Examples: >>> robot . add_device_ring ( RangeSensor , 10 , 0 , 360 , 6 , width = 20 ) Source code in robots/robot.py def add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ): \"\"\" Adds a ring of devices at a given distance from the center of the robot. Args: device_class (class): a class or function that receives position, a, and kwargs, and returns a device distance_from_center (float): in CM start_degree (float): angle of first device (0 points right) stop_degree (float): angle of stop degree (counter clockwise) count (int): number of sensors to add Note: use kwargs additional args to pass to device_class Example: ```python >>> robot.add_device_ring(RangeSensor, 10, 0, 360, 6, width=20) ``` \"\"\" span = stop_degree - start_degree step_angle = span / count for angle in arange ( start_degree , stop_degree , step_angle ): x , y = rotate_around ( 0 , 0 , distance_from_center , - angle * PI_OVER_180 ) self . add_device ( device_class ( position = ( x , y ), a = angle , ** kwargs )) backward ( self , translate ) \u00b6 Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot backward required Translate should be between 0 and 1, inclusive. Source code in robots/robot.py def backward ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot backward Translate should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( - translate * self . vx_max , 1 ) else : print ( \"backward value is out of range; should be between 0 and 1, inclusive\" ) cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ) \u00b6 Cast a ray into this world and see what it hits. Parameters: Name Type Description Default x1 int the x coordinate of ray origin required y1 int the y coordinate of ray origin required a int the angle of the ray to cast required maxRange float the length of ray to cast required x2 int the x coordinate of the endpoint None y2 int the y coordinate of the endpoint None ignore_robots List list of robots to ignore None Returns list of hits, furthest away first (back to front) Source code in robots/robot.py def cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ): \"\"\" Cast a ray into this world and see what it hits. Args: x1 (int): the x coordinate of ray origin y1 (int): the y coordinate of ray origin a (int): the angle of the ray to cast maxRange (float): the length of ray to cast x2 (int): the x coordinate of the endpoint y2 (int): the y coordinate of the endpoint ignore_robots (List): list of robots to ignore Returns list of hits, furthest away first (back to front) \"\"\" return cast_ray ( self . world , self , x1 , y1 , a , maxRange , x2 , y2 , ignore_robots ) del_device ( self , device ) \u00b6 Remove a device from a robot. Parameters: Name Type Description Default device Device the device to remove required Source code in robots/robot.py def del_device ( self , device ): \"\"\" Remove a device from a robot. Args: device (Device): the device to remove \"\"\" if isinstance ( device , ( str , int )): device = self [ device ] if device in self . _devices : device . robot = None self . _devices . remove ( device ) else : raise Exception ( \"Device %r is not on robot.\" % device ) display ( self , size = 100 ) \u00b6 Display the robot's image. Parameters: Name Type Description Default size int the size of the width and height of the image 100 Source code in robots/robot.py def display ( self , size = 100 ): \"\"\" Display the robot's image. Args: size (int): the size of the width and height of the image \"\"\" image = self . get_image ( size = size ) display ( image ) draw ( self , backend ) \u00b6 Draw the robot. Parameters: Name Type Description Default backend Backend the backend on which to draw required Source code in robots/robot.py def draw ( self , backend ): \"\"\" Draw the robot. Args: backend (Backend): the backend on which to draw \"\"\" if self . do_trace : time_step = self . world . time_step if self . world is not None else 0.1 if self . max_trace_length > 0 : max_trace_length = int ( 1.0 / time_step * self . max_trace_length ) else : max_trace_length = 0 if max_trace_length == 0 : data = [] else : data = self . trace [ - max_trace_length :] # None indicates a segment break if all ( data ): # no segments segments = [[( point [ 0 ], point [ 1 ]) for ( point , direction ) in data ]] else : segments = [] current = [] for item in data : if item is None : segments . append ( current ) current = [] else : point , direction = item current . append (( point [ 0 ], point [ 1 ])) if current : segments . append ( current ) for segment in segments : backend . draw_lines ( segment , stroke_style = self . trace_color , ) self . trace = data backend . pushMatrix () backend . translate ( self . x , self . y ) backend . rotate ( self . a ) # Draw first: for device in self . _devices : if device . type == \"bulb\" : device . draw ( backend ) # body: for shape in self . body : shape_name , color , args = shape if self . stalled : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) if color is None : backend . set_fill ( self . color ) else : backend . set_fill ( Color ( color )) if shape_name == \"polygon\" : backend . draw_polygon ( args ) elif shape_name == \"rectangle\" : backend . draw_rect ( * args ) elif shape_name == \"ellipse\" : backend . draw_ellipse ( * args ) elif shape_name == \"circle\" : backend . draw_circle ( * args ) elif shape_name == \"line\" : backend . draw_line ( * args ) backend . noStroke () # Draw on top of robot: for device in self . _devices : if device . type != \"bulb\" : device . draw ( backend ) backend . popMatrix () text = self . _get_current_text ( self . world . time ) if text : backend . set_fill_style ( Color ( 255 )) pad = 10 box_pad = 5 width = self . world . _backend . char_width * len ( text ) height = 20 if self . x - pad - width < 0 : side = 1 # put on right else : side = - 1 # put on left if self . y - height < 0 : half = 1 # put on top else : half = - 1 # put on bottom points = [ ( self . x , self . y ), ( self . x + pad * side , self . y + height / 2 * half ), ( self . x + pad * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y ), ( self . x + pad * side , self . y ), ( self . x + pad * side , self . y + height / 4 * half ), ] backend . set_stroke_style ( Color ( 0 )) backend . set_fill_style ( Color ( 255 , 255 , 255 , 200 )) backend . draw_polygon ( points ) backend . set_fill_style ( Color ( 0 )) if side == 1 : # right if half == 1 : # bottom backend . text ( text , self . x + ( pad + box_pad ), self . y + box_pad ) else : # top backend . text ( text , self . x + ( pad + box_pad ), self . y - self . world . _backend . char_height - box_pad , ) else : # left if half == 1 : # bottom backend . text ( text , self . x - pad - width - box_pad , self . y + box_pad ) else : # top backend . text ( text , self . x - pad - width - box_pad , self . y - self . world . _backend . char_height - box_pad , ) eat ( self ) \u00b6 If the robot is close enough to food, then this will eat it, removing it from the world, and requesting a redraw. Returns True if successfully eaten, and False otherwise. Note: it must be within robot.eat_food_distance Source code in robots/robot.py def eat ( self ): \"\"\" If the robot is close enough to food, then this will eat it, removing it from the world, and requesting a redraw. Returns True if successfully eaten, and False otherwise. Note: it must be within robot.eat_food_distance \"\"\" success = False if self . world is not None : for food in self . world . _food [:]: # copy if distance ( self . x , self . y , food [ 0 ], food [ 1 ]) <= self . eat_food_distance : self . food_eaten += 1 success = True self . world . _food . remove ( food ) self . world . _grid . need_update = True self . world . update () # request draw return success forward ( self , translate ) \u00b6 Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot forward required Arg should be between 0 and 1, inclusive. Source code in robots/robot.py def forward ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot forward Arg should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( translate * self . vx_max , 1 ) else : print ( \"forward value is out of range; should be between 0 and 1, inclusive\" ) from_json ( self , config ) \u00b6 Load a robot from a JSON config dict. Parameters: Name Type Description Default config dict a config dict required Source code in robots/robot.py def from_json ( self , config ): \"\"\" Load a robot from a JSON config dict. Args: config (dict): a config dict \"\"\" DEVICES = importlib . import_module ( \"aitk.robots.devices\" ) valid_keys = set ([ \"name\" , \"state\" , \"do_trace\" , \"va\" , \"vx\" , \"vy\" , \"tva\" , \"tvx\" , \"tvy\" , \"x\" , \"y\" , \"a\" , \"va_max\" , \"vx_max\" , \"vy_max\" , \"va_ramp\" , \"vx_ramp\" , \"vy_ramp\" , \"image_data\" , \"height\" , \"color\" , \"max_trace_length\" , \"body\" , \"devices\" , ]) config_keys = set ( list ( config . keys ())) extra_keys = config_keys - valid_keys if len ( extra_keys ) > 0 : raise TypeError ( \"invalid key(s) for robot config: %r \" % extra_keys ) if \"name\" in config : self . name = config [ \"name\" ] if \"state\" in config : self . state = defaultdict ( int ) self . state . update ( config [ \"state\" ]) if \"do_trace\" in config : self . do_trace = config [ \"do_trace\" ] if \"va\" in config : self . va = config [ \"va\" ] if \"vx\" in config : self . vx = config [ \"vx\" ] if \"vy\" in config : self . vy = config [ \"vy\" ] if \"tva\" in config : self . tva = config [ \"tva\" ] if \"tvx\" in config : self . tvx = config [ \"tvx\" ] if \"tvy\" in config : self . tvy = config [ \"tvy\" ] if \"va_max\" in config : self . va_max = config [ \"va_max\" ] if \"vx_max\" in config : self . vx_max = config [ \"vx_max\" ] if \"vy_max\" in config : self . vy_max = config [ \"vy_max\" ] if \"va_ramp\" in config : self . va_ramp = config [ \"va_ramp\" ] if \"vx_ramp\" in config : self . vx_ramp = config [ \"vx_ramp\" ] if \"vy_ramp\" in config : self . vy_ramp = config [ \"vy_ramp\" ] if \"x\" in config : self . x = config [ \"x\" ] if \"y\" in config : self . y = config [ \"y\" ] if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"image_data\" in config : self . image_data = config [ \"image_data\" ] # [\"dataset\", index] if len ( self . image_data ) == 0 : self . get_dataset_image = None else : self . get_dataset_image = get_dataset ( self . image_data [ 0 ]) if \"height\" in config : self . height = config [ \"height\" ] # ratio, 0 to 1 of height if \"color\" in config : self . _set_color ( config [ \"color\" ]) if \"max_trace_length\" in config : self . max_trace_length = config [ \"max_trace_length\" ] if \"body\" in config : self . body [:] = config [ \"body\" ] self . _init_boundingbox () if \"devices\" in config : # FIXME: raise if lengths/types don't match for i , deviceConfig in enumerate ( config [ \"devices\" ]): if i < len ( self ): if self [ i ] . __class__ . __name__ == deviceConfig [ \"class\" ]: # already a device, let's reuse it: device = self [ i ] device . initialize () device . from_json ( deviceConfig ) else : raise Exception ( \"can't use reset; config changed; use load_world\" ) else : device = None try : device_class = getattr ( DEVICES , deviceConfig [ \"class\" ]) device = device_class ( ** deviceConfig ) except Exception : raise Exception ( \"Failed to create device: %s (** %s )\" % ( deviceConfig [ \"class\" ], deviceConfig ) ) if device : self . add_device ( device ) get_image ( self , size = 100 ) \u00b6 Get an image of the robot. Parameters: Name Type Description Default size int size in pixels around robot 100 Source code in robots/robot.py def get_image ( self , size = 100 ): \"\"\" Get an image of the robot. Args: size (int): size in pixels around robot \"\"\" picture = self . world . get_image () start_x = round ( max ( self . x * self . world . scale - size / 2 , 0 ) ) start_y = round ( max ( self . y * self . world . scale - size / 2 , 0 ) ) rectangle = ( start_x , start_y , min ( start_x + size , self . world . width * self . world . scale ), min ( start_y + size , self . world . height * self . world . scale , ), ) picture = picture . crop ( rectangle ) return picture get_image_3d ( self , degrees ) \u00b6 Return the 3D image at the proper angle. Parameters: Name Type Description Default degrees int the angle of the image to get required Source code in robots/robot.py def get_image_3d ( self , degrees ): \"\"\" Return the 3D image at the proper angle. Args: degrees (int): the angle of the image to get \"\"\" return self . get_dataset_image ( self . image_data [ 1 ], degrees ) get_max_trace_length ( self ) \u00b6 Get the max length of the trace in seconds. Source code in robots/robot.py def get_max_trace_length ( self ): \"\"\" Get the max length of the trace in seconds. \"\"\" return self . max_trace_length get_pose ( self ) \u00b6 Get the pose of the robot (x, y, a) where a (direction) is in degrees. Source code in robots/robot.py def get_pose ( self ): \"\"\" Get the pose of the robot (x, y, a) where a (direction) is in degrees. \"\"\" return ( self . x , self . y , world_to_degrees ( self . a )) get_time ( self ) \u00b6 Get the clock time of the world. Source code in robots/robot.py def get_time ( self ): \"\"\" Get the clock time of the world. \"\"\" if self . world : return self . world . time get_velocity ( self , target = False ) \u00b6 Get the current (or target) translate and rotate velocities of the robot. Parameters: Name Type Description Default target bool get the target velocities if True; get the actual velocities otherwise False Source code in robots/robot.py def get_velocity ( self , target = False ): \"\"\" Get the current (or target) translate and rotate velocities of the robot. Args: target (bool): get the target velocities if True; get the actual velocities otherwise \"\"\" if not target : return ( self . vx / self . vx_max , self . va / self . va_max ) else : return ( self . tvx / self . vx_max , self . tva / self . va_max ) get_widget ( self , size = None , show_robot = None , attributes = None ) \u00b6 Get the robot widget. Parameters: Name Type Description Default size int size in pixels around robot None show_robot bool show picture of robot None attributes list items to include, or \"all\" None Source code in robots/robot.py def get_widget ( self , size = None , show_robot = None , attributes = None ): \"\"\" Get the robot widget. Args: size (int): size in pixels around robot show_robot (bool): show picture of robot attributes (list): items to include, or \"all\" \"\"\" from .watchers import RobotWatcher if self . _watcher is None : size = size if size is not None else 100 show_robot = show_robot if show_robot is not None else True attributes = attributes if attributes is not None else \"all\" self . _watcher = RobotWatcher ( self , size = size , show_robot = show_robot , attributes = attributes ) self . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( size = size , show_robot = show_robot , attributes = attributes ) self . _watcher . draw () return self . _watcher . get_widget () has_image ( self ) \u00b6 Does this robot have an associated 3D set of images from a dataset? Source code in robots/robot.py def has_image ( self ): \"\"\" Does this robot have an associated 3D set of images from a dataset? \"\"\" return self . get_dataset_image is not None motors ( self , left , right ) \u00b6 A move function that takes desired motor values and converts to trans and rotate. Parameters: Name Type Description Default left float the speed to move the left wheel required right float the speed to move the right wheel required Source code in robots/robot.py def motors ( self , left , right ): \"\"\" A move function that takes desired motor values and converts to trans and rotate. Args: left (float): the speed to move the left wheel right (float): the speed to move the right wheel \"\"\" trans = ( right + left ) / 2.0 rotate = ( right - left ) / 2.0 self . move ( trans , rotate ) move ( self , translate , rotate ) \u00b6 Set the target translate and rotate velocities. Parameters: Name Type Description Default translate float the speed to move the robot forward/backward required rotate float the speed to rotate the robot left/right required Args should be between -1 and 1. Source code in robots/robot.py def move ( self , translate , rotate ): \"\"\" Set the target translate and rotate velocities. Args: translate (float): the speed to move the robot forward/backward rotate (float): the speed to rotate the robot left/right Args should be between -1 and 1. \"\"\" # values between -1 and 1 # compute target velocities if self . world is not None : if self . world . status != \"running\" : print_once ( \"This world is not running\" ) if translate is not None : self . tvx = round ( translate * self . vx_max , 1 ) if rotate is not None : self . tva = round ( rotate * self . va_max , 1 ) pen_down ( self , color = None , radius = 1 ) \u00b6 Put the pen down to change the color of the background image. Parameters: Name Type Description Default color str the pen color to draw None radius int the size of the dot to draw 1 Source code in robots/robot.py def pen_down ( self , color = None , radius = 1 ): \"\"\" Put the pen down to change the color of the background image. Args: color (str): the pen color to draw radius (int): the size of the dot to draw Note: not for use in a robot in a recorder. \"\"\" from PIL import Image color = color if color is not None else self . color self . pen = ( Color ( color ), radius ) if self . world is not None : if self . world . _ground_image is None : image = Image . new ( \"RGBA\" , ( self . world . width , self . world . height ), color = \"white\" ) filename = \"ground_image.png\" image . save ( filename ) self . world . set_ground_image ( filename ) pen_up ( self ) \u00b6 Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_up ( self ): \"\"\" Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. \"\"\" self . pen = ( None , 0 ) reset ( self ) \u00b6 Reset the robot's internal stuff. Typically, called from the world. Source code in robots/robot.py def reset ( self ): \"\"\" Reset the robot's internal stuff. Typically, called from the world. \"\"\" self . trace [:] = [] self . text_trace [:] = [] self . pen_trace [:] = [] reverse ( self ) \u00b6 Flip the target x and a velocities from negative to positive or from positive to negative. Source code in robots/robot.py def reverse ( self ): \"\"\" Flip the target x and a velocities from negative to positive or from positive to negative. \"\"\" self . tvx = - self . tvx self . tva = - self . tva rotate ( self , rotate ) \u00b6 Set the target rotate velocity. Parameters: Name Type Description Default rotate float the speed to rotate the robot required Arg should be between -1 and 1. Source code in robots/robot.py def rotate ( self , rotate ): \"\"\" Set the target rotate velocity. Args: rotate (float): the speed to rotate the robot Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tva = rotate * self . va_max set_color ( self , color ) \u00b6 Set the color of a robot, and its trace. Parameters: Name Type Description Default color str the color of the robot required Source code in robots/robot.py def set_color ( self , color ): \"\"\" Set the color of a robot, and its trace. Args: color (str): the color of the robot \"\"\" self . _set_color ( color ) set_max_trace_length ( self , seconds ) \u00b6 Set the max length of trace, in seconds. Parameters: Name Type Description Default seconds float the length of trace in seconds required Source code in robots/robot.py def set_max_trace_length ( self , seconds ): \"\"\" Set the max length of trace, in seconds. Args: seconds (float): the length of trace in seconds \"\"\" self . max_trace_length = seconds set_pose ( self , x = None , y = None , a = None , clear_trace = True ) \u00b6 Set the pose of the robot. a is in degrees. Parameters: Name Type Description Default x int the x coordinate of the robot None y int the y coordinate of the robot None a int the angle of the robot in degrees (zero is to the left, 90 is up) None clear_trace bool if True, clear the robot's trace True Source code in robots/robot.py def set_pose ( self , x = None , y = None , a = None , clear_trace = True ): \"\"\" Set the pose of the robot. a is in degrees. Args: x (int): the x coordinate of the robot y (int): the y coordinate of the robot a (int): the angle of the robot in degrees (zero is to the left, 90 is up) clear_trace (bool): if True, clear the robot's trace Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add to world before setting pose\" ) else : if a is not None : a = degrees_to_world ( a ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save () set_random_pose ( self , clear_trace = True ) \u00b6 Set the pose of the robot to a random open location in the world. Parameters: Name Type Description Default clear_trace bool if True, clear the trace True Source code in robots/robot.py def set_random_pose ( self , clear_trace = True ): \"\"\" Set the pose of the robot to a random open location in the world. Args: clear_trace (bool): if True, clear the trace Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add robot to world before calling set_random_pose\" ) else : # Direction is in radians, in world coordinates: x , y , a = self . world . _find_random_pose ( self ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save () speak ( self , text = None ) \u00b6 Show some text in the robot's speech bubble. Parameters: Name Type Description Default text str the text to show; use None to clear None Source code in robots/robot.py def speak ( self , text = None ): \"\"\" Show some text in the robot's speech bubble. Args: text (str): the text to show; use None to clear Note: not for use in a robot in a recorder. \"\"\" if self . world : if self . world . _recording : if len ( self . text_trace ) > 0 : # If same as last, don't add again if self . text_trace [ - 1 ][ 1 ] != text : self . text_trace . append (( self . world . time , text )) else : self . text_trace . append (( self . world . time , text )) else : self . text_trace [:] = [( self . world . time , text )] stop ( self ) \u00b6 Set the target velocities to zeros. Source code in robots/robot.py def stop ( self ): \"\"\" Set the target velocities to zeros. \"\"\" self . tvx = 0.0 self . tvy = 0.0 self . tva = 0.0 summary ( self ) \u00b6 Prints a summary of information about the robot. Source code in robots/robot.py def summary ( self ): \"\"\" Prints a summary of information about the robot. \"\"\" if len ( self . _devices ) == 0 : print ( \" This robot has no devices.\" ) else : for i , device in enumerate ( self . _devices ): print ( \" robot[ %s or %r or %r ]: %r \" % ( i , device . type , device . name , device ) ) print ( \" \" + ( \"-\" * 25 )) to_json ( self ) \u00b6 Get this robot as a JSON config file. Source code in robots/robot.py def to_json ( self ): \"\"\" Get this robot as a JSON config file. \"\"\" robot_json = { \"name\" : self . name , \"state\" : self . state , \"va\" : self . va , \"vx\" : self . vx , \"vy\" : self . vy , \"tva\" : self . tva , \"tvx\" : self . tvx , \"tvy\" : self . tvy , \"va_max\" : self . va_max , \"vx_max\" : self . vx_max , \"vy_max\" : self . vy_max , \"va_ramp\" : self . va_ramp , \"vx_ramp\" : self . vx_ramp , \"vy_ramp\" : self . vy_ramp , \"x\" : self . x , \"y\" : self . y , \"a\" : world_to_degrees ( self . a ), \"image_data\" : self . image_data , \"height\" : self . height , \"color\" : str ( self . color ), \"max_trace_length\" : self . max_trace_length , \"body\" : self . body , \"devices\" : [ device . to_json () for device in self . _devices ], \"do_trace\" : self . do_trace , } return robot_json translate ( self , translate ) \u00b6 Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot forward/backward required Arg should be between -1 and 1. Source code in robots/robot.py def translate ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot forward/backward Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tvx = round ( translate * self . vx_max , 1 ) update ( self , draw_list = None ) \u00b6 Update the robot, and devices. Parameters: Name Type Description Default draw_list List list of items to draw None Source code in robots/robot.py def update ( self , draw_list = None ): \"\"\" Update the robot, and devices. Args: draw_list (List): list of items to draw \"\"\" # Wrapped worlds: wrapped = False if self . x < 0 : self . x = self . world . width wrapped = True elif self . x > self . world . width : self . x = 0 wrapped = True if self . y < 0 : self . y = self . world . height wrapped = True elif self . y > self . world . height : self . y = 0 wrapped = True if wrapped : self . trace . append ( None ) self . _init_boundingbox () if self . world . debug and draw_list is not None : draw_list . append (( \"strokeStyle\" , ( Color ( 255 ), 1 ))) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 0 ] . p1 . x , self . _bounding_lines [ 0 ] . p1 . y , self . _bounding_lines [ 0 ] . p2 . x , self . _bounding_lines [ 0 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 1 ] . p1 . x , self . _bounding_lines [ 1 ] . p1 . y , self . _bounding_lines [ 1 ] . p2 . x , self . _bounding_lines [ 1 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 2 ] . p1 . x , self . _bounding_lines [ 2 ] . p1 . y , self . _bounding_lines [ 2 ] . p2 . x , self . _bounding_lines [ 2 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 3 ] . p1 . x , self . _bounding_lines [ 3 ] . p1 . y , self . _bounding_lines [ 3 ] . p2 . x , self . _bounding_lines [ 3 ] . p2 . y , ), ) ) # Devices: for device in self . _devices : device . update ( draw_list ) # Update recording info: if self . world . _recording : if len ( self . pen_trace ) > 0 : # color of pen: if self . pen_trace [ - 1 ][ 1 ][ 0 ] != self . pen [ 0 ]: self . pen_trace . append (( self . world . time , self . pen )) # same pen color, do nothing elif self . pen != ( None , 0 ): self . pen_trace . append (( self . world . time , self . pen )) # else do nothing else : # not recording if self . pen == ( None , 0 ): self . pen_trace [:] = [] else : self . pen_trace [:] = [( self . world . time , self . pen )] # Alter world: self . _update_ground_image ( self . world . time ) return watch ( self , size = None , show_robot = None , attributes = None ) \u00b6 Watch the robot stats with live updates. Parameters: Name Type Description Default size int size in pixels around robot None show_robot bool show picture of robot None attributes List items to include, or \"all\" None Source code in robots/robot.py def watch ( self , size = None , show_robot = None , attributes = None ): \"\"\" Watch the robot stats with live updates. Args: size (int): size in pixels around robot show_robot (bool): show picture of robot attributes (List): items to include, or \"all\" \"\"\" widget = self . get_widget ( size = size , show_robot = show_robot , attributes = attributes , ) display ( widget )","title":"Robot"},{"location":"robot/#robot","text":"The Robot class is the base class for all robots. Typically, you would use an existing robot subclass: from aitk.robots import Scribbler , Vehicle robot1 = Scribbler () robot2 = Vehicle () After creating a robot, you can then add devices to it, and then add it to a world. from aitk.robots import World , Camera world = World ( 200 , 200 ) robot1 . add_device ( Camera ()) world . add_robot ( robot1 ) world . add_robot ( robot2 )","title":"Robot"},{"location":"robot/#aitk.robots.robot.Robot.__init__","text":"A simulated robot. Option Type Description Default x int starting location in the horizontal direction. Leave 0 to place in a random location. 0 y int starting location in the horizontal direction. Leave 0 to place in a random location. 0 a float starting angle in degrees. 0 color str the name of a color for the robot \"red\" name str a name to give your robot \"Robbie\" do_trace bool should the robot leave a trace? True height int height of robot use number < 1 0.25 max_trace_length int max length of trace, in seconds 10 state dict serializable memory for a robot None va float angle velocity None vx float x velocity None vy float y velocity None tva float angle target velocity None tvx float x target velocity None tvy float y target velocity None va_max float angle max velocity None vx_max float x max velocity None vy_max float y max velocity None va_ramp float angle linear acceleration None vx_ramp float x linear acceleration None vy_ramp float y linear acceleration None image_data dataset-name, index to use a 3D set of images None body List data structure that defines a robot body None devices List list of serialized devices None Source code in robots/robot.py def __init__ ( self , x = 0 , y = 0 , a = 0 , color = \"red\" , name = \"Robbie\" , do_trace = True , height = 0.25 , max_trace_length = 10 , ** kwargs ): \"\"\" A simulated robot. Option | Type | Description | Default ------ | ---- | ----------- | ------- x | int | starting location in the horizontal direction. Leave 0 to place in a random location. | 0 y | int | starting location in the horizontal direction. Leave 0 to place in a random location. | 0 a | float | starting angle in degrees. | 0 color | str | the name of a color for the robot | \"red\" name | str | a name to give your robot | \"Robbie\" do_trace | bool | should the robot leave a trace? | True height | int | height of robot use number < 1 | 0.25 max_trace_length | int | max length of trace, in seconds | 10 state | dict | serializable memory for a robot | None va | float | angle velocity | None vx | float | x velocity | None vy | float | y velocity | None tva | float | angle target velocity | None tvx | float | x target velocity | None tvy | float | y target velocity | None va_max | float | angle max velocity | None vx_max | float | x max velocity | None vy_max | float | y max velocity | None va_ramp | float | angle linear acceleration | None vx_ramp | float | x linear acceleration | None vy_ramp | float | y linear acceleration | None image_data | dataset-name, index | to use a 3D set of images | None body | List | data structure that defines a robot body | None devices | List | list of serialized devices | None \"\"\" # Get the args: config = { \"x\" : x , \"y\" : y , \"a\" : a , # degrees in the config file \"color\" : color , \"name\" : name , \"do_trace\" : do_trace , \"height\" : height , \"max_trace_length\" : max_trace_length , } # Update from the kwargs: config . update ( kwargs ) self . world = None self . _devices = [] self . _initialize () self . from_json ( config )","title":"__init__()"},{"location":"robot/#aitk.robots.robot.Robot.add_device","text":"Add a device to a robot. Parameters: Name Type Description Default device Device the device to add required Source code in robots/robot.py def add_device ( self , device ): \"\"\" Add a device to a robot. Args: device (Device): the device to add \"\"\" if device not in self . _devices : device . robot = self self . _devices . append ( device ) if self . world is not None : self . world . update () # request draw else : raise Exception ( \"Can't add the same device to a robot more than once.\" )","title":"add_device()"},{"location":"robot/#aitk.robots.robot.Robot.add_device_ring","text":"Adds a ring of devices at a given distance from the center of the robot. Parameters: Name Type Description Default device_class class a class or function that receives position, a, and kwargs, and returns a device required distance_from_center float in CM required start_degree float angle of first device (0 points right) required stop_degree float angle of stop degree (counter clockwise) required count int number of sensors to add required Examples: >>> robot . add_device_ring ( RangeSensor , 10 , 0 , 360 , 6 , width = 20 ) Source code in robots/robot.py def add_device_ring ( self , device_class , distance_from_center , start_degree , stop_degree , count , ** kwargs ): \"\"\" Adds a ring of devices at a given distance from the center of the robot. Args: device_class (class): a class or function that receives position, a, and kwargs, and returns a device distance_from_center (float): in CM start_degree (float): angle of first device (0 points right) stop_degree (float): angle of stop degree (counter clockwise) count (int): number of sensors to add Note: use kwargs additional args to pass to device_class Example: ```python >>> robot.add_device_ring(RangeSensor, 10, 0, 360, 6, width=20) ``` \"\"\" span = stop_degree - start_degree step_angle = span / count for angle in arange ( start_degree , stop_degree , step_angle ): x , y = rotate_around ( 0 , 0 , distance_from_center , - angle * PI_OVER_180 ) self . add_device ( device_class ( position = ( x , y ), a = angle , ** kwargs ))","title":"add_device_ring()"},{"location":"robot/#aitk.robots.robot.Robot.backward","text":"Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot backward required Translate should be between 0 and 1, inclusive. Source code in robots/robot.py def backward ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot backward Translate should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( - translate * self . vx_max , 1 ) else : print ( \"backward value is out of range; should be between 0 and 1, inclusive\" )","title":"backward()"},{"location":"robot/#aitk.robots.robot.Robot.cast_ray","text":"Cast a ray into this world and see what it hits. Parameters: Name Type Description Default x1 int the x coordinate of ray origin required y1 int the y coordinate of ray origin required a int the angle of the ray to cast required maxRange float the length of ray to cast required x2 int the x coordinate of the endpoint None y2 int the y coordinate of the endpoint None ignore_robots List list of robots to ignore None Returns list of hits, furthest away first (back to front) Source code in robots/robot.py def cast_ray ( self , x1 , y1 , a , maxRange , x2 = None , y2 = None , ignore_robots = None ): \"\"\" Cast a ray into this world and see what it hits. Args: x1 (int): the x coordinate of ray origin y1 (int): the y coordinate of ray origin a (int): the angle of the ray to cast maxRange (float): the length of ray to cast x2 (int): the x coordinate of the endpoint y2 (int): the y coordinate of the endpoint ignore_robots (List): list of robots to ignore Returns list of hits, furthest away first (back to front) \"\"\" return cast_ray ( self . world , self , x1 , y1 , a , maxRange , x2 , y2 , ignore_robots )","title":"cast_ray()"},{"location":"robot/#aitk.robots.robot.Robot.del_device","text":"Remove a device from a robot. Parameters: Name Type Description Default device Device the device to remove required Source code in robots/robot.py def del_device ( self , device ): \"\"\" Remove a device from a robot. Args: device (Device): the device to remove \"\"\" if isinstance ( device , ( str , int )): device = self [ device ] if device in self . _devices : device . robot = None self . _devices . remove ( device ) else : raise Exception ( \"Device %r is not on robot.\" % device )","title":"del_device()"},{"location":"robot/#aitk.robots.robot.Robot.display","text":"Display the robot's image. Parameters: Name Type Description Default size int the size of the width and height of the image 100 Source code in robots/robot.py def display ( self , size = 100 ): \"\"\" Display the robot's image. Args: size (int): the size of the width and height of the image \"\"\" image = self . get_image ( size = size ) display ( image )","title":"display()"},{"location":"robot/#aitk.robots.robot.Robot.draw","text":"Draw the robot. Parameters: Name Type Description Default backend Backend the backend on which to draw required Source code in robots/robot.py def draw ( self , backend ): \"\"\" Draw the robot. Args: backend (Backend): the backend on which to draw \"\"\" if self . do_trace : time_step = self . world . time_step if self . world is not None else 0.1 if self . max_trace_length > 0 : max_trace_length = int ( 1.0 / time_step * self . max_trace_length ) else : max_trace_length = 0 if max_trace_length == 0 : data = [] else : data = self . trace [ - max_trace_length :] # None indicates a segment break if all ( data ): # no segments segments = [[( point [ 0 ], point [ 1 ]) for ( point , direction ) in data ]] else : segments = [] current = [] for item in data : if item is None : segments . append ( current ) current = [] else : point , direction = item current . append (( point [ 0 ], point [ 1 ])) if current : segments . append ( current ) for segment in segments : backend . draw_lines ( segment , stroke_style = self . trace_color , ) self . trace = data backend . pushMatrix () backend . translate ( self . x , self . y ) backend . rotate ( self . a ) # Draw first: for device in self . _devices : if device . type == \"bulb\" : device . draw ( backend ) # body: for shape in self . body : shape_name , color , args = shape if self . stalled : backend . strokeStyle ( Color ( 255 ), 1 ) else : backend . strokeStyle ( Color ( 0 ), 1 ) if color is None : backend . set_fill ( self . color ) else : backend . set_fill ( Color ( color )) if shape_name == \"polygon\" : backend . draw_polygon ( args ) elif shape_name == \"rectangle\" : backend . draw_rect ( * args ) elif shape_name == \"ellipse\" : backend . draw_ellipse ( * args ) elif shape_name == \"circle\" : backend . draw_circle ( * args ) elif shape_name == \"line\" : backend . draw_line ( * args ) backend . noStroke () # Draw on top of robot: for device in self . _devices : if device . type != \"bulb\" : device . draw ( backend ) backend . popMatrix () text = self . _get_current_text ( self . world . time ) if text : backend . set_fill_style ( Color ( 255 )) pad = 10 box_pad = 5 width = self . world . _backend . char_width * len ( text ) height = 20 if self . x - pad - width < 0 : side = 1 # put on right else : side = - 1 # put on left if self . y - height < 0 : half = 1 # put on top else : half = - 1 # put on bottom points = [ ( self . x , self . y ), ( self . x + pad * side , self . y + height / 2 * half ), ( self . x + pad * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y + height * half ), ( self . x + ( pad + width + pad ) * side , self . y ), ( self . x + pad * side , self . y ), ( self . x + pad * side , self . y + height / 4 * half ), ] backend . set_stroke_style ( Color ( 0 )) backend . set_fill_style ( Color ( 255 , 255 , 255 , 200 )) backend . draw_polygon ( points ) backend . set_fill_style ( Color ( 0 )) if side == 1 : # right if half == 1 : # bottom backend . text ( text , self . x + ( pad + box_pad ), self . y + box_pad ) else : # top backend . text ( text , self . x + ( pad + box_pad ), self . y - self . world . _backend . char_height - box_pad , ) else : # left if half == 1 : # bottom backend . text ( text , self . x - pad - width - box_pad , self . y + box_pad ) else : # top backend . text ( text , self . x - pad - width - box_pad , self . y - self . world . _backend . char_height - box_pad , )","title":"draw()"},{"location":"robot/#aitk.robots.robot.Robot.eat","text":"If the robot is close enough to food, then this will eat it, removing it from the world, and requesting a redraw. Returns True if successfully eaten, and False otherwise. Note: it must be within robot.eat_food_distance Source code in robots/robot.py def eat ( self ): \"\"\" If the robot is close enough to food, then this will eat it, removing it from the world, and requesting a redraw. Returns True if successfully eaten, and False otherwise. Note: it must be within robot.eat_food_distance \"\"\" success = False if self . world is not None : for food in self . world . _food [:]: # copy if distance ( self . x , self . y , food [ 0 ], food [ 1 ]) <= self . eat_food_distance : self . food_eaten += 1 success = True self . world . _food . remove ( food ) self . world . _grid . need_update = True self . world . update () # request draw return success","title":"eat()"},{"location":"robot/#aitk.robots.robot.Robot.forward","text":"Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot forward required Arg should be between 0 and 1, inclusive. Source code in robots/robot.py def forward ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot forward Arg should be between 0 and 1, inclusive. \"\"\" if 0 <= translate <= 1 : self . tvx = round ( translate * self . vx_max , 1 ) else : print ( \"forward value is out of range; should be between 0 and 1, inclusive\" )","title":"forward()"},{"location":"robot/#aitk.robots.robot.Robot.from_json","text":"Load a robot from a JSON config dict. Parameters: Name Type Description Default config dict a config dict required Source code in robots/robot.py def from_json ( self , config ): \"\"\" Load a robot from a JSON config dict. Args: config (dict): a config dict \"\"\" DEVICES = importlib . import_module ( \"aitk.robots.devices\" ) valid_keys = set ([ \"name\" , \"state\" , \"do_trace\" , \"va\" , \"vx\" , \"vy\" , \"tva\" , \"tvx\" , \"tvy\" , \"x\" , \"y\" , \"a\" , \"va_max\" , \"vx_max\" , \"vy_max\" , \"va_ramp\" , \"vx_ramp\" , \"vy_ramp\" , \"image_data\" , \"height\" , \"color\" , \"max_trace_length\" , \"body\" , \"devices\" , ]) config_keys = set ( list ( config . keys ())) extra_keys = config_keys - valid_keys if len ( extra_keys ) > 0 : raise TypeError ( \"invalid key(s) for robot config: %r \" % extra_keys ) if \"name\" in config : self . name = config [ \"name\" ] if \"state\" in config : self . state = defaultdict ( int ) self . state . update ( config [ \"state\" ]) if \"do_trace\" in config : self . do_trace = config [ \"do_trace\" ] if \"va\" in config : self . va = config [ \"va\" ] if \"vx\" in config : self . vx = config [ \"vx\" ] if \"vy\" in config : self . vy = config [ \"vy\" ] if \"tva\" in config : self . tva = config [ \"tva\" ] if \"tvx\" in config : self . tvx = config [ \"tvx\" ] if \"tvy\" in config : self . tvy = config [ \"tvy\" ] if \"va_max\" in config : self . va_max = config [ \"va_max\" ] if \"vx_max\" in config : self . vx_max = config [ \"vx_max\" ] if \"vy_max\" in config : self . vy_max = config [ \"vy_max\" ] if \"va_ramp\" in config : self . va_ramp = config [ \"va_ramp\" ] if \"vx_ramp\" in config : self . vx_ramp = config [ \"vx_ramp\" ] if \"vy_ramp\" in config : self . vy_ramp = config [ \"vy_ramp\" ] if \"x\" in config : self . x = config [ \"x\" ] if \"y\" in config : self . y = config [ \"y\" ] if \"a\" in config : self . a = degrees_to_world ( config [ \"a\" ]) if \"image_data\" in config : self . image_data = config [ \"image_data\" ] # [\"dataset\", index] if len ( self . image_data ) == 0 : self . get_dataset_image = None else : self . get_dataset_image = get_dataset ( self . image_data [ 0 ]) if \"height\" in config : self . height = config [ \"height\" ] # ratio, 0 to 1 of height if \"color\" in config : self . _set_color ( config [ \"color\" ]) if \"max_trace_length\" in config : self . max_trace_length = config [ \"max_trace_length\" ] if \"body\" in config : self . body [:] = config [ \"body\" ] self . _init_boundingbox () if \"devices\" in config : # FIXME: raise if lengths/types don't match for i , deviceConfig in enumerate ( config [ \"devices\" ]): if i < len ( self ): if self [ i ] . __class__ . __name__ == deviceConfig [ \"class\" ]: # already a device, let's reuse it: device = self [ i ] device . initialize () device . from_json ( deviceConfig ) else : raise Exception ( \"can't use reset; config changed; use load_world\" ) else : device = None try : device_class = getattr ( DEVICES , deviceConfig [ \"class\" ]) device = device_class ( ** deviceConfig ) except Exception : raise Exception ( \"Failed to create device: %s (** %s )\" % ( deviceConfig [ \"class\" ], deviceConfig ) ) if device : self . add_device ( device )","title":"from_json()"},{"location":"robot/#aitk.robots.robot.Robot.get_image","text":"Get an image of the robot. Parameters: Name Type Description Default size int size in pixels around robot 100 Source code in robots/robot.py def get_image ( self , size = 100 ): \"\"\" Get an image of the robot. Args: size (int): size in pixels around robot \"\"\" picture = self . world . get_image () start_x = round ( max ( self . x * self . world . scale - size / 2 , 0 ) ) start_y = round ( max ( self . y * self . world . scale - size / 2 , 0 ) ) rectangle = ( start_x , start_y , min ( start_x + size , self . world . width * self . world . scale ), min ( start_y + size , self . world . height * self . world . scale , ), ) picture = picture . crop ( rectangle ) return picture","title":"get_image()"},{"location":"robot/#aitk.robots.robot.Robot.get_image_3d","text":"Return the 3D image at the proper angle. Parameters: Name Type Description Default degrees int the angle of the image to get required Source code in robots/robot.py def get_image_3d ( self , degrees ): \"\"\" Return the 3D image at the proper angle. Args: degrees (int): the angle of the image to get \"\"\" return self . get_dataset_image ( self . image_data [ 1 ], degrees )","title":"get_image_3d()"},{"location":"robot/#aitk.robots.robot.Robot.get_max_trace_length","text":"Get the max length of the trace in seconds. Source code in robots/robot.py def get_max_trace_length ( self ): \"\"\" Get the max length of the trace in seconds. \"\"\" return self . max_trace_length","title":"get_max_trace_length()"},{"location":"robot/#aitk.robots.robot.Robot.get_pose","text":"Get the pose of the robot (x, y, a) where a (direction) is in degrees. Source code in robots/robot.py def get_pose ( self ): \"\"\" Get the pose of the robot (x, y, a) where a (direction) is in degrees. \"\"\" return ( self . x , self . y , world_to_degrees ( self . a ))","title":"get_pose()"},{"location":"robot/#aitk.robots.robot.Robot.get_time","text":"Get the clock time of the world. Source code in robots/robot.py def get_time ( self ): \"\"\" Get the clock time of the world. \"\"\" if self . world : return self . world . time","title":"get_time()"},{"location":"robot/#aitk.robots.robot.Robot.get_velocity","text":"Get the current (or target) translate and rotate velocities of the robot. Parameters: Name Type Description Default target bool get the target velocities if True; get the actual velocities otherwise False Source code in robots/robot.py def get_velocity ( self , target = False ): \"\"\" Get the current (or target) translate and rotate velocities of the robot. Args: target (bool): get the target velocities if True; get the actual velocities otherwise \"\"\" if not target : return ( self . vx / self . vx_max , self . va / self . va_max ) else : return ( self . tvx / self . vx_max , self . tva / self . va_max )","title":"get_velocity()"},{"location":"robot/#aitk.robots.robot.Robot.get_widget","text":"Get the robot widget. Parameters: Name Type Description Default size int size in pixels around robot None show_robot bool show picture of robot None attributes list items to include, or \"all\" None Source code in robots/robot.py def get_widget ( self , size = None , show_robot = None , attributes = None ): \"\"\" Get the robot widget. Args: size (int): size in pixels around robot show_robot (bool): show picture of robot attributes (list): items to include, or \"all\" \"\"\" from .watchers import RobotWatcher if self . _watcher is None : size = size if size is not None else 100 show_robot = show_robot if show_robot is not None else True attributes = attributes if attributes is not None else \"all\" self . _watcher = RobotWatcher ( self , size = size , show_robot = show_robot , attributes = attributes ) self . world . _watchers . append ( self . _watcher ) else : self . _watcher . set_arguments ( size = size , show_robot = show_robot , attributes = attributes ) self . _watcher . draw () return self . _watcher . get_widget ()","title":"get_widget()"},{"location":"robot/#aitk.robots.robot.Robot.has_image","text":"Does this robot have an associated 3D set of images from a dataset? Source code in robots/robot.py def has_image ( self ): \"\"\" Does this robot have an associated 3D set of images from a dataset? \"\"\" return self . get_dataset_image is not None","title":"has_image()"},{"location":"robot/#aitk.robots.robot.Robot.motors","text":"A move function that takes desired motor values and converts to trans and rotate. Parameters: Name Type Description Default left float the speed to move the left wheel required right float the speed to move the right wheel required Source code in robots/robot.py def motors ( self , left , right ): \"\"\" A move function that takes desired motor values and converts to trans and rotate. Args: left (float): the speed to move the left wheel right (float): the speed to move the right wheel \"\"\" trans = ( right + left ) / 2.0 rotate = ( right - left ) / 2.0 self . move ( trans , rotate )","title":"motors()"},{"location":"robot/#aitk.robots.robot.Robot.move","text":"Set the target translate and rotate velocities. Parameters: Name Type Description Default translate float the speed to move the robot forward/backward required rotate float the speed to rotate the robot left/right required Args should be between -1 and 1. Source code in robots/robot.py def move ( self , translate , rotate ): \"\"\" Set the target translate and rotate velocities. Args: translate (float): the speed to move the robot forward/backward rotate (float): the speed to rotate the robot left/right Args should be between -1 and 1. \"\"\" # values between -1 and 1 # compute target velocities if self . world is not None : if self . world . status != \"running\" : print_once ( \"This world is not running\" ) if translate is not None : self . tvx = round ( translate * self . vx_max , 1 ) if rotate is not None : self . tva = round ( rotate * self . va_max , 1 )","title":"move()"},{"location":"robot/#aitk.robots.robot.Robot.pen_down","text":"Put the pen down to change the color of the background image. Parameters: Name Type Description Default color str the pen color to draw None radius int the size of the dot to draw 1 Source code in robots/robot.py def pen_down ( self , color = None , radius = 1 ): \"\"\" Put the pen down to change the color of the background image. Args: color (str): the pen color to draw radius (int): the size of the dot to draw Note: not for use in a robot in a recorder. \"\"\" from PIL import Image color = color if color is not None else self . color self . pen = ( Color ( color ), radius ) if self . world is not None : if self . world . _ground_image is None : image = Image . new ( \"RGBA\" , ( self . world . width , self . world . height ), color = \"white\" ) filename = \"ground_image.png\" image . save ( filename ) self . world . set_ground_image ( filename )","title":"pen_down()"},{"location":"robot/#aitk.robots.robot.Robot.pen_up","text":"Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. Source code in robots/robot.py def pen_up ( self ): \"\"\" Put the pen up to stop changing the color of the background image. Note: not for use in a robot in a recorder. \"\"\" self . pen = ( None , 0 )","title":"pen_up()"},{"location":"robot/#aitk.robots.robot.Robot.reset","text":"Reset the robot's internal stuff. Typically, called from the world. Source code in robots/robot.py def reset ( self ): \"\"\" Reset the robot's internal stuff. Typically, called from the world. \"\"\" self . trace [:] = [] self . text_trace [:] = [] self . pen_trace [:] = []","title":"reset()"},{"location":"robot/#aitk.robots.robot.Robot.reverse","text":"Flip the target x and a velocities from negative to positive or from positive to negative. Source code in robots/robot.py def reverse ( self ): \"\"\" Flip the target x and a velocities from negative to positive or from positive to negative. \"\"\" self . tvx = - self . tvx self . tva = - self . tva","title":"reverse()"},{"location":"robot/#aitk.robots.robot.Robot.rotate","text":"Set the target rotate velocity. Parameters: Name Type Description Default rotate float the speed to rotate the robot required Arg should be between -1 and 1. Source code in robots/robot.py def rotate ( self , rotate ): \"\"\" Set the target rotate velocity. Args: rotate (float): the speed to rotate the robot Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tva = rotate * self . va_max","title":"rotate()"},{"location":"robot/#aitk.robots.robot.Robot.set_color","text":"Set the color of a robot, and its trace. Parameters: Name Type Description Default color str the color of the robot required Source code in robots/robot.py def set_color ( self , color ): \"\"\" Set the color of a robot, and its trace. Args: color (str): the color of the robot \"\"\" self . _set_color ( color )","title":"set_color()"},{"location":"robot/#aitk.robots.robot.Robot.set_max_trace_length","text":"Set the max length of trace, in seconds. Parameters: Name Type Description Default seconds float the length of trace in seconds required Source code in robots/robot.py def set_max_trace_length ( self , seconds ): \"\"\" Set the max length of trace, in seconds. Args: seconds (float): the length of trace in seconds \"\"\" self . max_trace_length = seconds","title":"set_max_trace_length()"},{"location":"robot/#aitk.robots.robot.Robot.set_pose","text":"Set the pose of the robot. a is in degrees. Parameters: Name Type Description Default x int the x coordinate of the robot None y int the y coordinate of the robot None a int the angle of the robot in degrees (zero is to the left, 90 is up) None clear_trace bool if True, clear the robot's trace True Source code in robots/robot.py def set_pose ( self , x = None , y = None , a = None , clear_trace = True ): \"\"\" Set the pose of the robot. a is in degrees. Args: x (int): the x coordinate of the robot y (int): the y coordinate of the robot a (int): the angle of the robot in degrees (zero is to the left, 90 is up) clear_trace (bool): if True, clear the robot's trace Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add to world before setting pose\" ) else : if a is not None : a = degrees_to_world ( a ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save ()","title":"set_pose()"},{"location":"robot/#aitk.robots.robot.Robot.set_random_pose","text":"Set the pose of the robot to a random open location in the world. Parameters: Name Type Description Default clear_trace bool if True, clear the trace True Source code in robots/robot.py def set_random_pose ( self , clear_trace = True ): \"\"\" Set the pose of the robot to a random open location in the world. Args: clear_trace (bool): if True, clear the trace Note: the robot must be in a world. \"\"\" if self . world is None : raise Exception ( \"This robot is not in a world; add robot to world before calling set_random_pose\" ) else : # Direction is in radians, in world coordinates: x , y , a = self . world . _find_random_pose ( self ) self . _set_pose ( x , y , a , clear_trace ) # Save the robot's pose to the config self . world . update () self . world . save ()","title":"set_random_pose()"},{"location":"robot/#aitk.robots.robot.Robot.speak","text":"Show some text in the robot's speech bubble. Parameters: Name Type Description Default text str the text to show; use None to clear None Source code in robots/robot.py def speak ( self , text = None ): \"\"\" Show some text in the robot's speech bubble. Args: text (str): the text to show; use None to clear Note: not for use in a robot in a recorder. \"\"\" if self . world : if self . world . _recording : if len ( self . text_trace ) > 0 : # If same as last, don't add again if self . text_trace [ - 1 ][ 1 ] != text : self . text_trace . append (( self . world . time , text )) else : self . text_trace . append (( self . world . time , text )) else : self . text_trace [:] = [( self . world . time , text )]","title":"speak()"},{"location":"robot/#aitk.robots.robot.Robot.stop","text":"Set the target velocities to zeros. Source code in robots/robot.py def stop ( self ): \"\"\" Set the target velocities to zeros. \"\"\" self . tvx = 0.0 self . tvy = 0.0 self . tva = 0.0","title":"stop()"},{"location":"robot/#aitk.robots.robot.Robot.summary","text":"Prints a summary of information about the robot. Source code in robots/robot.py def summary ( self ): \"\"\" Prints a summary of information about the robot. \"\"\" if len ( self . _devices ) == 0 : print ( \" This robot has no devices.\" ) else : for i , device in enumerate ( self . _devices ): print ( \" robot[ %s or %r or %r ]: %r \" % ( i , device . type , device . name , device ) ) print ( \" \" + ( \"-\" * 25 ))","title":"summary()"},{"location":"robot/#aitk.robots.robot.Robot.to_json","text":"Get this robot as a JSON config file. Source code in robots/robot.py def to_json ( self ): \"\"\" Get this robot as a JSON config file. \"\"\" robot_json = { \"name\" : self . name , \"state\" : self . state , \"va\" : self . va , \"vx\" : self . vx , \"vy\" : self . vy , \"tva\" : self . tva , \"tvx\" : self . tvx , \"tvy\" : self . tvy , \"va_max\" : self . va_max , \"vx_max\" : self . vx_max , \"vy_max\" : self . vy_max , \"va_ramp\" : self . va_ramp , \"vx_ramp\" : self . vx_ramp , \"vy_ramp\" : self . vy_ramp , \"x\" : self . x , \"y\" : self . y , \"a\" : world_to_degrees ( self . a ), \"image_data\" : self . image_data , \"height\" : self . height , \"color\" : str ( self . color ), \"max_trace_length\" : self . max_trace_length , \"body\" : self . body , \"devices\" : [ device . to_json () for device in self . _devices ], \"do_trace\" : self . do_trace , } return robot_json","title":"to_json()"},{"location":"robot/#aitk.robots.robot.Robot.translate","text":"Set the target translate velocity. Parameters: Name Type Description Default translate float the speed to move the robot forward/backward required Arg should be between -1 and 1. Source code in robots/robot.py def translate ( self , translate ): \"\"\" Set the target translate velocity. Args: translate (float): the speed to move the robot forward/backward Arg should be between -1 and 1. \"\"\" # values between -1 and 1 self . tvx = round ( translate * self . vx_max , 1 )","title":"translate()"},{"location":"robot/#aitk.robots.robot.Robot.update","text":"Update the robot, and devices. Parameters: Name Type Description Default draw_list List list of items to draw None Source code in robots/robot.py def update ( self , draw_list = None ): \"\"\" Update the robot, and devices. Args: draw_list (List): list of items to draw \"\"\" # Wrapped worlds: wrapped = False if self . x < 0 : self . x = self . world . width wrapped = True elif self . x > self . world . width : self . x = 0 wrapped = True if self . y < 0 : self . y = self . world . height wrapped = True elif self . y > self . world . height : self . y = 0 wrapped = True if wrapped : self . trace . append ( None ) self . _init_boundingbox () if self . world . debug and draw_list is not None : draw_list . append (( \"strokeStyle\" , ( Color ( 255 ), 1 ))) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 0 ] . p1 . x , self . _bounding_lines [ 0 ] . p1 . y , self . _bounding_lines [ 0 ] . p2 . x , self . _bounding_lines [ 0 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 1 ] . p1 . x , self . _bounding_lines [ 1 ] . p1 . y , self . _bounding_lines [ 1 ] . p2 . x , self . _bounding_lines [ 1 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 2 ] . p1 . x , self . _bounding_lines [ 2 ] . p1 . y , self . _bounding_lines [ 2 ] . p2 . x , self . _bounding_lines [ 2 ] . p2 . y , ), ) ) draw_list . append ( ( \"draw_line\" , ( self . _bounding_lines [ 3 ] . p1 . x , self . _bounding_lines [ 3 ] . p1 . y , self . _bounding_lines [ 3 ] . p2 . x , self . _bounding_lines [ 3 ] . p2 . y , ), ) ) # Devices: for device in self . _devices : device . update ( draw_list ) # Update recording info: if self . world . _recording : if len ( self . pen_trace ) > 0 : # color of pen: if self . pen_trace [ - 1 ][ 1 ][ 0 ] != self . pen [ 0 ]: self . pen_trace . append (( self . world . time , self . pen )) # same pen color, do nothing elif self . pen != ( None , 0 ): self . pen_trace . append (( self . world . time , self . pen )) # else do nothing else : # not recording if self . pen == ( None , 0 ): self . pen_trace [:] = [] else : self . pen_trace [:] = [( self . world . time , self . pen )] # Alter world: self . _update_ground_image ( self . world . time ) return","title":"update()"},{"location":"robot/#aitk.robots.robot.Robot.watch","text":"Watch the robot stats with live updates. Parameters: Name Type Description Default size int size in pixels around robot None show_robot bool show picture of robot None attributes List items to include, or \"all\" None Source code in robots/robot.py def watch ( self , size = None , show_robot = None , attributes = None ): \"\"\" Watch the robot stats with live updates. Args: size (int): size in pixels around robot show_robot (bool): show picture of robot attributes (List): items to include, or \"all\" \"\"\" widget = self . get_widget ( size = size , show_robot = show_robot , attributes = attributes , ) display ( widget )","title":"watch()"},{"location":"smellsensor/","text":"SmellSensor \u00b6 __init__ ( self , position = ( 0 , 0 ), name = 'smell' , ** kwargs ) special \u00b6 A smell sensor for sensing food. Parameters: Name Type Description Default position Tuple[int, int] the position of the sensor in centimeters relative to the center of the robot. (0, 0) name str the name of the device 'smell' Source code in robots/devices/smellsensors.py def __init__ ( self , position = ( 0 , 0 ), name = \"smell\" , ** kwargs ): \"\"\" A smell sensor for sensing food. Args: position (Tuple[int, int]): the position of the sensor in centimeters relative to the center of the robot. name (str): the name of the device \"\"\" config = { \"position\" : position , \"name\" : name , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config ) draw ( self , backend ) \u00b6 Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/smellsensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . lineWidth ( 1 ) backend . set_stroke_style ( BLACK ) backend . set_fill_style ( WHITE ) backend . draw_circle ( self . position [ 0 ], self . position [ 1 ], 2 ) from_json ( self , config ) \u00b6 Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/smellsensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"name\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"name\" in config : self . name = config [ \"name\" ] if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) get_reading ( self ) \u00b6 Get the smell reading from the sensor. Source code in robots/devices/smellsensors.py def get_reading ( self ): \"\"\" Get the smell reading from the sensor. \"\"\" return self . value get_widget ( self , title = 'Smell Sensor:' ) \u00b6 Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor 'Smell Sensor:' Source code in robots/devices/smellsensors.py def get_widget ( self , title = \"Smell Sensor:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"value\" , title = title , labels = [ \"Name:\" , \"Food:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget initialize ( self ) \u00b6 Internal method to set all settings to default values. Source code in robots/devices/smellsensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"smell\" self . name = \"smell\" self . value = 0.0 self . position = [ 0 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) set_position ( self , position ) \u00b6 Set the position of the sensor with respect to the center of the robot. Source code in robots/devices/smellsensors.py def set_position ( self , position ): \"\"\" Set the position of the sensor with respect to the center of the robot. Args: position (List[int, int]) represents [x, y] in CM from center of robot \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ]) to_json ( self ) \u00b6 Save the internal settings to a config dictionary. Source code in robots/devices/smellsensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"name\" : self . name , } return config update ( self , draw_list = None ) \u00b6 Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/smellsensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" self . value = 0 # Location of sensor: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + math . pi / 2 , ) self . value = self . robot . world . _grid . get ( p [ 0 ], p [ 1 ]) watch ( self , title = 'Smell Sensor:' ) \u00b6 Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Smell Sensor:' Source code in robots/devices/smellsensors.py def watch ( self , title = \"Smell Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"SmellSensor"},{"location":"smellsensor/#smellsensor","text":"","title":"SmellSensor"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.__init__","text":"A smell sensor for sensing food. Parameters: Name Type Description Default position Tuple[int, int] the position of the sensor in centimeters relative to the center of the robot. (0, 0) name str the name of the device 'smell' Source code in robots/devices/smellsensors.py def __init__ ( self , position = ( 0 , 0 ), name = \"smell\" , ** kwargs ): \"\"\" A smell sensor for sensing food. Args: position (Tuple[int, int]): the position of the sensor in centimeters relative to the center of the robot. name (str): the name of the device \"\"\" config = { \"position\" : position , \"name\" : name , } config . update ( kwargs ) self . _watcher = None self . robot = None self . initialize () self . from_json ( config )","title":"__init__()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.draw","text":"Draw the device on the backend. Parameters: Name Type Description Default backend Backend an aitk drawing backend required Source code in robots/devices/smellsensors.py def draw ( self , backend ): \"\"\" Draw the device on the backend. Args: backend (Backend): an aitk drawing backend \"\"\" backend . lineWidth ( 1 ) backend . set_stroke_style ( BLACK ) backend . set_fill_style ( WHITE ) backend . draw_circle ( self . position [ 0 ], self . position [ 1 ], 2 )","title":"draw()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.from_json","text":"Set the settings from a device config. Parameters: Name Type Description Default config dict a config dictionary required Source code in robots/devices/smellsensors.py def from_json ( self , config ): \"\"\" Set the settings from a device config. Args: config (dict): a config dictionary \"\"\" valid_keys = set ([ \"position\" , \"name\" , \"class\" ]) self . verify_config ( valid_keys , config ) if \"name\" in config : self . name = config [ \"name\" ] if \"position\" in config : self . position = config [ \"position\" ] # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"from_json()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.get_reading","text":"Get the smell reading from the sensor. Source code in robots/devices/smellsensors.py def get_reading ( self ): \"\"\" Get the smell reading from the sensor. \"\"\" return self . value","title":"get_reading()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.get_widget","text":"Return the dynamically updating widget. Parameters: Name Type Description Default title str title of sensor 'Smell Sensor:' Source code in robots/devices/smellsensors.py def get_widget ( self , title = \"Smell Sensor:\" ): \"\"\" Return the dynamically updating widget. Args: title (str): title of sensor \"\"\" from ..watchers import AttributesWatcher if self . robot is None or self . robot . world is None : print ( \"ERROR: can't watch until added to robot, and robot is in world\" ) return None if self . _watcher is None : self . _watcher = AttributesWatcher ( self , \"name\" , \"value\" , title = title , labels = [ \"Name:\" , \"Food:\" ] ) self . robot . world . _watchers . append ( self . _watcher ) return self . _watcher . widget","title":"get_widget()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.initialize","text":"Internal method to set all settings to default values. Source code in robots/devices/smellsensors.py def initialize ( self ): \"\"\" Internal method to set all settings to default values. \"\"\" self . type = \"smell\" self . name = \"smell\" self . value = 0.0 self . position = [ 0 , 0 ] self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"initialize()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.set_position","text":"Set the position of the sensor with respect to the center of the robot. Source code in robots/devices/smellsensors.py def set_position ( self , position ): \"\"\" Set the position of the sensor with respect to the center of the robot. Args: position (List[int, int]) represents [x, y] in CM from center of robot \"\"\" if len ( position ) != 2 : raise ValueError ( \"position must be of length two\" ) self . position = position # Get location of sensor, doesn't change once position is set: self . dist_from_center = distance ( 0 , 0 , self . position [ 0 ], self . position [ 1 ]) self . dir_from_center = math . atan2 ( - self . position [ 0 ], self . position [ 1 ])","title":"set_position()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.to_json","text":"Save the internal settings to a config dictionary. Source code in robots/devices/smellsensors.py def to_json ( self ): \"\"\" Save the internal settings to a config dictionary. \"\"\" config = { \"class\" : self . __class__ . __name__ , \"position\" : self . position , \"name\" : self . name , } return config","title":"to_json()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.update","text":"Update the device. Parameters: Name Type Description Default draw_list list optional. If given, then the method can add to it for drawing later. None Source code in robots/devices/smellsensors.py def update ( self , draw_list = None ): \"\"\" Update the device. Args: draw_list (list): optional. If given, then the method can add to it for drawing later. \"\"\" self . value = 0 # Location of sensor: p = rotate_around ( self . robot . x , self . robot . y , self . dist_from_center , self . robot . a + self . dir_from_center + math . pi / 2 , ) self . value = self . robot . world . _grid . get ( p [ 0 ], p [ 1 ])","title":"update()"},{"location":"smellsensor/#aitk.robots.devices.smellsensors.SmellSensor.watch","text":"Create a dynamically updating view of this sensor. Parameters: Name Type Description Default title str title of sensor 'Smell Sensor:' Source code in robots/devices/smellsensors.py def watch ( self , title = \"Smell Sensor:\" ): \"\"\" Create a dynamically updating view of this sensor. Args: title (str): title of sensor \"\"\" widget = self . get_widget ( title = title ) return display ( widget )","title":"watch()"},{"location":"world/","text":"World \u00b6 The aitk.robots simulator world. All simulations begin with a world. __init__ ( self , width = 500 , height = 250 , seed = 0 , scale = 3.0 , boundary_wall = True , boundary_wall_color = 'purple' , boundary_wall_width = 1 , ground_color = 'green' , ground_image_filename = None , filename = None , quiet = False , smell_cell_size = None , ** kwargs ) special \u00b6 The constructor for the aitk.robots simulator world. Parameters: Name Type Description Default width int width of world in pixels 500 height int height of world in pixels 250 seed int random number generator seed 0 scale float value to use in drawing the world 3.0 boundary_wall bool draw a boundary around the world? True boundary_wall_color str color name of boundary wall 'purple' boundary_wall_width int width of boundary wall 1 ground_color str color name 'green' ground_image_filename str image file used for backgound None filename str name of json world file None quiet bool if True, don't print any messages False smell_cell_size int is set automatically based on world size None You can also pass any valid item from the world config settings. from aitk.robots import World world = World ( 200 , 200 ) Source code in robots/world.py def __init__ ( self , width = 500 , # type: int height = 250 , # type: int seed = 0 , # type: int scale = 3.0 , # type: float boundary_wall = True , # type: bool boundary_wall_color = \"purple\" , # type: str boundary_wall_width = 1 , # type: int ground_color = \"green\" , # type: str ground_image_filename = None , # type: str filename = None , # type: str quiet = False , # type: bool smell_cell_size = None , # type: int ** kwargs ): \"\"\" The constructor for the aitk.robots simulator world. Args: width (int): width of world in pixels height (int): height of world in pixels seed (int): random number generator seed scale (float): value to use in drawing the world boundary_wall (bool): draw a boundary around the world? boundary_wall_color (str): color name of boundary wall boundary_wall_width (int): width of boundary wall ground_color (str): color name ground_image_filename (str): image file used for backgound filename (str): name of json world file quiet (bool): if True, don't print any messages smell_cell_size (int): is set automatically based on world size You can also pass any valid item from the world config settings. ```python from aitk.robots import World world = World(200, 200) ``` \"\"\" # For faster-than real time display with synchronous backends, # keep processing time below this percentage of throttle_period: config = { \"width\" : width , \"height\" : height , \"seed\" : seed , \"scale\" : scale , \"boundary_wall\" : boundary_wall , \"boundary_wall_width\" : boundary_wall_width , \"boundary_wall_color\" : boundary_wall_color , \"ground_color\" : ground_color , \"quiet\" : quiet , \"smell_cell_size\" : smell_cell_size , } self . _messages = [] if filename is not None : config [ \"filename\" ] = filename if ground_image_filename is not None : config [ \"ground_image_filename\" ] = ground_image_filename config [ \"walls\" ] = kwargs . pop ( \"walls\" , []) config [ \"bulbs\" ] = kwargs . pop ( \"bulbs\" , []) config [ \"robots\" ] = kwargs . pop ( \"robots\" , []) config [ \"food\" ] = kwargs . pop ( \"food\" , []) if len ( kwargs ) != 0 : raise AttributeError ( \"unknown arguments for World: %s \" % list ( kwargs . keys ()) ) self . _show_throttle_percentage = 0.40 self . _time_decimal_places = 1 self . _throttle_period = 0.1 self . _time_of_last_call = 0 self . _step_display = \"tqdm\" self . debug = False self . _watchers = [] self . _robots = [] self . _bulbs = [] self . _backend = None self . _recording = False self . config = config . copy () self . _initialize () # default values self . robots = List ( self . _robots ) self . bulbs = List ( self . _bulbs ) self . reset () # from config add_bulb ( self , color , x , y , z , brightness , name = None ) \u00b6 Add a bulb to the world. Parameters: Name Type Description Default color str the color of the light required x int the x coordinate required y int the y coordinate required z int the z coordinate required brightness float the distance in pixels of 1 standard deviation required name str the name of the bulb None Source code in robots/world.py def add_bulb ( self , color , x , y , z , brightness , name = None ): \"\"\" Add a bulb to the world. Args: color (str): the color of the light x (int): the x coordinate y (int): the y coordinate z (int): the z coordinate brightness (float): the distance in pixels of 1 standard deviation name (str): the name of the bulb \"\"\" self . _add_bulb ( color , x , y , z , brightness , name ) self . update () # request draw self . save () add_food ( self , x , y , standard_deviation ) \u00b6 Add food at x, y with a brightness of standard_deviation (in pixels). Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required standard_deviation float distance int pixels of 1 standard deviation required Source code in robots/world.py def add_food ( self , x , y , standard_deviation ): \"\"\" Add food at x, y with a brightness of standard_deviation (in pixels). Args: x (int): the x coordinate y (int): the y coordinate standard_deviation (float): distance int pixels of 1 standard deviation \"\"\" self . _add_food ( x , y , standard_deviation ) self . _grid . need_update = True self . update () # request draw self . save () add_robot ( self , robot ) \u00b6 Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Parameters: Name Type Description Default robot Robot the robot to add required Source code in robots/world.py def add_robot ( self , robot ): \"\"\" Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Args: robot (Robot): the robot to add \"\"\" if robot not in self . _robots : if robot . x == 0 and robot . y == 0 : robot . x , robot . y , robot . a = self . _find_random_pose ( robot ) self . _robots . append ( robot ) robot . world = self # Bounding lines form a wall: if len ( robot . _bounding_lines ) == 0 : print ( \"WARNING: adding a robot with no body\" ) wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . update () self . save () else : raise Exception ( \"Can't add the same robot to a world more than once.\" ) add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = 'wall' ) \u00b6 Add a wall as a line or as a box. Parameters: Name Type Description Default color str the color of the wall required x1 int the upper left x coordinate required y1 int the upper left y coordinate required x2 int the lower right x coordinate required y2 int the lower right y coordinate required box bool whether this is a box (True) or line (False) True wtype str \"wall\", \"robot\", or \"boundary\" 'wall' Source code in robots/world.py def add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = \"wall\" ): \"\"\" Add a wall as a line or as a box. Args: color (str): the color of the wall x1 (int): the upper left x coordinate y1 (int): the upper left y coordinate x2 (int): the lower right x coordinate y2 (int): the lower right y coordinate box (bool): whether this is a box (True) or line (False) wtype (str): \"wall\", \"robot\", or \"boundary\" \"\"\" p1 = Point ( x1 , y1 ) p3 = Point ( x2 , y2 ) if box : ## Pairs of points make Line: p2 = Point ( x2 , y1 ) p4 = Point ( x1 , y2 ) wall = Wall ( Color ( color ), None , Line ( p1 , p2 ), Line ( p2 , p3 ), Line ( p3 , p4 ), Line ( p4 , p1 ), wtype = wtype , ) else : wall = Wall ( Color ( color ), None , Line ( p1 , p3 ), wtype = \"wall\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . _grid . update_wall ( wall ) self . update () # request draw clear_watchers ( self ) \u00b6 Clear all of the watchers. Source code in robots/world.py def clear_watchers ( self ): \"\"\" Clear all of the watchers. \"\"\" self . _watchers [:] = [] del_robot ( self , robot ) \u00b6 Remove a robot from the world. Parameters: Name Type Description Default robot Robot the robot to remove required Source code in robots/world.py def del_robot ( self , robot ): \"\"\" Remove a robot from the world. Args: robot (Robot): the robot to remove \"\"\" if not isinstance ( robot , Robot ): # Then look it up by index/name/type: robot = self . robots [ robot ] for wall in list ( self . _walls ): if wall . robot is robot : self . _walls . remove ( wall ) if robot in self . _robots : robot . world = None self . _robots . remove ( robot ) self . _complexity = self . _compute_complexity () self . update () # request draw display ( self , index = None , size = 100 ) \u00b6 Display a picture of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def display ( self , index = None , size = 100 ): \"\"\" Display a picture of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" picture = self . get_image ( index = index , size = size ) display ( picture ) draw ( self ) \u00b6 Force a redraw of the world. Source code in robots/world.py def draw ( self ): \"\"\" Force a redraw of the world. \"\"\" if self . _backend is None : return self . _grid . update ( self . _food ) with self . _backend : self . _backend . clear () self . _backend . noStroke () if self . _ground_image is not None : self . _backend . draw_image ( self . _ground_image , 0 , 0 ) else : self . _backend . set_fill ( self . ground_color ) self . _backend . draw_rect ( 0 , 0 , self . width , self . height ) if len ( self . _food ) > 0 : smell = self . _grid . get_image () smell = smell . resize (( int ( self . width * self . scale ), int ( self . height * self . scale ))) self . _backend . image . paste ( smell , ( 0 , 0 ), smell ) ## Draw all bulbs in world: maxRange = max ( self . width , self . height ) for bulb in self . _get_light_sources ( all = True ): if bulb . state == \"on\" : color = bulb . color self . _backend . line_width = 0 self . _backend . noStroke () x , y = bulb . get_position ( world = True ) # Cast rays once: all_hits = [] for ray in range ( bulb . rays ): angle = ray / bulb . rays * TWO_PI hits = cast_ray ( self , bulb . robot , x , y , - angle + PI_OVER_2 , maxRange ) all_hits . append ( hits ) # Now draw the rings: for i in range ( bulb . draw_rings ): radius = ( bulb . draw_rings - i ) * 2 ray_length = bulb . brightness / 30 * radius color . alpha = ( i + 1 ) / bulb . draw_rings * 255 self . _backend . set_fill_style ( color ) points = [] for ray in range ( bulb . rays ): hits = all_hits [ ray ] ray_length = bulb . brightness / 30 * radius if len ( hits ) > 0 : if hits [ - 1 ] . distance < ray_length : ray_length = hits [ - 1 ] . distance angle = ray / bulb . rays * TWO_PI x2 , y2 = rotate_around ( x , y , ray_length , angle ) points . append (( x2 , y2 )) self . _backend . draw_polygon ( points ) self . _backend . line_width = 1 ## Draw walls: for wall in self . _walls : if wall . wtype == \"wall\" : c = wall . color if len ( wall . lines ) == 1 : self . _backend . strokeStyle ( c , 5 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) else : self . _backend . set_fill ( c ) self . _backend . noStroke () self . _backend . beginShape () for line in wall . lines : self . _backend . vertex ( line . p1 . x , line . p1 . y ) self . _backend . vertex ( line . p2 . x , line . p2 . y ) self . _backend . endShape () self . _backend . lineWidth ( 1 ) self . _backend . noStroke () elif wall . wtype == \"boundary\" : c = wall . color self . _backend . strokeStyle ( c , 3 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) self . _backend . lineWidth ( 1 ) self . _backend . noStroke () ## Draw robots: for robot in self . _robots : robot . draw ( self . _backend ) text = format_time ( self . time ) self . _backend . draw_status ( text ) for items in self . _draw_list : if len ( items ) == 1 : command = items [ 0 ] args = tuple () kwargs = {} elif len ( items ) == 2 : command = items [ 0 ] args = items [ 1 ] kwargs = {} elif len ( items ) == 3 : command = items [ 0 ] args = items [ 1 ] kwargs = items [ 2 ] self . _backend . do_command ( command , * args , ** kwargs ) self . _draw_watchers () from_json ( self , config ) \u00b6 Load a json config file. Source code in robots/world.py def from_json ( self , config ): \"\"\" Load a json config file. \"\"\" self . config = config seed = config . get ( \"seed\" , 0 ) self . set_seed ( seed ) if \"filename\" in config : self . filename = config [ \"filename\" ] if \"quiet\" in config : self . quiet = config [ \"quiet\" ] if \"width\" in config : self . width = config [ \"width\" ] if \"height\" in config : self . height = config [ \"height\" ] if \"scale\" in config : self . scale = config [ \"scale\" ] if \"smell_cell_size\" in config : self . smell_cell_size = config [ \"smell_cell_size\" ] if self . smell_cell_size is None : self . smell_cell_size = max (( self . width * self . height ) // 20000 , 1 ) if \"boundary_wall\" in config : self . boundary_wall = config [ \"boundary_wall\" ] if \"boundary_wall_color\" in config : self . boundary_wall_color = Color ( config [ \"boundary_wall_color\" ]) if \"boundary_wall_width\" in config : self . boundary_wall_width = config [ \"boundary_wall_width\" ] if \"ground_color\" in config : self . ground_color = Color ( config [ \"ground_color\" ]) if \"ground_image_filename\" in config : self . set_ground_image ( config [ \"ground_image_filename\" ], show = False ) # Now, we create the grid: self . _grid = Grid ( self . width , self . height , self . smell_cell_size ) self . _grid . update_walls ( self . _walls ) # Add walls: self . _add_boundary_walls () for wall in config . get ( \"walls\" , []): # Walls are either \"boxes\" with 4 lines, or a single line: if \"wtype\" not in wall or wall [ \"wtype\" ] == \"box\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = True , ) elif wall [ \"wtype\" ] == \"line\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = False , ) for bulb in config . get ( \"bulbs\" , []): # bulbs are {x, y, z, color, brightness} self . _add_bulb ( ** bulb ) for food in config . get ( \"food\" , []): # food x, y, standard_deviation self . _add_food ( ** food ) ## Create robot, and add to world: for i , robotConfig in enumerate ( self . config . get ( \"robots\" , [])): # FIXME: raise if lengths don't match if i < len ( self . _robots ): # already a robot; let's reuse it: robot = self . _robots [ i ] robot . _initialize () robot . from_json ( robotConfig ) else : robot = Robot ( ** robotConfig ) self . add_robot ( robot ) # Create the backend if first time: if self . _backend is None : self . _backend = make_backend ( self . width , self . height , self . scale ) # Update the backend if it already existed, but differs in config self . _backend . update_dimensions ( self . width , self . height , self . scale ) get_bulb ( self , item ) \u00b6 Get the bulb by name or index. Equivalent to world.bulbs[item] Parameters: Name Type Description Default item int or string index or name of bulb required Source code in robots/world.py def get_bulb ( self , item ): \"\"\" Get the bulb by name or index. Equivalent to world.bulbs[item] Args: item (int or string): index or name of bulb \"\"\" return self . bulbs [ item ] get_ground_color_at ( self , x , y , radius = 1 ) \u00b6 Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required radius int size of area 1 Source code in robots/world.py def get_ground_color_at ( self , x , y , radius = 1 ): \"\"\" Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate radius (int): size of area \"\"\" if self . _ground_image : results = [] for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): results . append ( self . _ground_image_pixels [ (( x + i ) * self . scale , ( y + j ) * self . scale ) ] ) return results get_image ( self , index = None , size = 100 ) \u00b6 Get a PIL image of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def get_image ( self , index = None , size = 100 ): \"\"\" Get a PIL image of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" try : picture = self . _backend . get_image ( self . time ) except RuntimeError : raise Exception ( \"Backend is not ready yet; try again\" ) if index is not None : robot = self . robots [ index ] if robot : start_x = round ( max ( robot . x * self . scale - size / 2 , 0 )) start_y = round ( max ( robot . y * self . scale - size / 2 , 0 )) rectangle = ( start_x , start_y , min ( start_x + size , self . width * self . scale ), min ( start_y + size , self . height * self . scale ), ) picture = picture . crop ( rectangle ) return picture else : return picture get_robot ( self , item ) \u00b6 Get the robot by name or index. Equivalent to world.robots[item] Parameters: Name Type Description Default item int or string index or name of robot required Source code in robots/world.py def get_robot ( self , item ): \"\"\" Get the robot by name or index. Equivalent to world.robots[item] Args: item (int or string): index or name of robot \"\"\" return self . robots [ item ] get_widget ( self , width = None , height = None ) \u00b6 Returns the IPython simulation widget. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def get_widget ( self , width = None , height = None ): \"\"\" Returns the IPython simulation widget. Args: width (int): the width of the world height (int): the height of the world \"\"\" if isinstance ( width , int ): width = \" %s px\" % width if isinstance ( height , int ): height = \" %s px\" % height self . _step_display = \"notebook\" self . update () return self . _backend . get_widget ( width = width , height = height ) paste_ground_image ( self , image , x , y ) \u00b6 Paste an image onto the ground image. Requires a ground image to have already been set. Parameters: Name Type Description Default image Image a Python Image Library image required x int the x coordinate of upper lefthand corner required y int the y coordinate of upper lefthand corner required Source code in robots/world.py def paste_ground_image ( self , image , x , y ): \"\"\" Paste an image onto the ground image. Requires a ground image to have already been set. Args: image (Image): a Python Image Library image x (int): the x coordinate of upper lefthand corner y (int): the y coordinate of upper lefthand corner \"\"\" if self . _ground_image : self . _ground_image . paste ( image , ( x , y )) record ( self ) \u00b6 Create and return a world recorder. Source code in robots/world.py def record ( self ): \"\"\" Create and return a world recorder. \"\"\" from .watchers import Recorder recorder = Recorder ( self ) self . _watchers . append ( recorder ) self . _recording = True return recorder reset ( self ) \u00b6 Reloads the config from initialization, or from last save. Source code in robots/world.py def reset ( self ): \"\"\" Reloads the config from initialization, or from last save. \"\"\" self . stop () self . _initialize () self . _reset_watchers () self . _food = [] self . _grid = None self . from_json ( self . config ) self . time = 0.0 for robot in self . _robots : robot . reset () # Re-add the robot's boundaries: wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _stop = False # should stop? self . status = \"stopped\" self . update ( show = False ) # twice to allow robots to see each other self . update ( show = False ) self . draw () # force run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False ) \u00b6 Run the simulator until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False background bool if True, run in the background. False Source code in robots/world.py def run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False , ): \"\"\" Run the simulator until one of the control functions returns True or Control+C is pressed. Args: function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed background (bool): if True, run in the background. \"\"\" time_step = time_step if time_step is not None else self . time_step if background : if self . _thread is None : kwargs = { \"function\" : function , \"time_step\" : time_step , \"show\" : show , \"real_time\" : real_time , \"show_progress\" : False , \"quiet\" : True , \"background\" : False } print ( \"Starting world.run() in background. Use world.stop()\" ) self . _thread = Thread ( target = self . run , kwargs = kwargs ) self . _thread . start () else : print ( \"The world is already running in the background. Use world.stop()\" ) else : self . steps ( float ( \"inf\" ), function , time_step , show , real_time , show_progress , quiet ) save ( self ) \u00b6 Save the current state of the world as the config. Source code in robots/world.py def save ( self ): \"\"\" Save the current state of the world as the config. \"\"\" self . config = self . to_json () save_as ( self , filename ) \u00b6 Save the world config JSON as a new file. Parameters: Name Type Description Default filename str the name of the file to save the world in required Source code in robots/world.py def save_as ( self , filename ): \"\"\" Save the world config JSON as a new file. Args: filename (str): the name of the file to save the world in \"\"\" if not filename . endswith ( \".json\" ): filename = filename + \".json\" # First, save internally. self . config = self . to_json () with open ( filename , \"w\" ) as fp : json_dump ( self . to_json (), fp , sort_keys = True , indent = 4 ) self . config [ \"filename\" ] = filename save_file ( self ) \u00b6 Save the current state of the world as the config, and save it back to disc if it was loaded from disk. Source code in robots/world.py def save_file ( self ): \"\"\" Save the current state of the world as the config, and save it back to disc if it was loaded from disk. \"\"\" # First, save internally. self . config = self . to_json () if self . filename is not None and os . path . exists ( self . filename ): with open ( self . filename , \"w\" ) as fp : json_dump ( self . config , fp , sort_keys = True , indent = 4 ) else : if not self . quiet : print ( \"Saved in memory. Use world.save_as('filename') to save to disk.\" ) seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False ) \u00b6 Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default seconds float how many simulation seconds to run 5.0 function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time float run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Args: seconds (float): how many simulation seconds to run function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (float): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" time_step = time_step if time_step is not None else self . time_step steps = round ( seconds / time_step ) self . steps ( steps , function , time_step , show , real_time , show_progress , quiet ) set_ground_color_at ( self , x , y , pen ) \u00b6 Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required pen tuple the (color, radius) to draw with required Source code in robots/world.py def set_ground_color_at ( self , x , y , pen ): \"\"\" Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate pen (tuple): the (color, radius) to draw with \"\"\" if self . _ground_image : color , radius = pen for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): try : self . _ground_image_pixels [ (( x * self . scale ) + i , ( y * self . scale ) + j ) ] = color . to_tuple () except Exception : pass set_ground_image ( self , filename , show = True ) \u00b6 Set the background image Parameters: Name Type Description Default filename str the name of the image required show bool update the world now if True True Source code in robots/world.py def set_ground_image ( self , filename , show = True ): \"\"\" Set the background image Args: filename (str): the name of the image show (bool): update the world now if True \"\"\" self . ground_image_filename = filename self . _reset_ground_image () if show : self . update ( show = False ) self . draw () # force set_scale ( self , scale ) \u00b6 Change the scale of the rendered world. Parameters: Name Type Description Default scale float the scale of the world (usually between 0.5 and 10) required Source code in robots/world.py def set_scale ( self , scale ): \"\"\" Change the scale of the rendered world. Args: scale (float): the scale of the world (usually between 0.5 and 10) \"\"\" self . scale = scale self . _backend . update_dimensions ( self . width , self . height , self . scale ) # Save with config self . config [ \"scale\" ] = self . scale self . update ( show = False ) self . draw () # force set_seed ( self , seed ) \u00b6 Set the random seed. Source code in robots/world.py def set_seed ( self , seed ): \"\"\" Set the random seed. \"\"\" if seed == 0 : seed = random . randint ( 0 , 9999999 ) if not self . quiet : print ( \"Random seed set to:\" , seed ) else : if not self . quiet : print ( \"Using random seed:\" , seed ) random . seed ( seed ) self . seed = seed self . config [ \"seed\" ] = seed steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False ) \u00b6 Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default steps int either a finite number, or infinity 1 time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Args: steps (int): either a finite number, or infinity function (Function) either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" self . status = \"running\" time_step = time_step if time_step is not None else self . time_step if steps == float ( \"inf\" ): step_iter = count () else : step_iter = range ( steps ) with self . _no_interrupt (): start_real_time = time . monotonic () start_time = self . time for step in progress_bar ( step_iter , show_progress and not quiet , self . _step_display ): if self . _stop : self . status = \"stopped\" break if function is not None : if isinstance ( function , ( list , tuple )): if len ( function ) < len ( self . _robots ): print_once ( \"WARNING: you have not provided a controller function for every robot\" ) # Deterministically run robots round-robin: stop = any ( [ function [ i ]( self . _robots [ i ]) for i in range ( len ( function )) if function [ i ] is not None ] ) else : stop = function ( self ) if stop : break self . _step ( time_step , show = show , real_time = real_time ) self . status = \"stopped\" stop_real_time = time . monotonic () stop_time = self . time speed = ( stop_time - start_time ) / ( stop_real_time - start_real_time ) if steps > 1 and not quiet and not self . quiet : print ( \"Simulation stopped at: %s ; speed %s x real time\" % ( format_time ( self . time ), round ( speed , 2 )) ) if show : self . draw () # force to update any displays stop ( self ) \u00b6 Stop the simulator, if in thread or not. Source code in robots/world.py def stop ( self ): \"\"\" Stop the simulator, if in thread or not. \"\"\" self . _stop = True self . status = \"stopped\" if self . _thread is not None : print ( \"Stopping thread...\" ) self . _thread . join () self . _thread = None summary ( self ) \u00b6 Print a summary of information about the world and all of its robots. Source code in robots/world.py def summary ( self ): \"\"\" Print a summary of information about the world and all of its robots. \"\"\" print ( \"World details:\" ) if self . filename : print ( \"This world was loaded from %r \" % self . filename ) print ( \"Size: %s x %s \" % ( self . width , self . height )) print ( \"Robots:\" ) if len ( self . _robots ) == 0 : print ( \" This world has no robots.\" ) else : print ( \"-\" * 25 ) for i , robot in enumerate ( self . _robots ): print ( \" .robots[ %s or %r ]: %r \" % ( i , robot . name , robot )) robot . summary () print ( \"Food:\" ) if len ( self . _food ) == 0 : print ( \" This world has no food.\" ) else : print ( \"-\" * 25 ) for food in self . _food : print ( \" x: %s , y: %s , brightness: %s \" % ( food [ 0 ], food [ 1 ], food [ 2 ])) print ( \"Lights:\" ) if len ( self . _bulbs ) == 0 : print ( \" This world has no lights.\" ) else : print ( \"-\" * 25 ) for bulb in self . _bulbs : print ( \" x: %s , y: %s , brightness: %s , name: %r , color: %s \" % ( bulb . x , bulb . y , bulb . brightness , bulb . name , bulb . color )) to_json ( self ) \u00b6 Get the world as a JSON dict. Source code in robots/world.py def to_json ( self ): \"\"\" Get the world as a JSON dict. \"\"\" config = { \"seed\" : self . seed , \"width\" : int ( self . width ), \"height\" : int ( self . height ), \"scale\" : self . scale , \"boundary_wall\" : self . boundary_wall , # bool \"boundary_wall_color\" : str ( self . boundary_wall_color ), \"boundary_wall_width\" : self . boundary_wall_width , \"ground_color\" : str ( self . ground_color ), \"ground_image_filename\" : self . ground_image_filename , \"quiet\" : self . quiet , \"smell_cell_size\" : self . smell_cell_size , \"walls\" : [], \"bulbs\" : [], \"robots\" : [], \"food\" : [], } for wall in self . _walls : # Not a boundary wall or robot bounding box: if wall . wtype == \"wall\" : if len ( wall . lines ) == 4 : # Box: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 2 ] . p1 . x , \"y\" : wall . lines [ 2 ] . p1 . y ,}, \"wtype\" : \"box\" , } elif len ( wall . lines ) == 1 : # Line: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 0 ] . p2 . x , \"y\" : wall . lines [ 0 ] . p2 . y ,}, \"wtype\" : \"line\" , } else : raise Exception ( \"invalid wall length; should be 1 or 4: %s \" % len ( wall . lines )) config [ \"walls\" ] . append ( w ) for bulb in self . _bulbs : config [ \"bulbs\" ] . append ( { \"color\" : str ( bulb . color ), \"x\" : bulb . x , \"y\" : bulb . y , \"z\" : bulb . z , \"brightness\" : bulb . brightness , } ) for food in self . _food : config [ \"food\" ] . append ( { \"x\" : food [ 0 ], \"y\" : food [ 1 ], \"standard_deviation\" : food [ 2 ], } ) for robot in self . _robots : config [ \"robots\" ] . append ( robot . to_json ()) return config update ( self , show = True ) \u00b6 Update the world, robots, and devices. Optionally, draw the world. Parameters: Name Type Description Default show bool if True, draw the world. True Source code in robots/world.py def update ( self , show = True ): \"\"\" Update the world, robots, and devices. Optionally, draw the world. Args: show (bool): if True, draw the world. \"\"\" ## Update robots: self . _draw_list = self . _overlay_list [:] for robot in self . _robots : robot . update ( self . _draw_list ) if show : self . _request_draw () watch ( self , width = None , height = None ) \u00b6 Display a live (dynamically updated) view of the world. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def watch ( self , width = None , height = None ): \"\"\" Display a live (dynamically updated) view of the world. Args: width (int): the width of the world height (int): the height of the world \"\"\" # Force update: self . update ( show = True ) # Force draw: self . draw () widget = self . get_widget ( width , height ) display ( widget )","title":"World"},{"location":"world/#world","text":"The aitk.robots simulator world. All simulations begin with a world.","title":"World"},{"location":"world/#aitk.robots.world.World.__init__","text":"The constructor for the aitk.robots simulator world. Parameters: Name Type Description Default width int width of world in pixels 500 height int height of world in pixels 250 seed int random number generator seed 0 scale float value to use in drawing the world 3.0 boundary_wall bool draw a boundary around the world? True boundary_wall_color str color name of boundary wall 'purple' boundary_wall_width int width of boundary wall 1 ground_color str color name 'green' ground_image_filename str image file used for backgound None filename str name of json world file None quiet bool if True, don't print any messages False smell_cell_size int is set automatically based on world size None You can also pass any valid item from the world config settings. from aitk.robots import World world = World ( 200 , 200 ) Source code in robots/world.py def __init__ ( self , width = 500 , # type: int height = 250 , # type: int seed = 0 , # type: int scale = 3.0 , # type: float boundary_wall = True , # type: bool boundary_wall_color = \"purple\" , # type: str boundary_wall_width = 1 , # type: int ground_color = \"green\" , # type: str ground_image_filename = None , # type: str filename = None , # type: str quiet = False , # type: bool smell_cell_size = None , # type: int ** kwargs ): \"\"\" The constructor for the aitk.robots simulator world. Args: width (int): width of world in pixels height (int): height of world in pixels seed (int): random number generator seed scale (float): value to use in drawing the world boundary_wall (bool): draw a boundary around the world? boundary_wall_color (str): color name of boundary wall boundary_wall_width (int): width of boundary wall ground_color (str): color name ground_image_filename (str): image file used for backgound filename (str): name of json world file quiet (bool): if True, don't print any messages smell_cell_size (int): is set automatically based on world size You can also pass any valid item from the world config settings. ```python from aitk.robots import World world = World(200, 200) ``` \"\"\" # For faster-than real time display with synchronous backends, # keep processing time below this percentage of throttle_period: config = { \"width\" : width , \"height\" : height , \"seed\" : seed , \"scale\" : scale , \"boundary_wall\" : boundary_wall , \"boundary_wall_width\" : boundary_wall_width , \"boundary_wall_color\" : boundary_wall_color , \"ground_color\" : ground_color , \"quiet\" : quiet , \"smell_cell_size\" : smell_cell_size , } self . _messages = [] if filename is not None : config [ \"filename\" ] = filename if ground_image_filename is not None : config [ \"ground_image_filename\" ] = ground_image_filename config [ \"walls\" ] = kwargs . pop ( \"walls\" , []) config [ \"bulbs\" ] = kwargs . pop ( \"bulbs\" , []) config [ \"robots\" ] = kwargs . pop ( \"robots\" , []) config [ \"food\" ] = kwargs . pop ( \"food\" , []) if len ( kwargs ) != 0 : raise AttributeError ( \"unknown arguments for World: %s \" % list ( kwargs . keys ()) ) self . _show_throttle_percentage = 0.40 self . _time_decimal_places = 1 self . _throttle_period = 0.1 self . _time_of_last_call = 0 self . _step_display = \"tqdm\" self . debug = False self . _watchers = [] self . _robots = [] self . _bulbs = [] self . _backend = None self . _recording = False self . config = config . copy () self . _initialize () # default values self . robots = List ( self . _robots ) self . bulbs = List ( self . _bulbs ) self . reset () # from config","title":"__init__()"},{"location":"world/#aitk.robots.world.World.add_bulb","text":"Add a bulb to the world. Parameters: Name Type Description Default color str the color of the light required x int the x coordinate required y int the y coordinate required z int the z coordinate required brightness float the distance in pixels of 1 standard deviation required name str the name of the bulb None Source code in robots/world.py def add_bulb ( self , color , x , y , z , brightness , name = None ): \"\"\" Add a bulb to the world. Args: color (str): the color of the light x (int): the x coordinate y (int): the y coordinate z (int): the z coordinate brightness (float): the distance in pixels of 1 standard deviation name (str): the name of the bulb \"\"\" self . _add_bulb ( color , x , y , z , brightness , name ) self . update () # request draw self . save ()","title":"add_bulb()"},{"location":"world/#aitk.robots.world.World.add_food","text":"Add food at x, y with a brightness of standard_deviation (in pixels). Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required standard_deviation float distance int pixels of 1 standard deviation required Source code in robots/world.py def add_food ( self , x , y , standard_deviation ): \"\"\" Add food at x, y with a brightness of standard_deviation (in pixels). Args: x (int): the x coordinate y (int): the y coordinate standard_deviation (float): distance int pixels of 1 standard deviation \"\"\" self . _add_food ( x , y , standard_deviation ) self . _grid . need_update = True self . update () # request draw self . save ()","title":"add_food()"},{"location":"world/#aitk.robots.world.World.add_robot","text":"Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Parameters: Name Type Description Default robot Robot the robot to add required Source code in robots/world.py def add_robot ( self , robot ): \"\"\" Add a new robot to the world. If the robot's position is 0,0 then place it randomly in the world. Args: robot (Robot): the robot to add \"\"\" if robot not in self . _robots : if robot . x == 0 and robot . y == 0 : robot . x , robot . y , robot . a = self . _find_random_pose ( robot ) self . _robots . append ( robot ) robot . world = self # Bounding lines form a wall: if len ( robot . _bounding_lines ) == 0 : print ( \"WARNING: adding a robot with no body\" ) wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . update () self . save () else : raise Exception ( \"Can't add the same robot to a world more than once.\" )","title":"add_robot()"},{"location":"world/#aitk.robots.world.World.add_wall","text":"Add a wall as a line or as a box. Parameters: Name Type Description Default color str the color of the wall required x1 int the upper left x coordinate required y1 int the upper left y coordinate required x2 int the lower right x coordinate required y2 int the lower right y coordinate required box bool whether this is a box (True) or line (False) True wtype str \"wall\", \"robot\", or \"boundary\" 'wall' Source code in robots/world.py def add_wall ( self , color , x1 , y1 , x2 , y2 , box = True , wtype = \"wall\" ): \"\"\" Add a wall as a line or as a box. Args: color (str): the color of the wall x1 (int): the upper left x coordinate y1 (int): the upper left y coordinate x2 (int): the lower right x coordinate y2 (int): the lower right y coordinate box (bool): whether this is a box (True) or line (False) wtype (str): \"wall\", \"robot\", or \"boundary\" \"\"\" p1 = Point ( x1 , y1 ) p3 = Point ( x2 , y2 ) if box : ## Pairs of points make Line: p2 = Point ( x2 , y1 ) p4 = Point ( x1 , y2 ) wall = Wall ( Color ( color ), None , Line ( p1 , p2 ), Line ( p2 , p3 ), Line ( p3 , p4 ), Line ( p4 , p1 ), wtype = wtype , ) else : wall = Wall ( Color ( color ), None , Line ( p1 , p3 ), wtype = \"wall\" ) self . _walls . append ( wall ) self . _complexity = self . _compute_complexity () self . _grid . update_wall ( wall ) self . update () # request draw","title":"add_wall()"},{"location":"world/#aitk.robots.world.World.clear_watchers","text":"Clear all of the watchers. Source code in robots/world.py def clear_watchers ( self ): \"\"\" Clear all of the watchers. \"\"\" self . _watchers [:] = []","title":"clear_watchers()"},{"location":"world/#aitk.robots.world.World.del_robot","text":"Remove a robot from the world. Parameters: Name Type Description Default robot Robot the robot to remove required Source code in robots/world.py def del_robot ( self , robot ): \"\"\" Remove a robot from the world. Args: robot (Robot): the robot to remove \"\"\" if not isinstance ( robot , Robot ): # Then look it up by index/name/type: robot = self . robots [ robot ] for wall in list ( self . _walls ): if wall . robot is robot : self . _walls . remove ( wall ) if robot in self . _robots : robot . world = None self . _robots . remove ( robot ) self . _complexity = self . _compute_complexity () self . update () # request draw","title":"del_robot()"},{"location":"world/#aitk.robots.world.World.display","text":"Display a picture of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def display ( self , index = None , size = 100 ): \"\"\" Display a picture of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" picture = self . get_image ( index = index , size = size ) display ( picture )","title":"display()"},{"location":"world/#aitk.robots.world.World.draw","text":"Force a redraw of the world. Source code in robots/world.py def draw ( self ): \"\"\" Force a redraw of the world. \"\"\" if self . _backend is None : return self . _grid . update ( self . _food ) with self . _backend : self . _backend . clear () self . _backend . noStroke () if self . _ground_image is not None : self . _backend . draw_image ( self . _ground_image , 0 , 0 ) else : self . _backend . set_fill ( self . ground_color ) self . _backend . draw_rect ( 0 , 0 , self . width , self . height ) if len ( self . _food ) > 0 : smell = self . _grid . get_image () smell = smell . resize (( int ( self . width * self . scale ), int ( self . height * self . scale ))) self . _backend . image . paste ( smell , ( 0 , 0 ), smell ) ## Draw all bulbs in world: maxRange = max ( self . width , self . height ) for bulb in self . _get_light_sources ( all = True ): if bulb . state == \"on\" : color = bulb . color self . _backend . line_width = 0 self . _backend . noStroke () x , y = bulb . get_position ( world = True ) # Cast rays once: all_hits = [] for ray in range ( bulb . rays ): angle = ray / bulb . rays * TWO_PI hits = cast_ray ( self , bulb . robot , x , y , - angle + PI_OVER_2 , maxRange ) all_hits . append ( hits ) # Now draw the rings: for i in range ( bulb . draw_rings ): radius = ( bulb . draw_rings - i ) * 2 ray_length = bulb . brightness / 30 * radius color . alpha = ( i + 1 ) / bulb . draw_rings * 255 self . _backend . set_fill_style ( color ) points = [] for ray in range ( bulb . rays ): hits = all_hits [ ray ] ray_length = bulb . brightness / 30 * radius if len ( hits ) > 0 : if hits [ - 1 ] . distance < ray_length : ray_length = hits [ - 1 ] . distance angle = ray / bulb . rays * TWO_PI x2 , y2 = rotate_around ( x , y , ray_length , angle ) points . append (( x2 , y2 )) self . _backend . draw_polygon ( points ) self . _backend . line_width = 1 ## Draw walls: for wall in self . _walls : if wall . wtype == \"wall\" : c = wall . color if len ( wall . lines ) == 1 : self . _backend . strokeStyle ( c , 5 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) else : self . _backend . set_fill ( c ) self . _backend . noStroke () self . _backend . beginShape () for line in wall . lines : self . _backend . vertex ( line . p1 . x , line . p1 . y ) self . _backend . vertex ( line . p2 . x , line . p2 . y ) self . _backend . endShape () self . _backend . lineWidth ( 1 ) self . _backend . noStroke () elif wall . wtype == \"boundary\" : c = wall . color self . _backend . strokeStyle ( c , 3 ) self . _backend . draw_line ( wall . lines [ 0 ] . p1 . x , wall . lines [ 0 ] . p1 . y , wall . lines [ 0 ] . p2 . x , wall . lines [ 0 ] . p2 . y , ) self . _backend . lineWidth ( 1 ) self . _backend . noStroke () ## Draw robots: for robot in self . _robots : robot . draw ( self . _backend ) text = format_time ( self . time ) self . _backend . draw_status ( text ) for items in self . _draw_list : if len ( items ) == 1 : command = items [ 0 ] args = tuple () kwargs = {} elif len ( items ) == 2 : command = items [ 0 ] args = items [ 1 ] kwargs = {} elif len ( items ) == 3 : command = items [ 0 ] args = items [ 1 ] kwargs = items [ 2 ] self . _backend . do_command ( command , * args , ** kwargs ) self . _draw_watchers ()","title":"draw()"},{"location":"world/#aitk.robots.world.World.from_json","text":"Load a json config file. Source code in robots/world.py def from_json ( self , config ): \"\"\" Load a json config file. \"\"\" self . config = config seed = config . get ( \"seed\" , 0 ) self . set_seed ( seed ) if \"filename\" in config : self . filename = config [ \"filename\" ] if \"quiet\" in config : self . quiet = config [ \"quiet\" ] if \"width\" in config : self . width = config [ \"width\" ] if \"height\" in config : self . height = config [ \"height\" ] if \"scale\" in config : self . scale = config [ \"scale\" ] if \"smell_cell_size\" in config : self . smell_cell_size = config [ \"smell_cell_size\" ] if self . smell_cell_size is None : self . smell_cell_size = max (( self . width * self . height ) // 20000 , 1 ) if \"boundary_wall\" in config : self . boundary_wall = config [ \"boundary_wall\" ] if \"boundary_wall_color\" in config : self . boundary_wall_color = Color ( config [ \"boundary_wall_color\" ]) if \"boundary_wall_width\" in config : self . boundary_wall_width = config [ \"boundary_wall_width\" ] if \"ground_color\" in config : self . ground_color = Color ( config [ \"ground_color\" ]) if \"ground_image_filename\" in config : self . set_ground_image ( config [ \"ground_image_filename\" ], show = False ) # Now, we create the grid: self . _grid = Grid ( self . width , self . height , self . smell_cell_size ) self . _grid . update_walls ( self . _walls ) # Add walls: self . _add_boundary_walls () for wall in config . get ( \"walls\" , []): # Walls are either \"boxes\" with 4 lines, or a single line: if \"wtype\" not in wall or wall [ \"wtype\" ] == \"box\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = True , ) elif wall [ \"wtype\" ] == \"line\" : self . add_wall ( wall [ \"color\" ], wall [ \"p1\" ][ \"x\" ], wall [ \"p1\" ][ \"y\" ], wall [ \"p2\" ][ \"x\" ], wall [ \"p2\" ][ \"y\" ], box = False , ) for bulb in config . get ( \"bulbs\" , []): # bulbs are {x, y, z, color, brightness} self . _add_bulb ( ** bulb ) for food in config . get ( \"food\" , []): # food x, y, standard_deviation self . _add_food ( ** food ) ## Create robot, and add to world: for i , robotConfig in enumerate ( self . config . get ( \"robots\" , [])): # FIXME: raise if lengths don't match if i < len ( self . _robots ): # already a robot; let's reuse it: robot = self . _robots [ i ] robot . _initialize () robot . from_json ( robotConfig ) else : robot = Robot ( ** robotConfig ) self . add_robot ( robot ) # Create the backend if first time: if self . _backend is None : self . _backend = make_backend ( self . width , self . height , self . scale ) # Update the backend if it already existed, but differs in config self . _backend . update_dimensions ( self . width , self . height , self . scale )","title":"from_json()"},{"location":"world/#aitk.robots.world.World.get_bulb","text":"Get the bulb by name or index. Equivalent to world.bulbs[item] Parameters: Name Type Description Default item int or string index or name of bulb required Source code in robots/world.py def get_bulb ( self , item ): \"\"\" Get the bulb by name or index. Equivalent to world.bulbs[item] Args: item (int or string): index or name of bulb \"\"\" return self . bulbs [ item ]","title":"get_bulb()"},{"location":"world/#aitk.robots.world.World.get_ground_color_at","text":"Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required radius int size of area 1 Source code in robots/world.py def get_ground_color_at ( self , x , y , radius = 1 ): \"\"\" Get the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate radius (int): size of area \"\"\" if self . _ground_image : results = [] for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): results . append ( self . _ground_image_pixels [ (( x + i ) * self . scale , ( y + j ) * self . scale ) ] ) return results","title":"get_ground_color_at()"},{"location":"world/#aitk.robots.world.World.get_image","text":"Get a PIL image of the world, or of a robot. Parameters: Name Type Description Default index str or int index of robot None size int size of robot picture 100 Source code in robots/world.py def get_image ( self , index = None , size = 100 ): \"\"\" Get a PIL image of the world, or of a robot. Args: index (str or int, optional): index of robot size (int, optional): size of robot picture \"\"\" try : picture = self . _backend . get_image ( self . time ) except RuntimeError : raise Exception ( \"Backend is not ready yet; try again\" ) if index is not None : robot = self . robots [ index ] if robot : start_x = round ( max ( robot . x * self . scale - size / 2 , 0 )) start_y = round ( max ( robot . y * self . scale - size / 2 , 0 )) rectangle = ( start_x , start_y , min ( start_x + size , self . width * self . scale ), min ( start_y + size , self . height * self . scale ), ) picture = picture . crop ( rectangle ) return picture else : return picture","title":"get_image()"},{"location":"world/#aitk.robots.world.World.get_robot","text":"Get the robot by name or index. Equivalent to world.robots[item] Parameters: Name Type Description Default item int or string index or name of robot required Source code in robots/world.py def get_robot ( self , item ): \"\"\" Get the robot by name or index. Equivalent to world.robots[item] Args: item (int or string): index or name of robot \"\"\" return self . robots [ item ]","title":"get_robot()"},{"location":"world/#aitk.robots.world.World.get_widget","text":"Returns the IPython simulation widget. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def get_widget ( self , width = None , height = None ): \"\"\" Returns the IPython simulation widget. Args: width (int): the width of the world height (int): the height of the world \"\"\" if isinstance ( width , int ): width = \" %s px\" % width if isinstance ( height , int ): height = \" %s px\" % height self . _step_display = \"notebook\" self . update () return self . _backend . get_widget ( width = width , height = height )","title":"get_widget()"},{"location":"world/#aitk.robots.world.World.paste_ground_image","text":"Paste an image onto the ground image. Requires a ground image to have already been set. Parameters: Name Type Description Default image Image a Python Image Library image required x int the x coordinate of upper lefthand corner required y int the y coordinate of upper lefthand corner required Source code in robots/world.py def paste_ground_image ( self , image , x , y ): \"\"\" Paste an image onto the ground image. Requires a ground image to have already been set. Args: image (Image): a Python Image Library image x (int): the x coordinate of upper lefthand corner y (int): the y coordinate of upper lefthand corner \"\"\" if self . _ground_image : self . _ground_image . paste ( image , ( x , y ))","title":"paste_ground_image()"},{"location":"world/#aitk.robots.world.World.record","text":"Create and return a world recorder. Source code in robots/world.py def record ( self ): \"\"\" Create and return a world recorder. \"\"\" from .watchers import Recorder recorder = Recorder ( self ) self . _watchers . append ( recorder ) self . _recording = True return recorder","title":"record()"},{"location":"world/#aitk.robots.world.World.reset","text":"Reloads the config from initialization, or from last save. Source code in robots/world.py def reset ( self ): \"\"\" Reloads the config from initialization, or from last save. \"\"\" self . stop () self . _initialize () self . _reset_watchers () self . _food = [] self . _grid = None self . from_json ( self . config ) self . time = 0.0 for robot in self . _robots : robot . reset () # Re-add the robot's boundaries: wall = Wall ( robot . color , robot , * robot . _bounding_lines , wtype = \"robot\" ) self . _walls . append ( wall ) self . _stop = False # should stop? self . status = \"stopped\" self . update ( show = False ) # twice to allow robots to see each other self . update ( show = False ) self . draw () # force","title":"reset()"},{"location":"world/#aitk.robots.world.World.run","text":"Run the simulator until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False background bool if True, run in the background. False Source code in robots/world.py def run ( self , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , background = False , ): \"\"\" Run the simulator until one of the control functions returns True or Control+C is pressed. Args: function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed background (bool): if True, run in the background. \"\"\" time_step = time_step if time_step is not None else self . time_step if background : if self . _thread is None : kwargs = { \"function\" : function , \"time_step\" : time_step , \"show\" : show , \"real_time\" : real_time , \"show_progress\" : False , \"quiet\" : True , \"background\" : False } print ( \"Starting world.run() in background. Use world.stop()\" ) self . _thread = Thread ( target = self . run , kwargs = kwargs ) self . _thread . start () else : print ( \"The world is already running in the background. Use world.stop()\" ) else : self . steps ( float ( \"inf\" ), function , time_step , show , real_time , show_progress , quiet )","title":"run()"},{"location":"world/#aitk.robots.world.World.save","text":"Save the current state of the world as the config. Source code in robots/world.py def save ( self ): \"\"\" Save the current state of the world as the config. \"\"\" self . config = self . to_json ()","title":"save()"},{"location":"world/#aitk.robots.world.World.save_as","text":"Save the world config JSON as a new file. Parameters: Name Type Description Default filename str the name of the file to save the world in required Source code in robots/world.py def save_as ( self , filename ): \"\"\" Save the world config JSON as a new file. Args: filename (str): the name of the file to save the world in \"\"\" if not filename . endswith ( \".json\" ): filename = filename + \".json\" # First, save internally. self . config = self . to_json () with open ( filename , \"w\" ) as fp : json_dump ( self . to_json (), fp , sort_keys = True , indent = 4 ) self . config [ \"filename\" ] = filename","title":"save_as()"},{"location":"world/#aitk.robots.world.World.save_file","text":"Save the current state of the world as the config, and save it back to disc if it was loaded from disk. Source code in robots/world.py def save_file ( self ): \"\"\" Save the current state of the world as the config, and save it back to disc if it was loaded from disk. \"\"\" # First, save internally. self . config = self . to_json () if self . filename is not None and os . path . exists ( self . filename ): with open ( self . filename , \"w\" ) as fp : json_dump ( self . config , fp , sort_keys = True , indent = 4 ) else : if not self . quiet : print ( \"Saved in memory. Use world.save_as('filename') to save to disk.\" )","title":"save_file()"},{"location":"world/#aitk.robots.world.World.seconds","text":"Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default seconds float how many simulation seconds to run 5.0 function Function either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. None time_step float time unit to advance the world None show bool update the watchers True real_time float run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def seconds ( self , seconds = 5.0 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N seconds, or until one of the control functions returns True or Control+C is pressed. Args: seconds (float): how many simulation seconds to run function (Function): either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (float): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" time_step = time_step if time_step is not None else self . time_step steps = round ( seconds / time_step ) self . steps ( steps , function , time_step , show , real_time , show_progress , quiet )","title":"seconds()"},{"location":"world/#aitk.robots.world.World.set_ground_color_at","text":"Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Parameters: Name Type Description Default x int the x coordinate required y int the y coordinate required pen tuple the (color, radius) to draw with required Source code in robots/world.py def set_ground_color_at ( self , x , y , pen ): \"\"\" Set the pixel(s) of the ground image at position (x,y). Requires a ground image to have already been set. Args: x (int): the x coordinate y (int): the y coordinate pen (tuple): the (color, radius) to draw with \"\"\" if self . _ground_image : color , radius = pen for i in range ( - radius , radius + 1 , 1 ): for j in range ( - radius , radius + 1 , 1 ): try : self . _ground_image_pixels [ (( x * self . scale ) + i , ( y * self . scale ) + j ) ] = color . to_tuple () except Exception : pass","title":"set_ground_color_at()"},{"location":"world/#aitk.robots.world.World.set_ground_image","text":"Set the background image Parameters: Name Type Description Default filename str the name of the image required show bool update the world now if True True Source code in robots/world.py def set_ground_image ( self , filename , show = True ): \"\"\" Set the background image Args: filename (str): the name of the image show (bool): update the world now if True \"\"\" self . ground_image_filename = filename self . _reset_ground_image () if show : self . update ( show = False ) self . draw () # force","title":"set_ground_image()"},{"location":"world/#aitk.robots.world.World.set_scale","text":"Change the scale of the rendered world. Parameters: Name Type Description Default scale float the scale of the world (usually between 0.5 and 10) required Source code in robots/world.py def set_scale ( self , scale ): \"\"\" Change the scale of the rendered world. Args: scale (float): the scale of the world (usually between 0.5 and 10) \"\"\" self . scale = scale self . _backend . update_dimensions ( self . width , self . height , self . scale ) # Save with config self . config [ \"scale\" ] = self . scale self . update ( show = False ) self . draw () # force","title":"set_scale()"},{"location":"world/#aitk.robots.world.World.set_seed","text":"Set the random seed. Source code in robots/world.py def set_seed ( self , seed ): \"\"\" Set the random seed. \"\"\" if seed == 0 : seed = random . randint ( 0 , 9999999 ) if not self . quiet : print ( \"Random seed set to:\" , seed ) else : if not self . quiet : print ( \"Using random seed:\" , seed ) random . seed ( seed ) self . seed = seed self . config [ \"seed\" ] = seed","title":"set_seed()"},{"location":"world/#aitk.robots.world.World.steps","text":"Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Parameters: Name Type Description Default steps int either a finite number, or infinity 1 time_step float time unit to advance the world None show bool update the watchers True real_time bool run simulation in real time True show_progress bool show progress bar True quiet bool if True, do not show the status message when completed False Source code in robots/world.py def steps ( self , steps = 1 , function = None , time_step = None , show = True , real_time = True , show_progress = True , quiet = False , ): \"\"\" Run the simulator for N steps, or until one of the control functions returns True or Control+C is pressed. Args: steps (int): either a finite number, or infinity function (Function) either a single function that takes the world, or a list of functions (or None) that each take a robot. If any function returns True, then simulation will stop. time_step (float): time unit to advance the world show (bool): update the watchers real_time (bool): run simulation in real time show_progress (bool): show progress bar quiet (bool): if True, do not show the status message when completed \"\"\" self . status = \"running\" time_step = time_step if time_step is not None else self . time_step if steps == float ( \"inf\" ): step_iter = count () else : step_iter = range ( steps ) with self . _no_interrupt (): start_real_time = time . monotonic () start_time = self . time for step in progress_bar ( step_iter , show_progress and not quiet , self . _step_display ): if self . _stop : self . status = \"stopped\" break if function is not None : if isinstance ( function , ( list , tuple )): if len ( function ) < len ( self . _robots ): print_once ( \"WARNING: you have not provided a controller function for every robot\" ) # Deterministically run robots round-robin: stop = any ( [ function [ i ]( self . _robots [ i ]) for i in range ( len ( function )) if function [ i ] is not None ] ) else : stop = function ( self ) if stop : break self . _step ( time_step , show = show , real_time = real_time ) self . status = \"stopped\" stop_real_time = time . monotonic () stop_time = self . time speed = ( stop_time - start_time ) / ( stop_real_time - start_real_time ) if steps > 1 and not quiet and not self . quiet : print ( \"Simulation stopped at: %s ; speed %s x real time\" % ( format_time ( self . time ), round ( speed , 2 )) ) if show : self . draw () # force to update any displays","title":"steps()"},{"location":"world/#aitk.robots.world.World.stop","text":"Stop the simulator, if in thread or not. Source code in robots/world.py def stop ( self ): \"\"\" Stop the simulator, if in thread or not. \"\"\" self . _stop = True self . status = \"stopped\" if self . _thread is not None : print ( \"Stopping thread...\" ) self . _thread . join () self . _thread = None","title":"stop()"},{"location":"world/#aitk.robots.world.World.summary","text":"Print a summary of information about the world and all of its robots. Source code in robots/world.py def summary ( self ): \"\"\" Print a summary of information about the world and all of its robots. \"\"\" print ( \"World details:\" ) if self . filename : print ( \"This world was loaded from %r \" % self . filename ) print ( \"Size: %s x %s \" % ( self . width , self . height )) print ( \"Robots:\" ) if len ( self . _robots ) == 0 : print ( \" This world has no robots.\" ) else : print ( \"-\" * 25 ) for i , robot in enumerate ( self . _robots ): print ( \" .robots[ %s or %r ]: %r \" % ( i , robot . name , robot )) robot . summary () print ( \"Food:\" ) if len ( self . _food ) == 0 : print ( \" This world has no food.\" ) else : print ( \"-\" * 25 ) for food in self . _food : print ( \" x: %s , y: %s , brightness: %s \" % ( food [ 0 ], food [ 1 ], food [ 2 ])) print ( \"Lights:\" ) if len ( self . _bulbs ) == 0 : print ( \" This world has no lights.\" ) else : print ( \"-\" * 25 ) for bulb in self . _bulbs : print ( \" x: %s , y: %s , brightness: %s , name: %r , color: %s \" % ( bulb . x , bulb . y , bulb . brightness , bulb . name , bulb . color ))","title":"summary()"},{"location":"world/#aitk.robots.world.World.to_json","text":"Get the world as a JSON dict. Source code in robots/world.py def to_json ( self ): \"\"\" Get the world as a JSON dict. \"\"\" config = { \"seed\" : self . seed , \"width\" : int ( self . width ), \"height\" : int ( self . height ), \"scale\" : self . scale , \"boundary_wall\" : self . boundary_wall , # bool \"boundary_wall_color\" : str ( self . boundary_wall_color ), \"boundary_wall_width\" : self . boundary_wall_width , \"ground_color\" : str ( self . ground_color ), \"ground_image_filename\" : self . ground_image_filename , \"quiet\" : self . quiet , \"smell_cell_size\" : self . smell_cell_size , \"walls\" : [], \"bulbs\" : [], \"robots\" : [], \"food\" : [], } for wall in self . _walls : # Not a boundary wall or robot bounding box: if wall . wtype == \"wall\" : if len ( wall . lines ) == 4 : # Box: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 2 ] . p1 . x , \"y\" : wall . lines [ 2 ] . p1 . y ,}, \"wtype\" : \"box\" , } elif len ( wall . lines ) == 1 : # Line: w = { \"color\" : str ( wall . color ), \"p1\" : { \"x\" : wall . lines [ 0 ] . p1 . x , \"y\" : wall . lines [ 0 ] . p1 . y ,}, \"p2\" : { \"x\" : wall . lines [ 0 ] . p2 . x , \"y\" : wall . lines [ 0 ] . p2 . y ,}, \"wtype\" : \"line\" , } else : raise Exception ( \"invalid wall length; should be 1 or 4: %s \" % len ( wall . lines )) config [ \"walls\" ] . append ( w ) for bulb in self . _bulbs : config [ \"bulbs\" ] . append ( { \"color\" : str ( bulb . color ), \"x\" : bulb . x , \"y\" : bulb . y , \"z\" : bulb . z , \"brightness\" : bulb . brightness , } ) for food in self . _food : config [ \"food\" ] . append ( { \"x\" : food [ 0 ], \"y\" : food [ 1 ], \"standard_deviation\" : food [ 2 ], } ) for robot in self . _robots : config [ \"robots\" ] . append ( robot . to_json ()) return config","title":"to_json()"},{"location":"world/#aitk.robots.world.World.update","text":"Update the world, robots, and devices. Optionally, draw the world. Parameters: Name Type Description Default show bool if True, draw the world. True Source code in robots/world.py def update ( self , show = True ): \"\"\" Update the world, robots, and devices. Optionally, draw the world. Args: show (bool): if True, draw the world. \"\"\" ## Update robots: self . _draw_list = self . _overlay_list [:] for robot in self . _robots : robot . update ( self . _draw_list ) if show : self . _request_draw ()","title":"update()"},{"location":"world/#aitk.robots.world.World.watch","text":"Display a live (dynamically updated) view of the world. Parameters: Name Type Description Default width int the width of the world None height int the height of the world None Source code in robots/world.py def watch ( self , width = None , height = None ): \"\"\" Display a live (dynamically updated) view of the world. Args: width (int): the width of the world height (int): the height of the world \"\"\" # Force update: self . update ( show = True ) # Force draw: self . draw () widget = self . get_widget ( width , height ) display ( widget )","title":"watch()"}]}